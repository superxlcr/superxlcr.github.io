<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="android,源码,">










<meta name="description" content="前言、例子引入、源码分析、总结">
<meta name="keywords" content="android,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJava2源码阅读">
<meta property="og:url" content="https://superxlcr.github.io/2019/01/14/RxJava2源码阅读/index.html">
<meta property="og:site_name" content="superxlcr&#39;s notebook">
<meta property="og:description" content="前言、例子引入、源码分析、总结">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://superxlcr.github.io/2019/01/14/RxJava2源码阅读/1.png">
<meta property="og:image" content="https://superxlcr.github.io/2019/01/14/RxJava2源码阅读/2.png">
<meta property="og:image" content="https://superxlcr.github.io/2019/01/14/RxJava2源码阅读/3.png">
<meta property="og:updated_time" content="2020-05-11T07:23:44.731Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJava2源码阅读">
<meta name="twitter:description" content="前言、例子引入、源码分析、总结">
<meta name="twitter:image" content="https://superxlcr.github.io/2019/01/14/RxJava2源码阅读/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://superxlcr.github.io/2019/01/14/RxJava2源码阅读/">





  <title>RxJava2源码阅读 | superxlcr's notebook</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">superxlcr's notebook</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://superxlcr.github.io/2019/01/14/RxJava2源码阅读/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superxlcr">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="superxlcr's notebook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RxJava2源码阅读</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T11:28:57+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.4k字
                </span>
              

              

              
            </div>
          

          
              <div class="post-description">
                  
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ReactiveX，是一套用可观察流来完成异步编程的api，它的官网是：<br><a href="http://reactivex.io/" target="_blank" rel="noopener">http://reactivex.io/</a><br>而RxJava，则是ReactiveX为Java语言平台提供的api，目前最新版本为2.2.5，github地址为：<br><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">https://github.com/ReactiveX/RxJava</a></p>
<p>博主也在项目中使用了RxJava相关的api，惊叹于其神奇的链式调用，消除了复杂的异步编程层层嵌套导致的回调地狱，并把逻辑流程梳理清晰<br>最近刚好有空，在阅读了RxJava的源码后，在此写下一篇博客记录一下体会</p>
<p>博主阅读的是RxJava2版本的源码，与RxJava1的版本源码有较大出入<br>本文旨在分析RxJava2源码中流程相关的部分，基础的使用方式以及一些操作符说明请自行查询相关文档</p>
<h1 id="例子引入"><a href="#例子引入" class="headerlink" title="例子引入"></a>例子引入</h1><p>假设我们这里有这么一个场景：<br>有一系列的学生数据，我们需要把他们的所有id打印到logCat，然后再把其中的偶数id再次打印，如果熟悉RxJava的童鞋肯定会写出下面相似的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Student&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Student&gt; emitter)</span> </span>&#123;</span><br><span class="line">		List&lt;Student&gt; list = getStudentList();</span><br><span class="line">		<span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">			emitter.onNext(student);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">		.map(<span class="keyword">new</span> Function&lt;Student, Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> student.id;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		.observeOn(Schedulers.newThread())</span><br><span class="line">		.doOnNext(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">				Log.i(TAG, String.valueOf(integer));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		.filter(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> integer % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		.subscribeOn(Schedulers.io())</span><br><span class="line">		.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">		.subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">				Log.i(TAG, String.valueOf(integer));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>

<p>简单介绍下上面代码完成的事情：</p>
<ol>
<li>我们通过Observable#create方法，创建了一个发射学生Student数据的数据源</li>
<li>通过map操作符，我们从Student中获取他们的id</li>
<li>通过observeOn操作符，我们定义下面的工作将在一个新线程中执行</li>
<li>通过doOnNext操作符，我们打印出所有学生的id</li>
<li>通过filter操作符，我们过滤出其中的偶数学生id</li>
<li>通过subscribeOn操作符，我们定义数据源的发射操作在io线程中执行</li>
<li>通过observeOn操作符，我们定义下面的工作将在Android主线程中执行</li>
<li>通过subscribe方法，我们打印出剩下的偶数学生id</li>
</ol>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>值得注意的是，博主在RxJava的github<a href="https://github.com/ReactiveX/RxJava#simple-background-computation" target="_blank" rel="noopener">例子</a>上发现了一段话，它告诉了我们RxJava的流程设计是怎么样子的，相信当我们浏览完源码后再回来看会有更深的体会<br>原文如下：</p>
<blockquote>
<p>This style of chaining methods is called a fluent API which resembles the builder pattern. However, RxJava’s reactive types are immutable; each of the method calls returns a new Flowable with added behavior.</p>
</blockquote>
<p>这段话告诉了我们RxJava中的响应类型是不变的，每次方法的调用都是通过生成一个新的对象来添加新的行为<br>这很容易就让人联想到了使用装饰器模式实现的javaIo，看完源码之后我们会发现两者确实有共通之处</p>
<p>接下来我们一起来阅读下其中的源码，我们分为三个阶段，来看下RxJava真正的流程是怎样的</p>
<h2 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h2><p>首先我们来看下响应类型对象的创建流程<br>就例子而言，我们经过一系列链式调用后（除去subscribe方法）得到的是一个Observable对象</p>
<p>首先我们先来看下Observable#create方法<br>Observable#create:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，第2行的ObjectHelper#requireNonNull用于检测传入的数据是否为null，因为在RxJava的数据流中是不允许出现null的，后续类似的代码我们将忽略<br>第3行的RxJavaPlugins是一个全局的工具类，它允许我们设置一些监听器，在相应的hook点执行我们自己的操作，这里我们默认什么也不做，只返回原本的对象，后续类似的代码我们也将忽略<br>综上，Observable#create方法返回了一个ObservableCreate对象，并把我们写的ObservableOnSubscribe匿名内部类当做构造参数传入持有</p>
<p>接下来我们来看看Observable#map方法<br>Observable#map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(mapper, <span class="string">"mapper is null"</span>);</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map方法也很简单，返回了一个ObservableMap对象，并把Observable#create返回的ObservableCreate对象，以及我们写的Function匿名内部类当做构造参数传入持有<br>值得注意的是，这里返回的Observable的泛型参数已经改变了</p>
<p>接下来我们来看看Observable#observeOn方法<br>Observable#observeOn:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">	ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回了一个ObservableObserveOn对象，持有了map返回的ObservableMap对象，以及我们传入的调度器Schedulers.newThread()</p>
<p>接下来我们来看看Observable#doOnNext方法<br>Observable#doOnNext:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">doOnNext</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doOnEach(onNext, Functions.emptyConsumer(), Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;T&gt; <span class="title">doOnEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError, Action onComplete, Action onAfterTerminate)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(onNext, <span class="string">"onNext is null"</span>);</span><br><span class="line">	ObjectHelper.requireNonNull(onError, <span class="string">"onError is null"</span>);</span><br><span class="line">	ObjectHelper.requireNonNull(onComplete, <span class="string">"onComplete is null"</span>);</span><br><span class="line">	ObjectHelper.requireNonNull(onAfterTerminate, <span class="string">"onAfterTerminate is null"</span>);</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableDoOnEach&lt;T&gt;(<span class="keyword">this</span>, onNext, onError, onComplete, onAfterTerminate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回了一个ObservableDoOnEach对象，持有了observeOn返回的ObservableObserveOn对象，我们传入的Consumer对象以及一些我们并不关心的其他东西</p>
<p>接下来我们来看看Observable#filter方法<br>Observable#filter:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(predicate, <span class="string">"predicate is null"</span>);</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableFilter&lt;T&gt;(<span class="keyword">this</span>, predicate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回了一个ObservableFilter对象，持有了doOnNext返回的ObservableDoOnEach对象，以及我们传入的Predicate对象</p>
<p>接下来我们来看看Observable#subscribeOn方法<br>Observable#subscribeOn:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回了一个ObservableSubscribeOn对象，持有了filter返回的ObservableFilter对象，以及我们传入的调度器Schedulers.io()</p>
<p>接下来又调用了Observable#observeOn方法，返回了一个ObservableObserveOn对象，持有了subscribeOn返回的ObservableSubscribeOn对象，以及我们传入的调度器AndroidSchedulers.mainThread()</p>
<p>可见，在创建阶段，我们获得了一个“层层包裹”的ObservableObserveOn对象<br>就像是在使用java.io中的stream一样，通过装饰器模式“层层包裹”来增强相应的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> ByteArrayInputStream()))</span><br></pre></td></tr></table></figure>

<p>创建阶段具体流程可用下图表示：<br><img src="/2019/01/14/RxJava2源码阅读/1.png" alt="创建流程"></p>
<h2 id="订阅阶段"><a href="#订阅阶段" class="headerlink" title="订阅阶段"></a>订阅阶段</h2><p>接下来，我们对创建阶段得到的ObservableObserveOn对象调用了subscribe方法，这是在父类Observable中的一个final方法，我们一起来看下<br>Observable#subscribe:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError,</span></span></span><br><span class="line"><span class="function"><span class="params">		Action onComplete, Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(onNext, <span class="string">"onNext is null"</span>);</span><br><span class="line">	ObjectHelper.requireNonNull(onError, <span class="string">"onError is null"</span>);</span><br><span class="line">	ObjectHelper.requireNonNull(onComplete, <span class="string">"onComplete is null"</span>);</span><br><span class="line">	ObjectHelper.requireNonNull(onSubscribe, <span class="string">"onSubscribe is null"</span>);</span><br><span class="line"></span><br><span class="line">	LambdaObserver&lt;T&gt; ls = <span class="keyword">new</span> LambdaObserver&lt;T&gt;(onNext, onError, onComplete, onSubscribe);</span><br><span class="line"></span><br><span class="line">	subscribe(ls);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">		ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</span><br><span class="line"></span><br><span class="line">		subscribeActual(observer);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">		<span class="keyword">throw</span> e;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">		Exceptions.throwIfFatal(e);</span><br><span class="line">		<span class="comment">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class="line">		<span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class="line">		RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">		NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">		npe.initCause(e);</span><br><span class="line">		<span class="keyword">throw</span> npe;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码第11行，我们可以看到我们传入的监听器onNext被包装成为了一个LambdaObserver对象<br>接着在第24行，以该对象作为参数调用了ObservableObserveOn#subscribeActual<br>ObservableObserveOn#subscribeActual:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">		source.subscribe(observer);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">		source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在subscribeActual方法中，我们传入的scheduler是AndroidSchedulers.mainThread()，它是一个HandlerScheduler，因此走的是分支语句的else逻辑<br>在这里，我们的LambdaObserver对象被包装成为一个ObserveOnObserver对象，并与scheduler创建的Worker绑定在了一起<br>接着调用了source的subscribe方法，这里的source即是我们构造ObservableObserveOn时传入的“上游”数据源————ObservableSubscribeOn对象</p>
<p>由于Observable#subscribe是一个final方法，无法被子类重写，并且它最终的逻辑都会调用子类的subscribeActual方法，这里我们直接看ObservableSubscribeOn#subscribeActual<br>ObservableSubscribeOn#subscribeActual:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(s);</span><br><span class="line"></span><br><span class="line">	s.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">	parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">	SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">		<span class="keyword">this</span>.parent = parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		source.subscribe(parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在第3行，我们的ObserveOnObserver对象被包装成为了SubscribeOnObserver对象<br>接着在第5行，调用了ObserveOnObserver#onSubscribe<br>ObserveOnObserver#onSubscribe:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.s, s)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.s = s;</span><br><span class="line">		<span class="keyword">if</span> (s <span class="keyword">instanceof</span> QueueDisposable) &#123;</span><br><span class="line">			<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">			QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (m == QueueDisposable.SYNC) &#123;</span><br><span class="line">				sourceMode = m;</span><br><span class="line">				queue = qd;</span><br><span class="line">				done = <span class="keyword">true</span>;</span><br><span class="line">				actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">				schedule();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (m == QueueDisposable.ASYNC) &#123;</span><br><span class="line">				sourceMode = m;</span><br><span class="line">				queue = qd;</span><br><span class="line">				actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		queue = <span class="keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class="line"></span><br><span class="line">		actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过一系列检查后，最终会调用actual对象的onSubscribe方法，而actual对象即是我们构造ObserveOnObserver对象时传入的LambdaObserver对象<br>LambdaObserver#onSubscribe:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DisposableHelper.setOnce(<span class="keyword">this</span>, s)) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			onSubscribe.accept(<span class="keyword">this</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			Exceptions.throwIfFatal(ex);</span><br><span class="line">			s.dispose();</span><br><span class="line">			onError(ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们再例子中没有传入相应的监听器，所以这里onSubscribe是由Functions.emptyConsumer()创建的，什么也不会做<br>如果我们传入了相应的监听器，则会在当前线程收到开始订阅的回调通知（onSubscribe）</p>
<p>回到subscribeActual这里，接着第7行调用了传入的scheduler的scheduleDirect方法，执行了特定的任务SubscribeTask<br>这里我们不去深究具体的代码，由于我们传入的是Schedulers.io()，因此容易得知SubscribeTask#run是在io线程中执行的<br>在第18行，此时我们已经处于io线程中，同上，我们以SubscribeOnObserver对象作为参数，调用了“上游”数据源source————ObservableFilter的subscribe方法<br>ObservableFilter#subscribeActual:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">	source.subscribe(<span class="keyword">new</span> FilterObserver&lt;T&gt;(s, predicate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑比较简单，把传入的SubscribeOnObserver对象与构造时传入的Predicate对象绑定在一起，包装成FilterObserver对象后，调用了“上游”数据源source————ObservableDoOnEach的subscribe方法<br>ObservableDoOnEach#subscribeActual:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; t)</span> </span>&#123;</span><br><span class="line">	source.subscribe(<span class="keyword">new</span> DoOnEachObserver&lt;T&gt;(t, onNext, onError, onComplete, onAfterTerminate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑类似，把传入的FilterObserver对象与构造时传入的Consumer对象绑定在一起，包装成DoOnEachObserver对象后，调用了“上游”数据源source————ObservableObserveOn的subscribe方法</p>
<p>与上面提到的一样，ObservableObserveOn#subscribeActual会把DoOnEachObserver对象与scheduler（Schedulers.newThread()）创建的Worker绑定在了一起，包装成ObserveOnObserver对象，交给“上游”数据源————ObservableMap<br>ObservableMap#subscribeActual:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> U&gt; t)</span> </span>&#123;</span><br><span class="line">	source.subscribe(<span class="keyword">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑类似，把传入的ObserveOnObserver对象与构造时传入的Function对象绑定在一起，包装成MapObserver对象后，交给了“上游”数据源source————ObservableCreate<br>ObservableCreate#subscribeActual:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">	CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">	observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		source.subscribe(parent);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		Exceptions.throwIfFatal(ex);</span><br><span class="line">		parent.onError(ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第3行，传入的MapObserver对象被包装成了CreateEmitter<br>然后在第4行调用了MapObserver#onSubscribe，不过由于我们前面已经回调了订阅事件，因此这里实际上并不会回调到我们的监听器中，有兴趣的童鞋可以进一步看下相关源码<br>在第7行，调用了“上游”数据源source————我们构造的ObservableOnSubscribe匿名内部类的subscribe方法</p>
<p>至此，订阅阶段结束，这次被“层层包裹”的是我们的监听器Observer<br>订阅阶段的流程图如下所示：<br><img src="/2019/01/14/RxJava2源码阅读/2.png" alt="订阅阶段流程图"></p>
<h2 id="发射数据阶段"><a href="#发射数据阶段" class="headerlink" title="发射数据阶段"></a>发射数据阶段</h2><p>在订阅阶段的最后，我们调用了ObservableOnSubscribe匿名内部类的subscribe方法，进入了发射数据的阶段<br>首先，让我们一起来回顾下例子中的代码做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Student&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Student&gt; emitter)</span> </span>&#123;</span><br><span class="line">		List&lt;Student&gt; list = getStudentList();</span><br><span class="line">		<span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">			emitter.onNext(student);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在第4行，我们首先通过getStudentList方法获得了学生数据列表，然后在第6行调用了emitter对象的onNext方法把数据发送了出去<br>根据上文分析，这里的emitter对象实际类型为CreateEmitter，让我们来看下相关的代码<br>CreateEmitter#onNext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</span><br><span class="line"></span><br><span class="line">CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">	<span class="keyword">this</span>.observer = observer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">		onError(<span class="keyword">new</span> NullPointerException(<span class="string">"onNext called with null. Null values are generally not allowed in 2.x operators and sources."</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">		observer.onNext(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑比较简单，首先检查了发送的数据是否为null（因为在RxJava数据流中不允许任何null出现）<br>然后如果是还没Disposed的情况下，把数据传递给了observer对象<br>从构造函数可以看出，observer对象实际类型为订阅阶段传入的MapObserver对象，我们接着看下相关代码<br>MapObserver#onNext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper;</span><br><span class="line"></span><br><span class="line">MapObserver(Observer&lt;? <span class="keyword">super</span> U&gt; actual, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class="line">	<span class="keyword">super</span>(actual);</span><br><span class="line">	<span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	U v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		v = ObjectHelper.requireNonNull(mapper.apply(t), <span class="string">"The mapper function returned a null value."</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		fail(ex);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	actual.onNext(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第15行，调用了我们在订阅阶段时绑定的Function对象进行映射（map）转换<br>在进行了非空检查后，调用了actual对象，即ObserveOnObserver对象的onNext方法，继续数据的传递<br>ObserveOnObserver#onNext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">		queue.offer(t);</span><br><span class="line">	&#125;</span><br><span class="line">	schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">		worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">		drainFused();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		drainNormal();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> missed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class="line">	<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = actual;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="keyword">boolean</span> d = done;</span><br><span class="line">			T v;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				v = q.poll();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				Exceptions.throwIfFatal(ex);</span><br><span class="line">				s.dispose();</span><br><span class="line">				q.clear();</span><br><span class="line">				a.onError(ex);</span><br><span class="line">				worker.dispose();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (empty) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			a.onNext(v);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		missed = addAndGet(-missed);</span><br><span class="line">		<span class="keyword">if</span> (missed == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第6行，ObserveOnObserver首先把数据加入了一个队列中，然后再第8行调用了schedule方法开启线程调度<br>在第13行中，我们看到调用了worker对象的schedule方法，并传入了参数this<br>这里我们不去深究Scheduler调度器的具体实现，根据上下文的含义，不难推断出，由于我们传入的调度器是Schedulers.newThread()，ObserveOnObserver实现的run方法将会在一个新的线程中被调用<br>在run方法中，由于我们没有设置结果合并到一起输出，因此进入的是第22行的drainNormal逻辑<br>最终在第61行，我们会把从队列中取出的数据，在新的线程中，继续传递给“下游”的监听器————DoOnEachObserver</p>
<p>DoOnEachObserver#onNext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DoOnEachObserver(</span><br><span class="line">		Observer&lt;? <span class="keyword">super</span> T&gt; actual,</span><br><span class="line">		Consumer&lt;? <span class="keyword">super</span> T&gt; onNext,</span><br><span class="line">		Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError,</span><br><span class="line">		Action onComplete,</span><br><span class="line">		Action onAfterTerminate) &#123;</span><br><span class="line">	<span class="keyword">this</span>.actual = actual;</span><br><span class="line">	<span class="keyword">this</span>.onNext = onNext;</span><br><span class="line">	<span class="keyword">this</span>.onError = onError;</span><br><span class="line">	<span class="keyword">this</span>.onComplete = onComplete;</span><br><span class="line">	<span class="keyword">this</span>.onAfterTerminate = onAfterTerminate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (done) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		onNext.accept(t);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">		Exceptions.throwIfFatal(e);</span><br><span class="line">		s.dispose();</span><br><span class="line">		onError(e);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	actual.onNext(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑比较简单，交给了绑定的Consumer处理之后，继续把数据传递给“下游”的监听器————FilterObserver<br>FilterObserver#onNext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Predicate&lt;? <span class="keyword">super</span> T&gt; filter;</span><br><span class="line"></span><br><span class="line">FilterObserver(Observer&lt;? <span class="keyword">super</span> T&gt; actual, Predicate&lt;? <span class="keyword">super</span> T&gt; filter) &#123;</span><br><span class="line">	<span class="keyword">super</span>(actual);</span><br><span class="line">	<span class="keyword">this</span>.filter = filter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sourceMode == NONE) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> b;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			b = filter.test(t);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">			fail(e);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (b) &#123;</span><br><span class="line">			actual.onNext(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		actual.onNext(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们没有设置sourceMode，因此默认值为NONE，进入上半部分分支<br>FilterObserver使用订阅阶段绑定的Predicate对象，通过其test方法的返回值判断哪些数据允许往下传递<br>在例子中我们过滤条件为数据为偶数类型，因此test方法只有数据为偶数时才返回true，只有偶数数据才会被传递到“下游”————SubscribeOnObserver</p>
<p>SubscribeOnObserver#onNext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	actual.onNext(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>啥也没干，直接把数据往“下游”（ObserveOnObserver）传递<br>ObserveOnObserver上面我们已经分析过了，这里就不再重复分析了，它会在把线程切换到Android主线程后（这里的调度器是AndroidSchedulers.mainThread()），把数据传递给“下游”————LambdaObserver</p>
<p>LambdaObserver#onNext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LambdaObserver</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError,</span></span></span><br><span class="line"><span class="function"><span class="params">		Action onComplete,</span></span></span><br><span class="line"><span class="function"><span class="params">		Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	<span class="keyword">this</span>.onNext = onNext;</span><br><span class="line">	<span class="keyword">this</span>.onError = onError;</span><br><span class="line">	<span class="keyword">this</span>.onComplete = onComplete;</span><br><span class="line">	<span class="keyword">this</span>.onSubscribe = onSubscribe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			onNext.accept(t);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">			Exceptions.throwIfFatal(e);</span><br><span class="line">			get().dispose();</span><br><span class="line">			onError(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，LambdaObserver会把数据回调给我们一开始实现的Consumer匿名内部类<br>至此，发射数据阶段结束，其流程图如下所示：<br><img src="/2019/01/14/RxJava2源码阅读/3.png" alt="发射数据阶段流程图"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总而言之，RxJava的执行流程可以分为三个阶段：</p>
<ol>
<li>创建阶段：使用装饰器模式“层层包裹”创建出一个 reactive type 对象（这里是Observable）</li>
<li>订阅阶段：使用装饰器模式“层层包裹”我们传入的监听器，不断调用“上游”的subscribe；回调开始订阅事件（onSubscribe），切换订阅线程</li>
<li>发射数据阶段：数据由顶层监听器向“下游”逐级传递，传递数据的同时执行相应的变换操作</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/android/" rel="tag"># android</a>
          
            <a href="/tags/源码/" rel="tag"># 源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/18/LeakCanary，30分钟从入门到精通/" rel="next" title="LeakCanary，30分钟从入门到精通">
                <i class="fa fa-chevron-left"></i> LeakCanary，30分钟从入门到精通
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/20/当我们在说硬件加速渲染，具体指的是什么？/" rel="prev" title="当我们在说硬件加速渲染，具体指的是什么？">
                当我们在说硬件加速渲染，具体指的是什么？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="superxlcr">
            
              <p class="site-author-name" itemprop="name">superxlcr</p>
              <p class="site-description motion-element" itemprop="description">just a programmer.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">185</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/superxlcr" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#例子引入"><span class="nav-number">2.</span> <span class="nav-text">例子引入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码分析"><span class="nav-number">3.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建阶段"><span class="nav-number">3.1.</span> <span class="nav-text">创建阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#订阅阶段"><span class="nav-number">3.2.</span> <span class="nav-text">订阅阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发射数据阶段"><span class="nav-number">3.3.</span> <span class="nav-text">发射数据阶段</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">superxlcr</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
